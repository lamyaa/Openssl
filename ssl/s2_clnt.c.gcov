        -:    0:Source:s2_clnt.c
        -:    0:Graph:s2_clnt.gcno
        -:    0:Data:s2_clnt.gcda
        -:    0:Runs:10000
        -:    0:Programs:1
        -:    1:/* ssl/s2_clnt.c */
        -:    2:/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
        -:    3: * All rights reserved.
        -:    4: *
        -:    5: * This package is an SSL implementation written
        -:    6: * by Eric Young (eay@cryptsoft.com).
        -:    7: * The implementation was written so as to conform with Netscapes SSL.
        -:    8: * 
        -:    9: * This library is free for commercial and non-commercial use as long as
        -:   10: * the following conditions are aheared to.  The following conditions
        -:   11: * apply to all code found in this distribution, be it the RC4, RSA,
        -:   12: * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
        -:   13: * included with this distribution is covered by the same copyright terms
        -:   14: * except that the holder is Tim Hudson (tjh@cryptsoft.com).
        -:   15: * 
        -:   16: * Copyright remains Eric Young's, and as such any Copyright notices in
        -:   17: * the code are not to be removed.
        -:   18: * If this package is used in a product, Eric Young should be given attribution
        -:   19: * as the author of the parts of the library used.
        -:   20: * This can be in the form of a textual message at program startup or
        -:   21: * in documentation (online or textual) provided with the package.
        -:   22: * 
        -:   23: * Redistribution and use in source and binary forms, with or without
        -:   24: * modification, are permitted provided that the following conditions
        -:   25: * are met:
        -:   26: * 1. Redistributions of source code must retain the copyright
        -:   27: *    notice, this list of conditions and the following disclaimer.
        -:   28: * 2. Redistributions in binary form must reproduce the above copyright
        -:   29: *    notice, this list of conditions and the following disclaimer in the
        -:   30: *    documentation and/or other materials provided with the distribution.
        -:   31: * 3. All advertising materials mentioning features or use of this software
        -:   32: *    must display the following acknowledgement:
        -:   33: *    "This product includes cryptographic software written by
        -:   34: *     Eric Young (eay@cryptsoft.com)"
        -:   35: *    The word 'cryptographic' can be left out if the rouines from the library
        -:   36: *    being used are not cryptographic related :-).
        -:   37: * 4. If you include any Windows specific code (or a derivative thereof) from 
        -:   38: *    the apps directory (application code) you must include an acknowledgement:
        -:   39: *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
        -:   40: * 
        -:   41: * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
        -:   42: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   43: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   44: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   45: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   46: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   47: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   48: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   49: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   50: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   51: * SUCH DAMAGE.
        -:   52: * 
        -:   53: * The licence and distribution terms for any publically available version or
        -:   54: * derivative of this code cannot be changed.  i.e. this code cannot simply be
        -:   55: * copied and put under another distribution licence
        -:   56: * [including the GNU Public Licence.]
        -:   57: */
        -:   58:/* ====================================================================
        -:   59: * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
        -:   60: *
        -:   61: * Redistribution and use in source and binary forms, with or without
        -:   62: * modification, are permitted provided that the following conditions
        -:   63: * are met:
        -:   64: *
        -:   65: * 1. Redistributions of source code must retain the above copyright
        -:   66: *    notice, this list of conditions and the following disclaimer. 
        -:   67: *
        -:   68: * 2. Redistributions in binary form must reproduce the above copyright
        -:   69: *    notice, this list of conditions and the following disclaimer in
        -:   70: *    the documentation and/or other materials provided with the
        -:   71: *    distribution.
        -:   72: *
        -:   73: * 3. All advertising materials mentioning features or use of this
        -:   74: *    software must display the following acknowledgment:
        -:   75: *    "This product includes software developed by the OpenSSL Project
        -:   76: *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
        -:   77: *
        -:   78: * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
        -:   79: *    endorse or promote products derived from this software without
        -:   80: *    prior written permission. For written permission, please contact
        -:   81: *    openssl-core@openssl.org.
        -:   82: *
        -:   83: * 5. Products derived from this software may not be called "OpenSSL"
        -:   84: *    nor may "OpenSSL" appear in their names without prior written
        -:   85: *    permission of the OpenSSL Project.
        -:   86: *
        -:   87: * 6. Redistributions of any form whatsoever must retain the following
        -:   88: *    acknowledgment:
        -:   89: *    "This product includes software developed by the OpenSSL Project
        -:   90: *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
        -:   91: *
        -:   92: * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
        -:   93: * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   94: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        -:   95: * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
        -:   96: * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   97: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   98: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   99: * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:  100: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:  101: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        -:  102: * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
        -:  103: * OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  104: * ====================================================================
        -:  105: *
        -:  106: * This product includes cryptographic software written by Eric Young
        -:  107: * (eay@cryptsoft.com).  This product includes software written by Tim
        -:  108: * Hudson (tjh@cryptsoft.com).
        -:  109: *
        -:  110: */
        -:  111:
        -:  112:#include "ssl_locl.h"
        -:  113:#ifndef OPENSSL_NO_SSL2
        -:  114:#include <stdio.h>
        -:  115:#include <openssl/rand.h>
        -:  116:#include <openssl/buffer.h>
        -:  117:#include <openssl/objects.h>
        -:  118:#include <openssl/evp.h>
        -:  119:
        -:  120:static const SSL_METHOD *ssl2_get_client_method(int ver);
        -:  121:static int get_server_finished(SSL *s);
        -:  122:static int get_server_verify(SSL *s);
        -:  123:static int get_server_hello(SSL *s);
        -:  124:static int client_hello(SSL *s); 
        -:  125:static int client_master_key(SSL *s);
        -:  126:static int client_finished(SSL *s);
        -:  127:static int client_certificate(SSL *s);
        -:  128:static int ssl_rsa_public_encrypt(SESS_CERT *sc, int len, unsigned char *from,
        -:  129:	unsigned char *to,int padding);
        -:  130:#define BREAK	break
        -:  131:
    #####:  132:static const SSL_METHOD *ssl2_get_client_method(int ver)
        -:  133:	{
    #####:  134:	if (ver == SSL2_VERSION)
        -:  135:		return(SSLv2_client_method());
        -:  136:	else
    #####:  137:		return(NULL);
        -:  138:	}
        -:  139:
    #####:  140:IMPLEMENT_ssl2_meth_func(SSLv2_client_method,
        -:  141:			ssl_undefined_function,
        -:  142:			ssl2_connect,
        -:  143:			ssl2_get_client_method)
        -:  144:
    #####:  145:int ssl2_connect(SSL *s)
        -:  146:	{
    #####:  147:	unsigned long l=(unsigned long)time(NULL);
        -:  148:	BUF_MEM *buf=NULL;
        -:  149:	int ret= -1;
        -:  150:	void (*cb)(const SSL *ssl,int type,int val)=NULL;
        -:  151:	int new_state,state;
        -:  152:
    #####:  153:	RAND_add(&l,sizeof(l),0);
    #####:  154:	ERR_clear_error();
    #####:  155:	clear_sys_error();
        -:  156:
    #####:  157:	if (s->info_callback != NULL)
        -:  158:		cb=s->info_callback;
    #####:  159:	else if (s->ctx->info_callback != NULL)
        -:  160:		cb=s->ctx->info_callback;
        -:  161:
        -:  162:	/* init things to blank */
    #####:  163:	s->in_handshake++;
    #####:  164:	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
        -:  165:
        -:  166:	for (;;)
        -:  167:		{
    #####:  168:		state=s->state;
        -:  169:
    #####:  170:		switch (s->state)
        -:  171:			{
        -:  172:		case SSL_ST_BEFORE:
        -:  173:		case SSL_ST_CONNECT:
        -:  174:		case SSL_ST_BEFORE|SSL_ST_CONNECT:
        -:  175:		case SSL_ST_OK|SSL_ST_CONNECT:
        -:  176:
    #####:  177:			s->server=0;
    #####:  178:			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
        -:  179:
    #####:  180:			s->version=SSL2_VERSION;
    #####:  181:			s->type=SSL_ST_CONNECT;
        -:  182:
    #####:  183:			buf=s->init_buf;
    #####:  184:			if ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))
        -:  185:				{
        -:  186:				ret= -1;
        -:  187:				goto end;
        -:  188:				}
    #####:  189:			if (!BUF_MEM_grow(buf,
        -:  190:				SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
        -:  191:				{
    #####:  192:				if (buf == s->init_buf)
        -:  193:					buf=NULL;
        -:  194:				ret= -1;
        -:  195:				goto end;
        -:  196:				}
    #####:  197:			s->init_buf=buf;
        -:  198:			buf=NULL;
    #####:  199:			s->init_num=0;
    #####:  200:			s->state=SSL2_ST_SEND_CLIENT_HELLO_A;
    #####:  201:			s->ctx->stats.sess_connect++;
    #####:  202:			s->handshake_func=ssl2_connect;
    #####:  203:			BREAK;
        -:  204:
        -:  205:		case SSL2_ST_SEND_CLIENT_HELLO_A:
        -:  206:		case SSL2_ST_SEND_CLIENT_HELLO_B:
    #####:  207:			s->shutdown=0;
    #####:  208:			ret=client_hello(s);
    #####:  209:			if (ret <= 0) goto end;
    #####:  210:			s->init_num=0;
    #####:  211:			s->state=SSL2_ST_GET_SERVER_HELLO_A;
    #####:  212:			BREAK;
        -:  213:		
        -:  214:		case SSL2_ST_GET_SERVER_HELLO_A:
        -:  215:		case SSL2_ST_GET_SERVER_HELLO_B:
    #####:  216:			ret=get_server_hello(s);
    #####:  217:			if (ret <= 0) goto end;
    #####:  218:			s->init_num=0;
    #####:  219:			if (!s->hit) /* new session */
        -:  220:				{
    #####:  221:				s->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_A;
    #####:  222:				BREAK; 
        -:  223:				}
        -:  224:			else
        -:  225:				{
    #####:  226:				s->state=SSL2_ST_CLIENT_START_ENCRYPTION;
    #####:  227:				break;
        -:  228:				}
        -:  229:	
        -:  230:		case SSL2_ST_SEND_CLIENT_MASTER_KEY_A:
        -:  231:		case SSL2_ST_SEND_CLIENT_MASTER_KEY_B:
    #####:  232:			ret=client_master_key(s);
    #####:  233:			if (ret <= 0) goto end;
    #####:  234:			s->init_num=0;
    #####:  235:			s->state=SSL2_ST_CLIENT_START_ENCRYPTION;
    #####:  236:			break;
        -:  237:
        -:  238:		case SSL2_ST_CLIENT_START_ENCRYPTION:
        -:  239:			/* Ok, we now have all the stuff needed to
        -:  240:			 * start encrypting, so lets fire it up :-) */
    #####:  241:			if (!ssl2_enc_init(s,1))
        -:  242:				{
        -:  243:				ret= -1;
        -:  244:				goto end;
        -:  245:				}
    #####:  246:			s->s2->clear_text=0;
    #####:  247:			s->state=SSL2_ST_SEND_CLIENT_FINISHED_A;
    #####:  248:			break;
        -:  249:
        -:  250:		case SSL2_ST_SEND_CLIENT_FINISHED_A:
        -:  251:		case SSL2_ST_SEND_CLIENT_FINISHED_B:
    #####:  252:			ret=client_finished(s);
    #####:  253:			if (ret <= 0) goto end;
    #####:  254:			s->init_num=0;
    #####:  255:			s->state=SSL2_ST_GET_SERVER_VERIFY_A;
    #####:  256:			break;
        -:  257:
        -:  258:		case SSL2_ST_GET_SERVER_VERIFY_A:
        -:  259:		case SSL2_ST_GET_SERVER_VERIFY_B:
    #####:  260:			ret=get_server_verify(s);
    #####:  261:			if (ret <= 0) goto end;
    #####:  262:			s->init_num=0;
    #####:  263:			s->state=SSL2_ST_GET_SERVER_FINISHED_A;
    #####:  264:			break;
        -:  265:
        -:  266:		case SSL2_ST_GET_SERVER_FINISHED_A:
        -:  267:		case SSL2_ST_GET_SERVER_FINISHED_B:
    #####:  268:			ret=get_server_finished(s);
    #####:  269:			if (ret <= 0) goto end;
        -:  270:			break;
        -:  271:
        -:  272:		case SSL2_ST_SEND_CLIENT_CERTIFICATE_A:
        -:  273:		case SSL2_ST_SEND_CLIENT_CERTIFICATE_B:
        -:  274:		case SSL2_ST_SEND_CLIENT_CERTIFICATE_C:
        -:  275:		case SSL2_ST_SEND_CLIENT_CERTIFICATE_D:
        -:  276:		case SSL2_ST_X509_GET_CLIENT_CERTIFICATE:
    #####:  277:			ret=client_certificate(s);
    #####:  278:			if (ret <= 0) goto end;
    #####:  279:			s->init_num=0;
    #####:  280:			s->state=SSL2_ST_GET_SERVER_FINISHED_A;
    #####:  281:			break;
        -:  282:
        -:  283:		case SSL_ST_OK:
    #####:  284:			if (s->init_buf != NULL)
        -:  285:				{
    #####:  286:				BUF_MEM_free(s->init_buf);
    #####:  287:				s->init_buf=NULL;
        -:  288:				}
    #####:  289:			s->init_num=0;
        -:  290:		/*	ERR_clear_error();*/
        -:  291:
        -:  292:			/* If we want to cache session-ids in the client
        -:  293:			 * and we successfully add the session-id to the
        -:  294:			 * cache, and there is a callback, then pass it out.
        -:  295:			 * 26/11/96 - eay - only add if not a re-used session.
        -:  296:			 */
        -:  297:
    #####:  298:			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
    #####:  299:			if (s->hit) s->ctx->stats.sess_hit++;
        -:  300:
        -:  301:			ret=1;
        -:  302:			/* s->server=0; */
    #####:  303:			s->ctx->stats.sess_connect_good++;
        -:  304:
    #####:  305:			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
        -:  306:
        -:  307:			goto end;
        -:  308:			/* break; */
        -:  309:		default:
    #####:  310:			SSLerr(SSL_F_SSL2_CONNECT,SSL_R_UNKNOWN_STATE);
    #####:  311:			return(-1);
        -:  312:			/* break; */
        -:  313:			}
        -:  314:
    #####:  315:		if ((cb != NULL) && (s->state != state))
        -:  316:			{
        -:  317:			new_state=s->state;
    #####:  318:			s->state=state;
    #####:  319:			cb(s,SSL_CB_CONNECT_LOOP,1);
    #####:  320:			s->state=new_state;
        -:  321:			}
        -:  322:		}
        -:  323:end:
    #####:  324:	s->in_handshake--;
    #####:  325:	if (buf != NULL)
    #####:  326:		BUF_MEM_free(buf);
    #####:  327:	if (cb != NULL) 
    #####:  328:		cb(s,SSL_CB_CONNECT_EXIT,ret);
    #####:  329:	return(ret);
        -:  330:	}
        -:  331:
    #####:  332:static int get_server_hello(SSL *s)
        -:  333:	{
        -:  334:	unsigned char *buf;
        -:  335:	unsigned char *p;
        -:  336:	int i,j;
        -:  337:	unsigned long len;
        -:  338:	STACK_OF(SSL_CIPHER) *sk=NULL,*cl, *prio, *allow;
        -:  339:
    #####:  340:	buf=(unsigned char *)s->init_buf->data;
        -:  341:	p=buf;
    #####:  342:	if (s->state == SSL2_ST_GET_SERVER_HELLO_A)
        -:  343:		{
    #####:  344:		i=ssl2_read(s,(char *)&(buf[s->init_num]),11-s->init_num);
    #####:  345:		if (i < (11-s->init_num)) 
    #####:  346:			return(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));
    #####:  347:		s->init_num = 11;
        -:  348:
    #####:  349:		if (*(p++) != SSL2_MT_SERVER_HELLO)
        -:  350:			{
    #####:  351:			if (p[-1] != SSL2_MT_ERROR)
        -:  352:				{
    #####:  353:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  354:				SSLerr(SSL_F_GET_SERVER_HELLO,
        -:  355:					SSL_R_READ_WRONG_PACKET_TYPE);
        -:  356:				}
        -:  357:			else
    #####:  358:				SSLerr(SSL_F_GET_SERVER_HELLO,
        -:  359:					SSL_R_PEER_ERROR);
        -:  360:			return(-1);
        -:  361:			}
        -:  362:#if 0
        -:  363:		s->hit=(*(p++))?1:0;
        -:  364:		/* Some [PPC?] compilers fail to increment p in above
        -:  365:		   statement, e.g. one provided with Rhapsody 5.5, but
        -:  366:		   most recent example XL C 11.1 for AIX, even without
        -:  367:		   optimization flag... */
        -:  368:#else
    #####:  369:		s->hit=(*p)?1:0; p++;
        -:  370:#endif
    #####:  371:		s->s2->tmp.cert_type= *(p++);
    #####:  372:		n2s(p,i);
    #####:  373:		if (i < s->version) s->version=i;
    #####:  374:		n2s(p,i); s->s2->tmp.cert_length=i;
    #####:  375:		n2s(p,i); s->s2->tmp.csl=i;
    #####:  376:		n2s(p,i); s->s2->tmp.conn_id_length=i;
    #####:  377:		s->state=SSL2_ST_GET_SERVER_HELLO_B;
        -:  378:		}
        -:  379:
        -:  380:	/* SSL2_ST_GET_SERVER_HELLO_B */
    #####:  381:	len = 11 + (unsigned long)s->s2->tmp.cert_length + (unsigned long)s->s2->tmp.csl + (unsigned long)s->s2->tmp.conn_id_length;
    #####:  382:	if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)
        -:  383:		{
    #####:  384:		SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_MESSAGE_TOO_LONG);
    #####:  385:		return -1;
        -:  386:		}
    #####:  387:	j = (int)len - s->init_num;
    #####:  388:	i = ssl2_read(s,(char *)&(buf[s->init_num]),j);
    #####:  389:	if (i != j) return(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));
    #####:  390:	if (s->msg_callback)
    #####:  391:		s->msg_callback(0, s->version, 0, buf, (size_t)len, s, s->msg_callback_arg); /* SERVER-HELLO */
        -:  392:
        -:  393:	/* things are looking good */
        -:  394:
    #####:  395:	p = buf + 11;
    #####:  396:	if (s->hit)
        -:  397:		{
    #####:  398:		if (s->s2->tmp.cert_length != 0) 
        -:  399:			{
    #####:  400:			SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_LENGTH_NOT_ZERO);
    #####:  401:			return(-1);
        -:  402:			}
    #####:  403:		if (s->s2->tmp.cert_type != 0)
        -:  404:			{
    #####:  405:			if (!(s->options &
        -:  406:				SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG))
        -:  407:				{
    #####:  408:				SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_TYPE_NOT_ZERO);
    #####:  409:				return(-1);
        -:  410:				}
        -:  411:			}
    #####:  412:		if (s->s2->tmp.csl != 0)
        -:  413:			{
    #####:  414:			SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CIPHER_LIST_NOT_ZERO);
    #####:  415:			return(-1);
        -:  416:			}
        -:  417:		}
        -:  418:	else
        -:  419:		{
        -:  420:#ifdef undef
        -:  421:		/* very bad */
        -:  422:		memset(s->session->session_id,0,
        -:  423:			SSL_MAX_SSL_SESSION_ID_LENGTH_IN_BYTES);
        -:  424:		s->session->session_id_length=0;
        -:  425:		*/
        -:  426:#endif
        -:  427:
        -:  428:		/* we need to do this in case we were trying to reuse a 
        -:  429:		 * client session but others are already reusing it.
        -:  430:		 * If this was a new 'blank' session ID, the session-id
        -:  431:		 * length will still be 0 */
    #####:  432:		if (s->session->session_id_length > 0)
        -:  433:			{
    #####:  434:			if (!ssl_get_new_session(s,0))
        -:  435:				{
    #####:  436:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  437:				return(-1);
        -:  438:				}
        -:  439:			}
        -:  440:
    #####:  441:		if (ssl2_set_certificate(s,s->s2->tmp.cert_type,
    #####:  442:			s->s2->tmp.cert_length,p) <= 0)
        -:  443:			{
    #####:  444:			ssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);
    #####:  445:			return(-1);
        -:  446:			}
    #####:  447:		p+=s->s2->tmp.cert_length;
        -:  448:
    #####:  449:		if (s->s2->tmp.csl == 0)
        -:  450:			{
    #####:  451:			ssl2_return_error(s,SSL2_PE_NO_CIPHER);
    #####:  452:			SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_LIST);
    #####:  453:			return(-1);
        -:  454:			}
        -:  455:
        -:  456:		/* We have just received a list of ciphers back from the
        -:  457:		 * server.  We need to get the ones that match, then select
        -:  458:		 * the one we want the most :-). */
        -:  459:
        -:  460:		/* load the ciphers */
    #####:  461:		sk=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.csl,
    #####:  462:					    &s->session->ciphers);
    #####:  463:		p+=s->s2->tmp.csl;
    #####:  464:		if (sk == NULL)
        -:  465:			{
    #####:  466:			ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  467:			SSLerr(SSL_F_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);
    #####:  468:			return(-1);
        -:  469:			}
        -:  470:
    #####:  471:		(void)sk_SSL_CIPHER_set_cmp_func(sk,ssl_cipher_ptr_id_cmp);
        -:  472:
        -:  473:		/* get the array of ciphers we will accept */
    #####:  474:		cl=SSL_get_ciphers(s);
    #####:  475:		(void)sk_SSL_CIPHER_set_cmp_func(cl,ssl_cipher_ptr_id_cmp);
        -:  476:
        -:  477:		/*
        -:  478:		 * If server preference flag set, choose the first
        -:  479:		 * (highest priority) cipher the server sends, otherwise
        -:  480:		 * client preference has priority.
        -:  481:		 */
    #####:  482:		if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)
        -:  483:		    {
        -:  484:		    prio = sk;
        -:  485:		    allow = cl;
        -:  486:		    }
        -:  487:		else
        -:  488:		    {
        -:  489:		    prio = cl;
        -:  490:		    allow = sk;
        -:  491:		    }
        -:  492:		/* In theory we could have ciphers sent back that we
        -:  493:		 * don't want to use but that does not matter since we
        -:  494:		 * will check against the list we originally sent and
        -:  495:		 * for performance reasons we should not bother to match
        -:  496:		 * the two lists up just to check. */
    #####:  497:		for (i=0; i<sk_SSL_CIPHER_num(prio); i++)
        -:  498:			{
    #####:  499:			if (sk_SSL_CIPHER_find(allow,
        -:  500:					     sk_SSL_CIPHER_value(prio,i)) >= 0)
        -:  501:				break;
        -:  502:			}
        -:  503:
    #####:  504:		if (i >= sk_SSL_CIPHER_num(prio))
        -:  505:			{
    #####:  506:			ssl2_return_error(s,SSL2_PE_NO_CIPHER);
    #####:  507:			SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_MATCH);
    #####:  508:			return(-1);
        -:  509:			}
    #####:  510:		s->session->cipher=sk_SSL_CIPHER_value(prio,i);
        -:  511:
        -:  512:
    #####:  513:		if (s->session->peer != NULL) /* can't happen*/
        -:  514:			{
    #####:  515:			ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
    #####:  516:			SSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
    #####:  517:			return(-1);
        -:  518:			}
        -:  519:
    #####:  520:		s->session->peer = s->session->sess_cert->peer_key->x509;
        -:  521:		/* peer_key->x509 has been set by ssl2_set_certificate. */
    #####:  522:		CRYPTO_add(&s->session->peer->references, 1, CRYPTO_LOCK_X509);
        -:  523:		}
        -:  524:
    #####:  525:	if (s->session->sess_cert == NULL 
    #####:  526:      || s->session->peer != s->session->sess_cert->peer_key->x509)
        -:  527:		/* can't happen */
        -:  528:		{
    #####:  529:		ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
    #####:  530:		SSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
    #####:  531:		return(-1);
        -:  532:		}
        -:  533:		
    #####:  534:	s->s2->conn_id_length=s->s2->tmp.conn_id_length;
    #####:  535:	if (s->s2->conn_id_length > sizeof s->s2->conn_id)
        -:  536:		{
    #####:  537:		ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
    #####:  538:		SSLerr(SSL_F_GET_SERVER_HELLO, SSL_R_SSL2_CONNECTION_ID_TOO_LONG);
    #####:  539:		return -1;
        -:  540:		}
    #####:  541:	memcpy(s->s2->conn_id,p,s->s2->tmp.conn_id_length);
    #####:  542:	return(1);
        -:  543:	}
        -:  544:
    #####:  545:static int client_hello(SSL *s)
        -:  546:	{
        -:  547:	unsigned char *buf;
        -:  548:	unsigned char *p,*d;
        -:  549:/*	CIPHER **cipher;*/
        -:  550:	int i,n,j;
        -:  551:
    #####:  552:	buf=(unsigned char *)s->init_buf->data;
    #####:  553:	if (s->state == SSL2_ST_SEND_CLIENT_HELLO_A)
        -:  554:		{
    #####:  555:		if ((s->session == NULL) ||
    #####:  556:			(s->session->ssl_version != s->version))
        -:  557:			{
    #####:  558:			if (!ssl_get_new_session(s,0))
        -:  559:				{
    #####:  560:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  561:				return(-1);
        -:  562:				}
        -:  563:			}
        -:  564:		/* else use the pre-loaded session */
        -:  565:
        -:  566:		p=buf;					/* header */
    #####:  567:		d=p+9;					/* data section */
    #####:  568:		*(p++)=SSL2_MT_CLIENT_HELLO;		/* type */
    #####:  569:		s2n(SSL2_VERSION,p);			/* version */
        -:  570:		n=j=0;
        -:  571:
    #####:  572:		n=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),d,0);
    #####:  573:		d+=n;
        -:  574:
    #####:  575:		if (n == 0)
        -:  576:			{
    #####:  577:			SSLerr(SSL_F_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
    #####:  578:			return(-1);
        -:  579:			}
        -:  580:
    #####:  581:		s2n(n,p);			/* cipher spec num bytes */
        -:  582:
    #####:  583:		if ((s->session->session_id_length > 0) &&
        -:  584:			(s->session->session_id_length <=
        -:  585:			SSL2_MAX_SSL_SESSION_ID_LENGTH))
        -:  586:			{
    #####:  587:			i=s->session->session_id_length;
    #####:  588:			s2n(i,p);		/* session id length */
    #####:  589:			memcpy(d,s->session->session_id,(unsigned int)i);
    #####:  590:			d+=i;
        -:  591:			}
        -:  592:		else
        -:  593:			{
    #####:  594:			s2n(0,p);
        -:  595:			}
        -:  596:
    #####:  597:		s->s2->challenge_length=SSL2_CHALLENGE_LENGTH;
    #####:  598:		s2n(SSL2_CHALLENGE_LENGTH,p);		/* challenge length */
        -:  599:		/*challenge id data*/
    #####:  600:		if (RAND_pseudo_bytes(s->s2->challenge,SSL2_CHALLENGE_LENGTH) <= 0)
        -:  601:			return -1;
    #####:  602:		memcpy(d,s->s2->challenge,SSL2_CHALLENGE_LENGTH);
    #####:  603:		d+=SSL2_CHALLENGE_LENGTH;
        -:  604:
    #####:  605:		s->state=SSL2_ST_SEND_CLIENT_HELLO_B;
    #####:  606:		s->init_num=d-buf;
    #####:  607:		s->init_off=0;
        -:  608:		}
        -:  609:	/* SSL2_ST_SEND_CLIENT_HELLO_B */
    #####:  610:	return(ssl2_do_write(s));
        -:  611:	}
        -:  612:
    #####:  613:static int client_master_key(SSL *s)
        -:  614:	{
        -:  615:	unsigned char *buf;
        -:  616:	unsigned char *p,*d;
        -:  617:	int clear,enc,karg,i;
        -:  618:	SSL_SESSION *sess;
        -:  619:	const EVP_CIPHER *c;
        -:  620:	const EVP_MD *md;
        -:  621:
    #####:  622:	buf=(unsigned char *)s->init_buf->data;
    #####:  623:	if (s->state == SSL2_ST_SEND_CLIENT_MASTER_KEY_A)
        -:  624:		{
        -:  625:
    #####:  626:		if (!ssl_cipher_get_evp(s->session,&c,&md,NULL,NULL,NULL))
        -:  627:			{
    #####:  628:			ssl2_return_error(s,SSL2_PE_NO_CIPHER);
    #####:  629:			SSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);
    #####:  630:			return(-1);
        -:  631:			}
    #####:  632:		sess=s->session;
        -:  633:		p=buf;
    #####:  634:		d=p+10;
    #####:  635:		*(p++)=SSL2_MT_CLIENT_MASTER_KEY;/* type */
        -:  636:
    #####:  637:		i=ssl_put_cipher_by_char(s,sess->cipher,p);
    #####:  638:		p+=i;
        -:  639:
        -:  640:		/* make key_arg data */
    #####:  641:		i=EVP_CIPHER_iv_length(c);
    #####:  642:		sess->key_arg_length=i;
    #####:  643:		if (i > SSL_MAX_KEY_ARG_LENGTH)
        -:  644:			{
    #####:  645:			ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
    #####:  646:			SSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
    #####:  647:			return -1;
        -:  648:			}
    #####:  649:		if (i > 0)
    #####:  650:			if (RAND_pseudo_bytes(sess->key_arg,i) <= 0)
        -:  651:				return -1;
        -:  652:
        -:  653:		/* make a master key */
    #####:  654:		i=EVP_CIPHER_key_length(c);
    #####:  655:		sess->master_key_length=i;
    #####:  656:		if (i > 0)
        -:  657:			{
    #####:  658:			if (i > (int)sizeof(sess->master_key))
        -:  659:				{
    #####:  660:				ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
    #####:  661:				SSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
    #####:  662:				return -1;
        -:  663:				}
    #####:  664:			if (RAND_bytes(sess->master_key,i) <= 0)
        -:  665:				{
    #####:  666:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  667:				return(-1);
        -:  668:				}
        -:  669:			}
        -:  670:
    #####:  671:		if (sess->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)
        -:  672:			enc=8;
    #####:  673:		else if (SSL_C_IS_EXPORT(sess->cipher))
        -:  674:			enc=5;
        -:  675:		else
        -:  676:			enc=i;
        -:  677:
    #####:  678:		if ((int)i < enc)
        -:  679:			{
    #####:  680:			ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  681:			SSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_CIPHER_TABLE_SRC_ERROR);
    #####:  682:			return(-1);
        -:  683:			}
    #####:  684:		clear=i-enc;
    #####:  685:		s2n(clear,p);
    #####:  686:		memcpy(d,sess->master_key,(unsigned int)clear);
    #####:  687:		d+=clear;
        -:  688:
    #####:  689:		enc=ssl_rsa_public_encrypt(sess->sess_cert,enc,
        -:  690:			&(sess->master_key[clear]),d,
    #####:  691:			(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);
    #####:  692:		if (enc <= 0)
        -:  693:			{
    #####:  694:			ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  695:			SSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PUBLIC_KEY_ENCRYPT_ERROR);
    #####:  696:			return(-1);
        -:  697:			}
        -:  698:#ifdef PKCS1_CHECK
        -:  699:		if (s->options & SSL_OP_PKCS1_CHECK_1) d[1]++;
        -:  700:		if (s->options & SSL_OP_PKCS1_CHECK_2)
        -:  701:			sess->master_key[clear]++;
        -:  702:#endif
    #####:  703:		s2n(enc,p);
    #####:  704:		d+=enc;
    #####:  705:		karg=sess->key_arg_length;	
    #####:  706:		s2n(karg,p); /* key arg size */
    #####:  707:		if (karg > (int)sizeof(sess->key_arg))
        -:  708:			{
    #####:  709:			ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  710:			SSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
    #####:  711:			return -1;
        -:  712:			}
    #####:  713:		memcpy(d,sess->key_arg,(unsigned int)karg);
    #####:  714:		d+=karg;
        -:  715:
    #####:  716:		s->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_B;
    #####:  717:		s->init_num=d-buf;
    #####:  718:		s->init_off=0;
        -:  719:		}
        -:  720:
        -:  721:	/* SSL2_ST_SEND_CLIENT_MASTER_KEY_B */
    #####:  722:	return(ssl2_do_write(s));
        -:  723:	}
        -:  724:
    #####:  725:static int client_finished(SSL *s)
        -:  726:	{
        -:  727:	unsigned char *p;
        -:  728:
    #####:  729:	if (s->state == SSL2_ST_SEND_CLIENT_FINISHED_A)
        -:  730:		{
    #####:  731:		p=(unsigned char *)s->init_buf->data;
    #####:  732:		*(p++)=SSL2_MT_CLIENT_FINISHED;
    #####:  733:		if (s->s2->conn_id_length > sizeof s->s2->conn_id)
        -:  734:			{
    #####:  735:			SSLerr(SSL_F_CLIENT_FINISHED, ERR_R_INTERNAL_ERROR);
    #####:  736:			return -1;
        -:  737:			}
    #####:  738:		memcpy(p,s->s2->conn_id,(unsigned int)s->s2->conn_id_length);
        -:  739:
    #####:  740:		s->state=SSL2_ST_SEND_CLIENT_FINISHED_B;
    #####:  741:		s->init_num=s->s2->conn_id_length+1;
    #####:  742:		s->init_off=0;
        -:  743:		}
    #####:  744:	return(ssl2_do_write(s));
        -:  745:	}
        -:  746:
        -:  747:/* read the data and then respond */
    #####:  748:static int client_certificate(SSL *s)
        -:  749:	{
        -:  750:	unsigned char *buf;
        -:  751:	unsigned char *p,*d;
        -:  752:	int i;
        -:  753:	unsigned int n;
        -:  754:	int cert_ch_len;
        -:  755:	unsigned char *cert_ch;
        -:  756:
    #####:  757:	buf=(unsigned char *)s->init_buf->data;
        -:  758:
        -:  759:	/* We have a cert associated with the SSL, so attach it to
        -:  760:	 * the session if it does not have one */
        -:  761:
    #####:  762:	if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_A)
        -:  763:		{
    #####:  764:		i=ssl2_read(s,(char *)&(buf[s->init_num]),
    #####:  765:			SSL2_MAX_CERT_CHALLENGE_LENGTH+2-s->init_num);
    #####:  766:		if (i<(SSL2_MIN_CERT_CHALLENGE_LENGTH+2-s->init_num))
    #####:  767:			return(ssl2_part_read(s,SSL_F_CLIENT_CERTIFICATE,i));
    #####:  768:		s->init_num += i;
    #####:  769:		if (s->msg_callback)
    #####:  770:			s->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg); /* REQUEST-CERTIFICATE */
        -:  771:
        -:  772:		/* type=buf[0]; */
        -:  773:		/* type eq x509 */
    #####:  774:		if (buf[1] != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)
        -:  775:			{
    #####:  776:			ssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);
    #####:  777:			SSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_AUTHENTICATION_TYPE);
    #####:  778:			return(-1);
        -:  779:			}
        -:  780:
    #####:  781:		if ((s->cert == NULL) ||
    #####:  782:			(s->cert->key->x509 == NULL) ||
    #####:  783:			(s->cert->key->privatekey == NULL))
        -:  784:			{
    #####:  785:			s->state=SSL2_ST_X509_GET_CLIENT_CERTIFICATE;
        -:  786:			}
        -:  787:		else
    #####:  788:			s->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;
        -:  789:		}
        -:  790:
    #####:  791:	cert_ch = buf + 2;
    #####:  792:	cert_ch_len = s->init_num - 2;
        -:  793:
    #####:  794:	if (s->state == SSL2_ST_X509_GET_CLIENT_CERTIFICATE)
        -:  795:		{
    #####:  796:		X509 *x509=NULL;
    #####:  797:		EVP_PKEY *pkey=NULL;
        -:  798:
        -:  799:		/* If we get an error we need to
        -:  800:		 * ssl->rwstate=SSL_X509_LOOKUP;
        -:  801:		 * return(error);
        -:  802:		 * We should then be retried when things are ok and we
        -:  803:		 * can get a cert or not */
        -:  804:
        -:  805:		i=0;
    #####:  806:		if (s->ctx->client_cert_cb != NULL)
        -:  807:			{
    #####:  808:			i=s->ctx->client_cert_cb(s,&(x509),&(pkey));
        -:  809:			}
        -:  810:
    #####:  811:		if (i < 0)
        -:  812:			{
    #####:  813:			s->rwstate=SSL_X509_LOOKUP;
    #####:  814:			return(-1);
        -:  815:			}
    #####:  816:		s->rwstate=SSL_NOTHING;
        -:  817:
    #####:  818:		if ((i == 1) && (pkey != NULL) && (x509 != NULL))
        -:  819:			{
    #####:  820:			s->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;
    #####:  821:			if (	!SSL_use_certificate(s,x509) || 
    #####:  822:				!SSL_use_PrivateKey(s,pkey))
        -:  823:				{
        -:  824:				i=0;
        -:  825:				}
    #####:  826:			X509_free(x509);
    #####:  827:			EVP_PKEY_free(pkey);
        -:  828:			}
    #####:  829:		else if (i == 1)
        -:  830:			{
    #####:  831:			if (x509 != NULL) X509_free(x509);
    #####:  832:			if (pkey != NULL) EVP_PKEY_free(pkey);
    #####:  833:			SSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
        -:  834:			i=0;
        -:  835:			}
        -:  836:
    #####:  837:		if (i == 0)
        -:  838:			{
        -:  839:			/* We have no client certificate to respond with
        -:  840:			 * so send the correct error message back */
    #####:  841:			s->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_B;
    #####:  842:			p=buf;
    #####:  843:			*(p++)=SSL2_MT_ERROR;
    #####:  844:			s2n(SSL2_PE_NO_CERTIFICATE,p);
    #####:  845:			s->init_off=0;
    #####:  846:			s->init_num=3;
        -:  847:			/* Write is done at the end */
        -:  848:			}
        -:  849:		}
        -:  850:
    #####:  851:	if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_B)
        -:  852:		{
    #####:  853:		return(ssl2_do_write(s));
        -:  854:		}
        -:  855:
    #####:  856:	if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_C)
        -:  857:		{
        -:  858:		EVP_MD_CTX ctx;
        -:  859:
        -:  860:		/* ok, now we calculate the checksum
        -:  861:		 * do it first so we can reuse buf :-) */
    #####:  862:		p=buf;
    #####:  863:		EVP_MD_CTX_init(&ctx);
    #####:  864:		EVP_SignInit_ex(&ctx,s->ctx->rsa_md5, NULL);
    #####:  865:		EVP_SignUpdate(&ctx,s->s2->key_material,
        -:  866:			       s->s2->key_material_length);
    #####:  867:		EVP_SignUpdate(&ctx,cert_ch,(unsigned int)cert_ch_len);
    #####:  868:		i=i2d_X509(s->session->sess_cert->peer_key->x509,&p);
        -:  869:		/* Don't update the signature if it fails - FIXME: probably should handle this better */
    #####:  870:		if(i > 0)
    #####:  871:			EVP_SignUpdate(&ctx,buf,(unsigned int)i);
        -:  872:
    #####:  873:		p=buf;
    #####:  874:		d=p+6;
    #####:  875:		*(p++)=SSL2_MT_CLIENT_CERTIFICATE;
    #####:  876:		*(p++)=SSL2_CT_X509_CERTIFICATE;
    #####:  877:		n=i2d_X509(s->cert->key->x509,&d);
    #####:  878:		s2n(n,p);
        -:  879:
    #####:  880:		if (!EVP_SignFinal(&ctx,d,&n,s->cert->key->privatekey))
        -:  881:			{
        -:  882:			/* this is not good.  If things have failed it
        -:  883:			 * means there so something wrong with the key.
        -:  884:			 * We will continue with a 0 length signature
        -:  885:			 */
        -:  886:			}
    #####:  887:		EVP_MD_CTX_cleanup(&ctx);
    #####:  888:		s2n(n,p);
    #####:  889:		d+=n;
        -:  890:
    #####:  891:		s->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_D;
    #####:  892:		s->init_num=d-buf;
    #####:  893:		s->init_off=0;
        -:  894:		}
        -:  895:	/* if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_D) */
    #####:  896:	return(ssl2_do_write(s));
        -:  897:	}
        -:  898:
    #####:  899:static int get_server_verify(SSL *s)
        -:  900:	{
        -:  901:	unsigned char *p;
        -:  902:	int i, n, len;
        -:  903:
    #####:  904:	p=(unsigned char *)s->init_buf->data;
    #####:  905:	if (s->state == SSL2_ST_GET_SERVER_VERIFY_A)
        -:  906:		{
    #####:  907:		i=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);
    #####:  908:		if (i < (1-s->init_num)) 
    #####:  909:			return(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));
    #####:  910:		s->init_num += i;
        -:  911:
    #####:  912:		s->state= SSL2_ST_GET_SERVER_VERIFY_B;
    #####:  913:		if (*p != SSL2_MT_SERVER_VERIFY)
        -:  914:			{
    #####:  915:			if (p[0] != SSL2_MT_ERROR)
        -:  916:				{
    #####:  917:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  918:				SSLerr(SSL_F_GET_SERVER_VERIFY,
        -:  919:					SSL_R_READ_WRONG_PACKET_TYPE);
        -:  920:				}
        -:  921:			else
        -:  922:				{
    #####:  923:				SSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_PEER_ERROR);
        -:  924:				/* try to read the error message */
    #####:  925:				i=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);
    #####:  926:				return ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);
        -:  927:				}
    #####:  928:			return(-1);
        -:  929:			}
        -:  930:		}
        -:  931:	
    #####:  932:	p=(unsigned char *)s->init_buf->data;
    #####:  933:	len = 1 + s->s2->challenge_length;
    #####:  934:	n =  len - s->init_num;
    #####:  935:	i = ssl2_read(s,(char *)&(p[s->init_num]),n);
    #####:  936:	if (i < n)
    #####:  937:		return(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));
    #####:  938:	if (s->msg_callback)
    #####:  939:		s->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg); /* SERVER-VERIFY */
    #####:  940:	p += 1;
        -:  941:
    #####:  942:	if (CRYPTO_memcmp(p,s->s2->challenge,s->s2->challenge_length) != 0)
        -:  943:		{
    #####:  944:		ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  945:		SSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_CHALLENGE_IS_DIFFERENT);
    #####:  946:		return(-1);
        -:  947:		}
        -:  948:	return(1);
        -:  949:	}
        -:  950:
    #####:  951:static int get_server_finished(SSL *s)
        -:  952:	{
        -:  953:	unsigned char *buf;
        -:  954:	unsigned char *p;
        -:  955:	int i, n, len;
        -:  956:
    #####:  957:	buf=(unsigned char *)s->init_buf->data;
        -:  958:	p=buf;
    #####:  959:	if (s->state == SSL2_ST_GET_SERVER_FINISHED_A)
        -:  960:		{
    #####:  961:		i=ssl2_read(s,(char *)&(buf[s->init_num]),1-s->init_num);
    #####:  962:		if (i < (1-s->init_num))
    #####:  963:			return(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));
    #####:  964:		s->init_num += i;
        -:  965:
    #####:  966:		if (*p == SSL2_MT_REQUEST_CERTIFICATE)
        -:  967:			{
    #####:  968:			s->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_A;
    #####:  969:			return(1);
        -:  970:			}
    #####:  971:		else if (*p != SSL2_MT_SERVER_FINISHED)
        -:  972:			{
    #####:  973:			if (p[0] != SSL2_MT_ERROR)
        -:  974:				{
    #####:  975:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####:  976:				SSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);
        -:  977:				}
        -:  978:			else
        -:  979:				{
    #####:  980:				SSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_PEER_ERROR);
        -:  981:				/* try to read the error message */
    #####:  982:				i=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);
    #####:  983:				return ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);
        -:  984:				}
    #####:  985:			return(-1);
        -:  986:			}
    #####:  987:		s->state=SSL2_ST_GET_SERVER_FINISHED_B;
        -:  988:		}
        -:  989:
        -:  990:	len = 1 + SSL2_SSL_SESSION_ID_LENGTH;
    #####:  991:	n = len - s->init_num;
    #####:  992:	i = ssl2_read(s,(char *)&(buf[s->init_num]), n);
    #####:  993:	if (i < n) /* XXX could be shorter than SSL2_SSL_SESSION_ID_LENGTH, that's the maximum */
    #####:  994:		return(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));
    #####:  995:	s->init_num += i;
    #####:  996:	if (s->msg_callback)
    #####:  997:		s->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg); /* SERVER-FINISHED */
        -:  998:
    #####:  999:	if (!s->hit) /* new session */
        -: 1000:		{
        -: 1001:		/* new session-id */
        -: 1002:		/* Make sure we were not trying to re-use an old SSL_SESSION
        -: 1003:		 * or bad things can happen */
        -: 1004:		/* ZZZZZZZZZZZZZ */
    #####: 1005:		s->session->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;
    #####: 1006:		memcpy(s->session->session_id,p+1,SSL2_SSL_SESSION_ID_LENGTH);
        -: 1007:		}
        -: 1008:	else
        -: 1009:		{
    #####: 1010:		if (!(s->options & SSL_OP_MICROSOFT_SESS_ID_BUG))
        -: 1011:			{
    #####: 1012:			if ((s->session->session_id_length > sizeof s->session->session_id)
    #####: 1013:			    || (0 != memcmp(buf + 1, s->session->session_id,
        -: 1014:			                    (unsigned int)s->session->session_id_length)))
        -: 1015:				{
    #####: 1016:				ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
    #####: 1017:				SSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_SSL_SESSION_ID_IS_DIFFERENT);
    #####: 1018:				return(-1);
        -: 1019:				}
        -: 1020:			}
        -: 1021:		}
    #####: 1022:	s->state = SSL_ST_OK;
    #####: 1023:	return(1);
        -: 1024:	}
        -: 1025:
        -: 1026:/* loads in the certificate from the server */
    #####: 1027:int ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data)
        -: 1028:	{
        -: 1029:	STACK_OF(X509) *sk=NULL;
        -: 1030:	EVP_PKEY *pkey=NULL;
        -: 1031:	SESS_CERT *sc=NULL;
        -: 1032:	int i;
        -: 1033:	X509 *x509=NULL;
        -: 1034:	int ret=0;
        -: 1035:	
    #####: 1036:	x509=d2i_X509(NULL,&data,(long)len);
    #####: 1037:	if (x509 == NULL)
        -: 1038:		{
    #####: 1039:		SSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_X509_LIB);
    #####: 1040:		goto err;
        -: 1041:		}
        -: 1042:
    #####: 1043:	if ((sk=sk_X509_new_null()) == NULL || !sk_X509_push(sk,x509))
        -: 1044:		{
    #####: 1045:		SSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_MALLOC_FAILURE);
    #####: 1046:		goto err;
        -: 1047:		}
        -: 1048:
    #####: 1049:	i=ssl_verify_cert_chain(s,sk);
        -: 1050:		
    #####: 1051:	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0))
        -: 1052:		{
    #####: 1053:		SSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);
    #####: 1054:		goto err;
        -: 1055:		}
    #####: 1056:	ERR_clear_error(); /* but we keep s->verify_result */
    #####: 1057:	s->session->verify_result = s->verify_result;
        -: 1058:
        -: 1059:	/* server's cert for this session */
    #####: 1060:	sc=ssl_sess_cert_new();
    #####: 1061:	if (sc == NULL)
        -: 1062:		{
        -: 1063:		ret= -1;
        -: 1064:		goto err;
        -: 1065:		}
    #####: 1066:	if (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);
    #####: 1067:	s->session->sess_cert=sc;
        -: 1068:
    #####: 1069:	sc->peer_pkeys[SSL_PKEY_RSA_ENC].x509=x509;
    #####: 1070:	sc->peer_key= &(sc->peer_pkeys[SSL_PKEY_RSA_ENC]);
        -: 1071:
    #####: 1072:	pkey=X509_get_pubkey(x509);
        -: 1073:	x509=NULL;
    #####: 1074:	if (pkey == NULL)
        -: 1075:		{
    #####: 1076:		SSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY);
    #####: 1077:		goto err;
        -: 1078:		}
    #####: 1079:	if (pkey->type != EVP_PKEY_RSA)
        -: 1080:		{
    #####: 1081:		SSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_PUBLIC_KEY_NOT_RSA);
    #####: 1082:		goto err;
        -: 1083:		}
        -: 1084:
    #####: 1085:	if (!ssl_set_peer_cert_type(sc,SSL2_CT_X509_CERTIFICATE))
        -: 1086:		goto err;
        -: 1087:	ret=1;
        -: 1088:err:
    #####: 1089:	sk_X509_free(sk);
    #####: 1090:	X509_free(x509);
    #####: 1091:	EVP_PKEY_free(pkey);
    #####: 1092:	return(ret);
        -: 1093:	}
        -: 1094:
    #####: 1095:static int ssl_rsa_public_encrypt(SESS_CERT *sc, int len, unsigned char *from,
        -: 1096:	     unsigned char *to, int padding)
        -: 1097:	{
        -: 1098:	EVP_PKEY *pkey=NULL;
        -: 1099:	int i= -1;
        -: 1100:
    #####: 1101:	if ((sc == NULL) || (sc->peer_key->x509 == NULL) ||
        -: 1102:		((pkey=X509_get_pubkey(sc->peer_key->x509)) == NULL))
        -: 1103:		{
    #####: 1104:		SSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_NO_PUBLICKEY);
    #####: 1105:		return(-1);
        -: 1106:		}
    #####: 1107:	if (pkey->type != EVP_PKEY_RSA)
        -: 1108:		{
    #####: 1109:		SSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);
    #####: 1110:		goto end;
        -: 1111:		}
        -: 1112:
        -: 1113:	/* we have the public key */
    #####: 1114:	i=RSA_public_encrypt(len,from,to,pkey->pkey.rsa,padding);
    #####: 1115:	if (i < 0)
    #####: 1116:		SSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,ERR_R_RSA_LIB);
        -: 1117:end:
    #####: 1118:	EVP_PKEY_free(pkey);
    #####: 1119:	return(i);
        -: 1120:	}
        -: 1121:#else /* !OPENSSL_NO_SSL2 */
        -: 1122:
        -: 1123:# if PEDANTIC
        -: 1124:static void *dummy=&dummy;
        -: 1125:# endif
        -: 1126:
        -: 1127:#endif
