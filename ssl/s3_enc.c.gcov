        -:    0:Source:s3_enc.c
        -:    0:Graph:s3_enc.gcno
        -:    0:Data:s3_enc.gcda
        -:    0:Runs:10000
        -:    0:Programs:1
        -:    1:/* ssl/s3_enc.c */
        -:    2:/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
        -:    3: * All rights reserved.
        -:    4: *
        -:    5: * This package is an SSL implementation written
        -:    6: * by Eric Young (eay@cryptsoft.com).
        -:    7: * The implementation was written so as to conform with Netscapes SSL.
        -:    8: * 
        -:    9: * This library is free for commercial and non-commercial use as long as
        -:   10: * the following conditions are aheared to.  The following conditions
        -:   11: * apply to all code found in this distribution, be it the RC4, RSA,
        -:   12: * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
        -:   13: * included with this distribution is covered by the same copyright terms
        -:   14: * except that the holder is Tim Hudson (tjh@cryptsoft.com).
        -:   15: * 
        -:   16: * Copyright remains Eric Young's, and as such any Copyright notices in
        -:   17: * the code are not to be removed.
        -:   18: * If this package is used in a product, Eric Young should be given attribution
        -:   19: * as the author of the parts of the library used.
        -:   20: * This can be in the form of a textual message at program startup or
        -:   21: * in documentation (online or textual) provided with the package.
        -:   22: * 
        -:   23: * Redistribution and use in source and binary forms, with or without
        -:   24: * modification, are permitted provided that the following conditions
        -:   25: * are met:
        -:   26: * 1. Redistributions of source code must retain the copyright
        -:   27: *    notice, this list of conditions and the following disclaimer.
        -:   28: * 2. Redistributions in binary form must reproduce the above copyright
        -:   29: *    notice, this list of conditions and the following disclaimer in the
        -:   30: *    documentation and/or other materials provided with the distribution.
        -:   31: * 3. All advertising materials mentioning features or use of this software
        -:   32: *    must display the following acknowledgement:
        -:   33: *    "This product includes cryptographic software written by
        -:   34: *     Eric Young (eay@cryptsoft.com)"
        -:   35: *    The word 'cryptographic' can be left out if the rouines from the library
        -:   36: *    being used are not cryptographic related :-).
        -:   37: * 4. If you include any Windows specific code (or a derivative thereof) from 
        -:   38: *    the apps directory (application code) you must include an acknowledgement:
        -:   39: *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
        -:   40: * 
        -:   41: * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
        -:   42: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   43: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   44: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   45: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   46: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   47: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   48: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   49: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   50: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   51: * SUCH DAMAGE.
        -:   52: * 
        -:   53: * The licence and distribution terms for any publically available version or
        -:   54: * derivative of this code cannot be changed.  i.e. this code cannot simply be
        -:   55: * copied and put under another distribution licence
        -:   56: * [including the GNU Public Licence.]
        -:   57: */
        -:   58:/* ====================================================================
        -:   59: * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
        -:   60: *
        -:   61: * Redistribution and use in source and binary forms, with or without
        -:   62: * modification, are permitted provided that the following conditions
        -:   63: * are met:
        -:   64: *
        -:   65: * 1. Redistributions of source code must retain the above copyright
        -:   66: *    notice, this list of conditions and the following disclaimer. 
        -:   67: *
        -:   68: * 2. Redistributions in binary form must reproduce the above copyright
        -:   69: *    notice, this list of conditions and the following disclaimer in
        -:   70: *    the documentation and/or other materials provided with the
        -:   71: *    distribution.
        -:   72: *
        -:   73: * 3. All advertising materials mentioning features or use of this
        -:   74: *    software must display the following acknowledgment:
        -:   75: *    "This product includes software developed by the OpenSSL Project
        -:   76: *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
        -:   77: *
        -:   78: * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
        -:   79: *    endorse or promote products derived from this software without
        -:   80: *    prior written permission. For written permission, please contact
        -:   81: *    openssl-core@openssl.org.
        -:   82: *
        -:   83: * 5. Products derived from this software may not be called "OpenSSL"
        -:   84: *    nor may "OpenSSL" appear in their names without prior written
        -:   85: *    permission of the OpenSSL Project.
        -:   86: *
        -:   87: * 6. Redistributions of any form whatsoever must retain the following
        -:   88: *    acknowledgment:
        -:   89: *    "This product includes software developed by the OpenSSL Project
        -:   90: *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
        -:   91: *
        -:   92: * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
        -:   93: * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   94: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        -:   95: * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
        -:   96: * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   97: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   98: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   99: * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:  100: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:  101: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        -:  102: * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
        -:  103: * OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  104: * ====================================================================
        -:  105: *
        -:  106: * This product includes cryptographic software written by Eric Young
        -:  107: * (eay@cryptsoft.com).  This product includes software written by Tim
        -:  108: * Hudson (tjh@cryptsoft.com).
        -:  109: *
        -:  110: */
        -:  111:/* ====================================================================
        -:  112: * Copyright 2005 Nokia. All rights reserved.
        -:  113: *
        -:  114: * The portions of the attached software ("Contribution") is developed by
        -:  115: * Nokia Corporation and is licensed pursuant to the OpenSSL open source
        -:  116: * license.
        -:  117: *
        -:  118: * The Contribution, originally written by Mika Kousa and Pasi Eronen of
        -:  119: * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
        -:  120: * support (see RFC 4279) to OpenSSL.
        -:  121: *
        -:  122: * No patent licenses or other rights except those expressly stated in
        -:  123: * the OpenSSL open source license shall be deemed granted or received
        -:  124: * expressly, by implication, estoppel, or otherwise.
        -:  125: *
        -:  126: * No assurances are provided by Nokia that the Contribution does not
        -:  127: * infringe the patent or other intellectual property rights of any third
        -:  128: * party or that the license provides you with all the necessary rights
        -:  129: * to make use of the Contribution.
        -:  130: *
        -:  131: * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
        -:  132: * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
        -:  133: * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
        -:  134: * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
        -:  135: * OTHERWISE.
        -:  136: */
        -:  137:
        -:  138:#include <stdio.h>
        -:  139:#include "ssl_locl.h"
        -:  140:#include <openssl/evp.h>
        -:  141:#include <openssl/md5.h>
        -:  142:
        -:  143:static unsigned char ssl3_pad_1[48]={
        -:  144:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
        -:  145:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
        -:  146:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
        -:  147:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
        -:  148:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
        -:  149:	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 };
        -:  150:
        -:  151:static unsigned char ssl3_pad_2[48]={
        -:  152:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
        -:  153:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
        -:  154:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
        -:  155:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
        -:  156:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
        -:  157:	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c };
        -:  158:static int ssl3_handshake_mac(SSL *s, int md_nid,
        -:  159:	const char *sender, int len, unsigned char *p);
    #####:  160:static int ssl3_generate_key_block(SSL *s, unsigned char *km, int num)
        -:  161:	{
        -:  162:	EVP_MD_CTX m5;
        -:  163:	EVP_MD_CTX s1;
        -:  164:	unsigned char buf[16],smd[SHA_DIGEST_LENGTH];
        -:  165:	unsigned char c='A';
        -:  166:	unsigned int i,j,k;
        -:  167:
        -:  168:#ifdef CHARSET_EBCDIC
        -:  169:	c = os_toascii[c]; /*'A' in ASCII */
        -:  170:#endif
        -:  171:	k=0;
    #####:  172:	EVP_MD_CTX_init(&m5);
    #####:  173:	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    #####:  174:	EVP_MD_CTX_init(&s1);
    #####:  175:	for (i=0; (int)i<num; i+=MD5_DIGEST_LENGTH)
        -:  176:		{
    #####:  177:		k++;
    #####:  178:		if (k > sizeof buf)
        -:  179:			{
        -:  180:			/* bug: 'buf' is too small for this ciphersuite */
    #####:  181:			SSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK, ERR_R_INTERNAL_ERROR);
        -:  182:			return 0;
        -:  183:			}
        -:  184:		
    #####:  185:		for (j=0; j<k; j++)
    #####:  186:			buf[j]=c;
    #####:  187:		c++;
    #####:  188:		EVP_DigestInit_ex(&s1,EVP_sha1(), NULL);
    #####:  189:		EVP_DigestUpdate(&s1,buf,k);
    #####:  190:		EVP_DigestUpdate(&s1,s->session->master_key,
    #####:  191:			s->session->master_key_length);
    #####:  192:		EVP_DigestUpdate(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);
    #####:  193:		EVP_DigestUpdate(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);
    #####:  194:		EVP_DigestFinal_ex(&s1,smd,NULL);
        -:  195:
    #####:  196:		EVP_DigestInit_ex(&m5,EVP_md5(), NULL);
    #####:  197:		EVP_DigestUpdate(&m5,s->session->master_key,
    #####:  198:			s->session->master_key_length);
    #####:  199:		EVP_DigestUpdate(&m5,smd,SHA_DIGEST_LENGTH);
    #####:  200:		if ((int)(i+MD5_DIGEST_LENGTH) > num)
        -:  201:			{
    #####:  202:			EVP_DigestFinal_ex(&m5,smd,NULL);
    #####:  203:			memcpy(km,smd,(num-i));
        -:  204:			}
        -:  205:		else
    #####:  206:			EVP_DigestFinal_ex(&m5,km,NULL);
        -:  207:
    #####:  208:		km+=MD5_DIGEST_LENGTH;
        -:  209:		}
    #####:  210:	OPENSSL_cleanse(smd,SHA_DIGEST_LENGTH);
    #####:  211:	EVP_MD_CTX_cleanup(&m5);
    #####:  212:	EVP_MD_CTX_cleanup(&s1);
        -:  213:	return 1;
        -:  214:	}
        -:  215:
    #####:  216:int ssl3_change_cipher_state(SSL *s, int which)
        -:  217:	{
        -:  218:	unsigned char *p,*mac_secret;
        -:  219:	unsigned char exp_key[EVP_MAX_KEY_LENGTH];
        -:  220:	unsigned char exp_iv[EVP_MAX_IV_LENGTH];
        -:  221:	unsigned char *ms,*key,*iv,*er1,*er2;
        -:  222:	EVP_CIPHER_CTX *dd;
        -:  223:	const EVP_CIPHER *c;
        -:  224:#ifndef OPENSSL_NO_COMP
        -:  225:	COMP_METHOD *comp;
        -:  226:#endif
        -:  227:	const EVP_MD *m;
        -:  228:	EVP_MD_CTX md;
        -:  229:	int is_exp,n,i,j,k,cl;
        -:  230:	int reuse_dd = 0;
        -:  231:
    #####:  232:	is_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
    #####:  233:	c=s->s3->tmp.new_sym_enc;
    #####:  234:	m=s->s3->tmp.new_hash;
        -:  235:	/* m == NULL will lead to a crash later */
    #####:  236:	OPENSSL_assert(m);
        -:  237:#ifndef OPENSSL_NO_COMP
    #####:  238:	if (s->s3->tmp.new_compression == NULL)
        -:  239:		comp=NULL;
        -:  240:	else
    #####:  241:		comp=s->s3->tmp.new_compression->method;
        -:  242:#endif
        -:  243:
    #####:  244:	if (which & SSL3_CC_READ)
        -:  245:		{
    #####:  246:		if (s->enc_read_ctx != NULL)
        -:  247:			reuse_dd = 1;
    #####:  248:		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
        -:  249:			goto err;
        -:  250:		else
        -:  251:			/* make sure it's intialized in case we exit later with an error */
    #####:  252:			EVP_CIPHER_CTX_init(s->enc_read_ctx);
    #####:  253:		dd= s->enc_read_ctx;
        -:  254:
    #####:  255:		ssl_replace_hash(&s->read_hash,m);
        -:  256:#ifndef OPENSSL_NO_COMP
        -:  257:		/* COMPRESS */
    #####:  258:		if (s->expand != NULL)
        -:  259:			{
    #####:  260:			COMP_CTX_free(s->expand);
    #####:  261:			s->expand=NULL;
        -:  262:			}
    #####:  263:		if (comp != NULL)
        -:  264:			{
    #####:  265:			s->expand=COMP_CTX_new(comp);
    #####:  266:			if (s->expand == NULL)
        -:  267:				{
    #####:  268:				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
    #####:  269:				goto err2;
        -:  270:				}
    #####:  271:			if (s->s3->rrec.comp == NULL)
    #####:  272:				s->s3->rrec.comp=(unsigned char *)
    #####:  273:					OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);
    #####:  274:			if (s->s3->rrec.comp == NULL)
        -:  275:				goto err;
        -:  276:			}
        -:  277:#endif
    #####:  278:		memset(&(s->s3->read_sequence[0]),0,8);
    #####:  279:		mac_secret= &(s->s3->read_mac_secret[0]);
        -:  280:		}
        -:  281:	else
        -:  282:		{
    #####:  283:		if (s->enc_write_ctx != NULL)
        -:  284:			reuse_dd = 1;
    #####:  285:		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
        -:  286:			goto err;
        -:  287:		else
        -:  288:			/* make sure it's intialized in case we exit later with an error */
    #####:  289:			EVP_CIPHER_CTX_init(s->enc_write_ctx);
    #####:  290:		dd= s->enc_write_ctx;
    #####:  291:		ssl_replace_hash(&s->write_hash,m);
        -:  292:#ifndef OPENSSL_NO_COMP
        -:  293:		/* COMPRESS */
    #####:  294:		if (s->compress != NULL)
        -:  295:			{
    #####:  296:			COMP_CTX_free(s->compress);
    #####:  297:			s->compress=NULL;
        -:  298:			}
    #####:  299:		if (comp != NULL)
        -:  300:			{
    #####:  301:			s->compress=COMP_CTX_new(comp);
    #####:  302:			if (s->compress == NULL)
        -:  303:				{
    #####:  304:				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
    #####:  305:				goto err2;
        -:  306:				}
        -:  307:			}
        -:  308:#endif
    #####:  309:		memset(&(s->s3->write_sequence[0]),0,8);
    #####:  310:		mac_secret= &(s->s3->write_mac_secret[0]);
        -:  311:		}
        -:  312:
    #####:  313:	if (reuse_dd)
    #####:  314:		EVP_CIPHER_CTX_cleanup(dd);
        -:  315:
    #####:  316:	p=s->s3->tmp.key_block;
    #####:  317:	i=EVP_MD_size(m);
    #####:  318:	if (i < 0)
        -:  319:		goto err2;
    #####:  320:	cl=EVP_CIPHER_key_length(c);
        -:  321:	j=is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
    #####:  322:		 cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
        -:  323:	/* Was j=(is_exp)?5:EVP_CIPHER_key_length(c); */
    #####:  324:	k=EVP_CIPHER_iv_length(c);
    #####:  325:	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
    #####:  326:		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
        -:  327:		{
    #####:  328:		ms=  &(p[ 0]); n=i+i;
    #####:  329:		key= &(p[ n]); n+=j+j;
    #####:  330:		iv=  &(p[ n]); n+=k+k;
    #####:  331:		er1= &(s->s3->client_random[0]);
    #####:  332:		er2= &(s->s3->server_random[0]);
        -:  333:		}
        -:  334:	else
        -:  335:		{
        -:  336:		n=i;
    #####:  337:		ms=  &(p[ n]); n+=i+j;
    #####:  338:		key= &(p[ n]); n+=j+k;
    #####:  339:		iv=  &(p[ n]); n+=k;
    #####:  340:		er1= &(s->s3->server_random[0]);
    #####:  341:		er2= &(s->s3->client_random[0]);
        -:  342:		}
        -:  343:
    #####:  344:	if (n > s->s3->tmp.key_block_length)
        -:  345:		{
    #####:  346:		SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
    #####:  347:		goto err2;
        -:  348:		}
        -:  349:
    #####:  350:	EVP_MD_CTX_init(&md);
    #####:  351:	memcpy(mac_secret,ms,i);
    #####:  352:	if (is_exp)
        -:  353:		{
        -:  354:		/* In here I set both the read and write key/iv to the
        -:  355:		 * same value since only the correct one will be used :-).
        -:  356:		 */
    #####:  357:		EVP_DigestInit_ex(&md,EVP_md5(), NULL);
    #####:  358:		EVP_DigestUpdate(&md,key,j);
    #####:  359:		EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
    #####:  360:		EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
    #####:  361:		EVP_DigestFinal_ex(&md,&(exp_key[0]),NULL);
        -:  362:		key= &(exp_key[0]);
        -:  363:
    #####:  364:		if (k > 0)
        -:  365:			{
    #####:  366:			EVP_DigestInit_ex(&md,EVP_md5(), NULL);
    #####:  367:			EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
    #####:  368:			EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
    #####:  369:			EVP_DigestFinal_ex(&md,&(exp_iv[0]),NULL);
        -:  370:			iv= &(exp_iv[0]);
        -:  371:			}
        -:  372:		}
        -:  373:
    #####:  374:	s->session->key_arg_length=0;
        -:  375:
    #####:  376:	EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
        -:  377:
    #####:  378:	OPENSSL_cleanse(&(exp_key[0]),sizeof(exp_key));
    #####:  379:	OPENSSL_cleanse(&(exp_iv[0]),sizeof(exp_iv));
    #####:  380:	EVP_MD_CTX_cleanup(&md);
    #####:  381:	return(1);
        -:  382:err:
    #####:  383:	SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
        -:  384:err2:
        -:  385:	return(0);
        -:  386:	}
        -:  387:
    #####:  388:int ssl3_setup_key_block(SSL *s)
        -:  389:	{
        -:  390:	unsigned char *p;
        -:  391:	const EVP_CIPHER *c;
        -:  392:	const EVP_MD *hash;
        -:  393:	int num;
        -:  394:	int ret = 0;
        -:  395:	SSL_COMP *comp;
        -:  396:
    #####:  397:	if (s->s3->tmp.key_block_length != 0)
        -:  398:		return(1);
        -:  399:
    #####:  400:	if (!ssl_cipher_get_evp(s->session,&c,&hash,NULL,NULL,&comp))
        -:  401:		{
    #####:  402:		SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
    #####:  403:		return(0);
        -:  404:		}
        -:  405:
    #####:  406:	s->s3->tmp.new_sym_enc=c;
    #####:  407:	s->s3->tmp.new_hash=hash;
        -:  408:#ifdef OPENSSL_NO_COMP
        -:  409:	s->s3->tmp.new_compression=NULL;
        -:  410:#else
    #####:  411:	s->s3->tmp.new_compression=comp;
        -:  412:#endif
        -:  413:
    #####:  414:	num=EVP_MD_size(hash);
    #####:  415:	if (num < 0)
        -:  416:		return 0;
        -:  417:
    #####:  418:	num=EVP_CIPHER_key_length(c)+num+EVP_CIPHER_iv_length(c);
    #####:  419:	num*=2;
        -:  420:
    #####:  421:	ssl3_cleanup_key_block(s);
        -:  422:
    #####:  423:	if ((p=OPENSSL_malloc(num)) == NULL)
        -:  424:		goto err;
        -:  425:
    #####:  426:	s->s3->tmp.key_block_length=num;
    #####:  427:	s->s3->tmp.key_block=p;
        -:  428:
    #####:  429:	ret = ssl3_generate_key_block(s,p,num);
        -:  430:
    #####:  431:	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
        -:  432:		{
        -:  433:		/* enable vulnerability countermeasure for CBC ciphers with
        -:  434:		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
        -:  435:		 */
    #####:  436:		s->s3->need_empty_fragments = 1;
        -:  437:
    #####:  438:		if (s->session->cipher != NULL)
        -:  439:			{
    #####:  440:			if (s->session->cipher->algorithm_enc == SSL_eNULL)
    #####:  441:				s->s3->need_empty_fragments = 0;
        -:  442:			
        -:  443:#ifndef OPENSSL_NO_RC4
    #####:  444:			if (s->session->cipher->algorithm_enc == SSL_RC4)
    #####:  445:				s->s3->need_empty_fragments = 0;
        -:  446:#endif
        -:  447:			}
        -:  448:		}
        -:  449:
    #####:  450:	return ret;
        -:  451:		
        -:  452:err:
    #####:  453:	SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
    #####:  454:	return(0);
        -:  455:	}
        -:  456:
    70000:  457:void ssl3_cleanup_key_block(SSL *s)
        -:  458:	{
    70000:  459:	if (s->s3->tmp.key_block != NULL)
        -:  460:		{
    10000:  461:		OPENSSL_cleanse(s->s3->tmp.key_block,
    10000:  462:			s->s3->tmp.key_block_length);
    10000:  463:		OPENSSL_free(s->s3->tmp.key_block);
    10000:  464:		s->s3->tmp.key_block=NULL;
        -:  465:		}
    70000:  466:	s->s3->tmp.key_block_length=0;
    70000:  467:	}
        -:  468:
        -:  469:/* ssl3_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
        -:  470: *
        -:  471: * Returns:
        -:  472: *   0: (in non-constant time) if the record is publically invalid (i.e. too
        -:  473: *       short etc).
        -:  474: *   1: if the record's padding is valid / the encryption was successful.
        -:  475: *   -1: if the record's padding is invalid or, if sending, an internal error
        -:  476: *       occured.
        -:  477: */
    #####:  478:int ssl3_enc(SSL *s, int send)
        -:  479:	{
        -:  480:	SSL3_RECORD *rec;
        -:  481:	EVP_CIPHER_CTX *ds;
        -:  482:	unsigned long l;
        -:  483:	int bs,i,mac_size=0;
        -:  484:	const EVP_CIPHER *enc;
        -:  485:
    #####:  486:	if (send)
        -:  487:		{
    #####:  488:		ds=s->enc_write_ctx;
    #####:  489:		rec= &(s->s3->wrec);
    #####:  490:		if (s->enc_write_ctx == NULL)
        -:  491:			enc=NULL;
        -:  492:		else
    #####:  493:			enc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
        -:  494:		}
        -:  495:	else
        -:  496:		{
    #####:  497:		ds=s->enc_read_ctx;
    #####:  498:		rec= &(s->s3->rrec);
    #####:  499:		if (s->enc_read_ctx == NULL)
        -:  500:			enc=NULL;
        -:  501:		else
    #####:  502:			enc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
        -:  503:		}
        -:  504:
    #####:  505:	if ((s->session == NULL) || (ds == NULL) ||
    #####:  506:		(enc == NULL))
        -:  507:		{
    #####:  508:		memmove(rec->data,rec->input,rec->length);
    #####:  509:		rec->input=rec->data;
        -:  510:		}
        -:  511:	else
        -:  512:		{
    #####:  513:		l=rec->length;
    #####:  514:		bs=EVP_CIPHER_block_size(ds->cipher);
        -:  515:
        -:  516:		/* COMPRESS */
        -:  517:
    #####:  518:		if ((bs != 1) && send)
        -:  519:			{
    #####:  520:			i=bs-((int)l%bs);
        -:  521:
        -:  522:			/* we need to add 'i-1' padding bytes */
    #####:  523:			l+=i;
        -:  524:			/* the last of these zero bytes will be overwritten
        -:  525:			 * with the padding length. */
    #####:  526:			memset(&rec->input[rec->length], 0, i);
    #####:  527:			rec->length+=i;
    #####:  528:			rec->input[l-1]=(i-1);
        -:  529:			}
        -:  530:		
    #####:  531:		if (!send)
        -:  532:			{
    #####:  533:			if (l == 0 || l%bs != 0)
        -:  534:				return 0;
        -:  535:			/* otherwise, rec->length >= bs */
        -:  536:			}
        -:  537:		
    #####:  538:		EVP_Cipher(ds,rec->data,rec->input,l);
        -:  539:
    #####:  540:		if (EVP_MD_CTX_md(s->read_hash) != NULL)
    #####:  541:			mac_size = EVP_MD_CTX_size(s->read_hash);
    #####:  542:		if ((bs != 1) && !send)
    #####:  543:			return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
        -:  544:		}
        -:  545:	return(1);
        -:  546:	}
        -:  547:
    10000:  548:void ssl3_init_finished_mac(SSL *s)
        -:  549:	{
    10000:  550:	if (s->s3->handshake_buffer) BIO_free(s->s3->handshake_buffer);
    10000:  551:	if (s->s3->handshake_dgst) ssl3_free_digest_list(s);
    10000:  552:    s->s3->handshake_buffer=BIO_new(BIO_s_mem());	
    10000:  553:	(void)BIO_set_close(s->s3->handshake_buffer,BIO_CLOSE);
    10000:  554:	}
        -:  555:
    20000:  556:void ssl3_free_digest_list(SSL *s) 
        -:  557:	{
        -:  558:	int i;
    40000:  559:	if (!s->s3->handshake_dgst) return;
    60000:  560:	for (i=0;i<SSL_MAX_DIGEST;i++) 
        -:  561:		{
    60000:  562:		if (s->s3->handshake_dgst[i])
    10000:  563:			EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
        -:  564:		}
    10000:  565:	OPENSSL_free(s->s3->handshake_dgst);
    10000:  566:	s->s3->handshake_dgst=NULL;
        -:  567:	}	
        -:  568:
        -:  569:
        -:  570:
    80000:  571:void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
        -:  572:	{
    80000:  573:	if (s->s3->handshake_buffer && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) 
        -:  574:		{
    40000:  575:		BIO_write (s->s3->handshake_buffer,(void *)buf,len);
        -:  576:		} 
        -:  577:	else 
        -:  578:		{
        -:  579:		int i;
   240000:  580:		for (i=0;i< SSL_MAX_DIGEST;i++) 
        -:  581:			{
   240000:  582:			if (s->s3->handshake_dgst[i]!= NULL)
    40000:  583:			EVP_DigestUpdate(s->s3->handshake_dgst[i],buf,len);
        -:  584:			}
        -:  585:		}	
    80000:  586:	}
        -:  587:
    10000:  588:int ssl3_digest_cached_records(SSL *s)
        -:  589:	{
        -:  590:	int i;
        -:  591:	long mask;
        -:  592:	const EVP_MD *md;
        -:  593:	long hdatalen;
        -:  594:	void *hdata;
        -:  595:
        -:  596:	/* Allocate handshake_dgst array */
    10000:  597:	ssl3_free_digest_list(s);
    10000:  598:	s->s3->handshake_dgst = OPENSSL_malloc(SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));
    10000:  599:	memset(s->s3->handshake_dgst,0,SSL_MAX_DIGEST *sizeof(EVP_MD_CTX *));
    10000:  600:	hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,&hdata);
    10000:  601:	if (hdatalen <= 0)
        -:  602:		{
    #####:  603:		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, SSL_R_BAD_HANDSHAKE_LENGTH);
    #####:  604:		return 0;
        -:  605:		}
        -:  606:
        -:  607:	/* Loop through bitso of algorithm2 field and create MD_CTX-es */
    60000:  608:	for (i=0;ssl_get_handshake_digest(i,&mask,&md); i++) 
        -:  609:		{
    60000:  610:		if ((mask & ssl_get_algorithm2(s)) && md) 
        -:  611:			{
    10000:  612:			s->s3->handshake_dgst[i]=EVP_MD_CTX_create();
        -:  613:#ifdef OPENSSL_FIPS
        -:  614:			if (EVP_MD_nid(md) == NID_md5)
        -:  615:				{
        -:  616:				EVP_MD_CTX_set_flags(s->s3->handshake_dgst[i],
        -:  617:						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
        -:  618:				}
        -:  619:#endif
    10000:  620:			EVP_DigestInit_ex(s->s3->handshake_dgst[i],md,NULL);
    10000:  621:			EVP_DigestUpdate(s->s3->handshake_dgst[i],hdata,hdatalen);
        -:  622:			} 
        -:  623:		else 
        -:  624:			{	
    50000:  625:			s->s3->handshake_dgst[i]=NULL;
        -:  626:			}
        -:  627:		}
    10000:  628:	if (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE))
        -:  629:		{
        -:  630:		/* Free handshake_buffer BIO */
    10000:  631:		BIO_free(s->s3->handshake_buffer);
    10000:  632:		s->s3->handshake_buffer = NULL;
        -:  633:		}
        -:  634:
        -:  635:	return 1;
        -:  636:	}
        -:  637:
    #####:  638:int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p)
        -:  639:	{
    #####:  640:	return(ssl3_handshake_mac(s,md_nid,NULL,0,p));
        -:  641:	}
    #####:  642:int ssl3_final_finish_mac(SSL *s, 
        -:  643:	     const char *sender, int len, unsigned char *p)
        -:  644:	{
        -:  645:	int ret;
    #####:  646:	ret=ssl3_handshake_mac(s,NID_md5,sender,len,p);
    #####:  647:	p+=ret;
    #####:  648:	ret+=ssl3_handshake_mac(s,NID_sha1,sender,len,p);
    #####:  649:	return(ret);
        -:  650:	}
    #####:  651:static int ssl3_handshake_mac(SSL *s, int md_nid,
        -:  652:	     const char *sender, int len, unsigned char *p)
        -:  653:	{
        -:  654:	unsigned int ret;
        -:  655:	int npad,n;
        -:  656:	unsigned int i;
        -:  657:	unsigned char md_buf[EVP_MAX_MD_SIZE];
        -:  658:	EVP_MD_CTX ctx,*d=NULL;
        -:  659:
    #####:  660:	if (s->s3->handshake_buffer) 
    #####:  661:		if (!ssl3_digest_cached_records(s))
        -:  662:			return 0;
        -:  663:
        -:  664:	/* Search for digest of specified type in the handshake_dgst
        -:  665:	 * array*/
    #####:  666:	for (i=0;i<SSL_MAX_DIGEST;i++) 
        -:  667:		{
    #####:  668:		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
        -:  669:		  	{
    #####:  670:		  	d=s->s3->handshake_dgst[i];
    #####:  671:			break;
        -:  672:			}
        -:  673:		}
    #####:  674:	if (!d) {
    #####:  675:		SSLerr(SSL_F_SSL3_HANDSHAKE_MAC,SSL_R_NO_REQUIRED_DIGEST);
    #####:  676:		return 0;
        -:  677:	}	
    #####:  678:	EVP_MD_CTX_init(&ctx);
    #####:  679:	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    #####:  680:	EVP_MD_CTX_copy_ex(&ctx,d);
    #####:  681:	n=EVP_MD_CTX_size(&ctx);
    #####:  682:	if (n < 0)
        -:  683:		return 0;
        -:  684:
    #####:  685:	npad=(48/n)*n;
    #####:  686:	if (sender != NULL)
    #####:  687:		EVP_DigestUpdate(&ctx,sender,len);
    #####:  688:	EVP_DigestUpdate(&ctx,s->session->master_key,
    #####:  689:		s->session->master_key_length);
    #####:  690:	EVP_DigestUpdate(&ctx,ssl3_pad_1,npad);
    #####:  691:	EVP_DigestFinal_ex(&ctx,md_buf,&i);
        -:  692:
    #####:  693:	EVP_DigestInit_ex(&ctx,EVP_MD_CTX_md(&ctx), NULL);
    #####:  694:	EVP_DigestUpdate(&ctx,s->session->master_key,
    #####:  695:		s->session->master_key_length);
    #####:  696:	EVP_DigestUpdate(&ctx,ssl3_pad_2,npad);
    #####:  697:	EVP_DigestUpdate(&ctx,md_buf,i);
    #####:  698:	EVP_DigestFinal_ex(&ctx,p,&ret);
        -:  699:
    #####:  700:	EVP_MD_CTX_cleanup(&ctx);
        -:  701:
    #####:  702:	return((int)ret);
        -:  703:	}
        -:  704:
    #####:  705:int n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
        -:  706:	{
        -:  707:	SSL3_RECORD *rec;
        -:  708:	unsigned char *mac_sec,*seq;
        -:  709:	EVP_MD_CTX md_ctx;
        -:  710:	const EVP_MD_CTX *hash;
        -:  711:	unsigned char *p,rec_char;
        -:  712:	size_t md_size, orig_len;
        -:  713:	int npad;
        -:  714:	int t;
        -:  715:
    #####:  716:	if (send)
        -:  717:		{
    #####:  718:		rec= &(ssl->s3->wrec);
    #####:  719:		mac_sec= &(ssl->s3->write_mac_secret[0]);
    #####:  720:		seq= &(ssl->s3->write_sequence[0]);
    #####:  721:		hash=ssl->write_hash;
        -:  722:		}
        -:  723:	else
        -:  724:		{
    #####:  725:		rec= &(ssl->s3->rrec);
    #####:  726:		mac_sec= &(ssl->s3->read_mac_secret[0]);
    #####:  727:		seq= &(ssl->s3->read_sequence[0]);
    #####:  728:		hash=ssl->read_hash;
        -:  729:		}
        -:  730:
    #####:  731:	t=EVP_MD_CTX_size(hash);
    #####:  732:	if (t < 0)
        -:  733:		return -1;
    #####:  734:	md_size=t;
    #####:  735:	npad=(48/md_size)*md_size;
        -:  736:
        -:  737:	/* kludge: ssl3_cbc_remove_padding passes padding length in rec->type */
    #####:  738:	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
    #####:  739:	rec->type &= 0xff;
        -:  740:
    #####:  741:	if (!send &&
    #####:  742:	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
    #####:  743:	    ssl3_cbc_record_digest_supported(hash))
    #####:  744:		{
        -:  745:		/* This is a CBC-encrypted record. We must avoid leaking any
        -:  746:		 * timing-side channel information about how many blocks of
        -:  747:		 * data we are hashing because that gives an attacker a
        -:  748:		 * timing-oracle. */
        -:  749:
        -:  750:		/* npad is, at most, 48 bytes and that's with MD5:
        -:  751:		 *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.
        -:  752:		 *
        -:  753:		 * With SHA-1 (the largest hash speced for SSLv3) the hash size
        -:  754:		 * goes up 4, but npad goes down by 8, resulting in a smaller
        -:  755:		 * total size. */
        -:  756:		unsigned char header[75];
        -:  757:		unsigned j = 0;
    #####:  758:		memcpy(header+j, mac_sec, md_size);
    #####:  759:		j += md_size;
    #####:  760:		memcpy(header+j, ssl3_pad_1, npad);
    #####:  761:		j += npad;
    #####:  762:		memcpy(header+j, seq, 8);
    #####:  763:		j += 8;
    #####:  764:		header[j++] = rec->type;
    #####:  765:		header[j++] = rec->length >> 8;
    #####:  766:		header[j++] = rec->length & 0xff;
        -:  767:
    #####:  768:		ssl3_cbc_digest_record(
        -:  769:			hash,
        -:  770:			md, &md_size,
    #####:  771:			header, rec->input,
    #####:  772:			rec->length + md_size, orig_len,
        -:  773:			mac_sec, md_size,
        -:  774:			1 /* is SSLv3 */);
        -:  775:		}
        -:  776:	else
        -:  777:		{
        -:  778:		unsigned int md_size_u;
        -:  779:		/* Chop the digest off the end :-) */
    #####:  780:		EVP_MD_CTX_init(&md_ctx);
        -:  781:
    #####:  782:		EVP_MD_CTX_copy_ex( &md_ctx,hash);
    #####:  783:		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
    #####:  784:		EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);
    #####:  785:		EVP_DigestUpdate(&md_ctx,seq,8);
    #####:  786:		rec_char=rec->type;
    #####:  787:		EVP_DigestUpdate(&md_ctx,&rec_char,1);
        -:  788:		p=md;
    #####:  789:		s2n(rec->length,p);
    #####:  790:		EVP_DigestUpdate(&md_ctx,md,2);
    #####:  791:		EVP_DigestUpdate(&md_ctx,rec->input,rec->length);
    #####:  792:		EVP_DigestFinal_ex( &md_ctx,md,NULL);
        -:  793:
    #####:  794:		EVP_MD_CTX_copy_ex( &md_ctx,hash);
    #####:  795:		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
    #####:  796:		EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);
    #####:  797:		EVP_DigestUpdate(&md_ctx,md,md_size);
    #####:  798:		EVP_DigestFinal_ex( &md_ctx,md,&md_size_u);
    #####:  799:		md_size = md_size_u;
        -:  800:
    #####:  801:		EVP_MD_CTX_cleanup(&md_ctx);
        -:  802:	}
        -:  803:
        -:  804:	ssl3_record_sequence_update(seq);
    #####:  805:	return(md_size);
        -:  806:	}
        -:  807:
    #####:  808:void ssl3_record_sequence_update(unsigned char *seq)
        -:  809:	{
        -:  810:	int i;
        -:  811:
    #####:  812:	for (i=7; i>=0; i--)
        -:  813:		{
    #####:  814:		++seq[i];
    #####:  815:		if (seq[i] != 0) break; 
        -:  816:		}
    #####:  817:	}
        -:  818:
    #####:  819:int ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
        -:  820:	     int len)
        -:  821:	{
        -:  822:	static const unsigned char *salt[3]={
        -:  823:#ifndef CHARSET_EBCDIC
        -:  824:		(const unsigned char *)"A",
        -:  825:		(const unsigned char *)"BB",
        -:  826:		(const unsigned char *)"CCC",
        -:  827:#else
        -:  828:		(const unsigned char *)"\x41",
        -:  829:		(const unsigned char *)"\x42\x42",
        -:  830:		(const unsigned char *)"\x43\x43\x43",
        -:  831:#endif
        -:  832:		};
        -:  833:	unsigned char buf[EVP_MAX_MD_SIZE];
        -:  834:	EVP_MD_CTX ctx;
        -:  835:	int i,ret=0;
        -:  836:	unsigned int n;
        -:  837:
    #####:  838:	EVP_MD_CTX_init(&ctx);
    #####:  839:	for (i=0; i<3; i++)
        -:  840:		{
    #####:  841:		EVP_DigestInit_ex(&ctx,s->ctx->sha1, NULL);
    #####:  842:		EVP_DigestUpdate(&ctx,salt[i],strlen((const char *)salt[i]));
    #####:  843:		EVP_DigestUpdate(&ctx,p,len);
    #####:  844:		EVP_DigestUpdate(&ctx,&(s->s3->client_random[0]),
        -:  845:			SSL3_RANDOM_SIZE);
    #####:  846:		EVP_DigestUpdate(&ctx,&(s->s3->server_random[0]),
        -:  847:			SSL3_RANDOM_SIZE);
    #####:  848:		EVP_DigestFinal_ex(&ctx,buf,&n);
        -:  849:
    #####:  850:		EVP_DigestInit_ex(&ctx,s->ctx->md5, NULL);
    #####:  851:		EVP_DigestUpdate(&ctx,p,len);
    #####:  852:		EVP_DigestUpdate(&ctx,buf,n);
    #####:  853:		EVP_DigestFinal_ex(&ctx,out,&n);
    #####:  854:		out+=n;
    #####:  855:		ret+=n;
        -:  856:		}
    #####:  857:	EVP_MD_CTX_cleanup(&ctx);
    #####:  858:	return(ret);
        -:  859:	}
        -:  860:
    #####:  861:int ssl3_alert_code(int code)
        -:  862:	{
        -:  863:	switch (code)
        -:  864:		{
        -:  865:	case SSL_AD_CLOSE_NOTIFY:	return(SSL3_AD_CLOSE_NOTIFY);
        -:  866:	case SSL_AD_UNEXPECTED_MESSAGE:	return(SSL3_AD_UNEXPECTED_MESSAGE);
        -:  867:	case SSL_AD_BAD_RECORD_MAC:	return(SSL3_AD_BAD_RECORD_MAC);
        -:  868:	case SSL_AD_DECRYPTION_FAILED:	return(SSL3_AD_BAD_RECORD_MAC);
        -:  869:	case SSL_AD_RECORD_OVERFLOW:	return(SSL3_AD_BAD_RECORD_MAC);
        -:  870:	case SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);
        -:  871:	case SSL_AD_HANDSHAKE_FAILURE:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  872:	case SSL_AD_NO_CERTIFICATE:	return(SSL3_AD_NO_CERTIFICATE);
        -:  873:	case SSL_AD_BAD_CERTIFICATE:	return(SSL3_AD_BAD_CERTIFICATE);
        -:  874:	case SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);
        -:  875:	case SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);
        -:  876:	case SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);
        -:  877:	case SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);
        -:  878:	case SSL_AD_ILLEGAL_PARAMETER:	return(SSL3_AD_ILLEGAL_PARAMETER);
        -:  879:	case SSL_AD_UNKNOWN_CA:		return(SSL3_AD_BAD_CERTIFICATE);
        -:  880:	case SSL_AD_ACCESS_DENIED:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  881:	case SSL_AD_DECODE_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  882:	case SSL_AD_DECRYPT_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  883:	case SSL_AD_EXPORT_RESTRICTION:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  884:	case SSL_AD_PROTOCOL_VERSION:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  885:	case SSL_AD_INSUFFICIENT_SECURITY:return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  886:	case SSL_AD_INTERNAL_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  887:	case SSL_AD_USER_CANCELLED:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  888:	case SSL_AD_NO_RENEGOTIATION:	return(-1); /* Don't send it :-) */
        -:  889:	case SSL_AD_UNSUPPORTED_EXTENSION: return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  890:	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  891:	case SSL_AD_UNRECOGNIZED_NAME:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  892:	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  893:	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(SSL3_AD_HANDSHAKE_FAILURE);
        -:  894:	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
        -:  895:	default:			return(-1);
        -:  896:		}
        -:  897:	}
        -:  898:
