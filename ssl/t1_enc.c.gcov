        -:    0:Source:t1_enc.c
        -:    0:Graph:t1_enc.gcno
        -:    0:Data:t1_enc.gcda
        -:    0:Runs:10000
        -:    0:Programs:1
        -:    1:/* ssl/t1_enc.c */
        -:    2:/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
        -:    3: * All rights reserved.
        -:    4: *
        -:    5: * This package is an SSL implementation written
        -:    6: * by Eric Young (eay@cryptsoft.com).
        -:    7: * The implementation was written so as to conform with Netscapes SSL.
        -:    8: * 
        -:    9: * This library is free for commercial and non-commercial use as long as
        -:   10: * the following conditions are aheared to.  The following conditions
        -:   11: * apply to all code found in this distribution, be it the RC4, RSA,
        -:   12: * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
        -:   13: * included with this distribution is covered by the same copyright terms
        -:   14: * except that the holder is Tim Hudson (tjh@cryptsoft.com).
        -:   15: * 
        -:   16: * Copyright remains Eric Young's, and as such any Copyright notices in
        -:   17: * the code are not to be removed.
        -:   18: * If this package is used in a product, Eric Young should be given attribution
        -:   19: * as the author of the parts of the library used.
        -:   20: * This can be in the form of a textual message at program startup or
        -:   21: * in documentation (online or textual) provided with the package.
        -:   22: * 
        -:   23: * Redistribution and use in source and binary forms, with or without
        -:   24: * modification, are permitted provided that the following conditions
        -:   25: * are met:
        -:   26: * 1. Redistributions of source code must retain the copyright
        -:   27: *    notice, this list of conditions and the following disclaimer.
        -:   28: * 2. Redistributions in binary form must reproduce the above copyright
        -:   29: *    notice, this list of conditions and the following disclaimer in the
        -:   30: *    documentation and/or other materials provided with the distribution.
        -:   31: * 3. All advertising materials mentioning features or use of this software
        -:   32: *    must display the following acknowledgement:
        -:   33: *    "This product includes cryptographic software written by
        -:   34: *     Eric Young (eay@cryptsoft.com)"
        -:   35: *    The word 'cryptographic' can be left out if the rouines from the library
        -:   36: *    being used are not cryptographic related :-).
        -:   37: * 4. If you include any Windows specific code (or a derivative thereof) from 
        -:   38: *    the apps directory (application code) you must include an acknowledgement:
        -:   39: *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
        -:   40: * 
        -:   41: * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
        -:   42: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   43: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   44: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   45: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   46: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   47: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   48: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   49: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   50: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   51: * SUCH DAMAGE.
        -:   52: * 
        -:   53: * The licence and distribution terms for any publically available version or
        -:   54: * derivative of this code cannot be changed.  i.e. this code cannot simply be
        -:   55: * copied and put under another distribution licence
        -:   56: * [including the GNU Public Licence.]
        -:   57: */
        -:   58:/* ====================================================================
        -:   59: * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
        -:   60: *
        -:   61: * Redistribution and use in source and binary forms, with or without
        -:   62: * modification, are permitted provided that the following conditions
        -:   63: * are met:
        -:   64: *
        -:   65: * 1. Redistributions of source code must retain the above copyright
        -:   66: *    notice, this list of conditions and the following disclaimer. 
        -:   67: *
        -:   68: * 2. Redistributions in binary form must reproduce the above copyright
        -:   69: *    notice, this list of conditions and the following disclaimer in
        -:   70: *    the documentation and/or other materials provided with the
        -:   71: *    distribution.
        -:   72: *
        -:   73: * 3. All advertising materials mentioning features or use of this
        -:   74: *    software must display the following acknowledgment:
        -:   75: *    "This product includes software developed by the OpenSSL Project
        -:   76: *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
        -:   77: *
        -:   78: * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
        -:   79: *    endorse or promote products derived from this software without
        -:   80: *    prior written permission. For written permission, please contact
        -:   81: *    openssl-core@openssl.org.
        -:   82: *
        -:   83: * 5. Products derived from this software may not be called "OpenSSL"
        -:   84: *    nor may "OpenSSL" appear in their names without prior written
        -:   85: *    permission of the OpenSSL Project.
        -:   86: *
        -:   87: * 6. Redistributions of any form whatsoever must retain the following
        -:   88: *    acknowledgment:
        -:   89: *    "This product includes software developed by the OpenSSL Project
        -:   90: *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
        -:   91: *
        -:   92: * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
        -:   93: * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   94: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        -:   95: * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
        -:   96: * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   97: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   98: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   99: * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:  100: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:  101: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        -:  102: * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
        -:  103: * OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  104: * ====================================================================
        -:  105: *
        -:  106: * This product includes cryptographic software written by Eric Young
        -:  107: * (eay@cryptsoft.com).  This product includes software written by Tim
        -:  108: * Hudson (tjh@cryptsoft.com).
        -:  109: *
        -:  110: */
        -:  111:/* ====================================================================
        -:  112: * Copyright 2005 Nokia. All rights reserved.
        -:  113: *
        -:  114: * The portions of the attached software ("Contribution") is developed by
        -:  115: * Nokia Corporation and is licensed pursuant to the OpenSSL open source
        -:  116: * license.
        -:  117: *
        -:  118: * The Contribution, originally written by Mika Kousa and Pasi Eronen of
        -:  119: * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
        -:  120: * support (see RFC 4279) to OpenSSL.
        -:  121: *
        -:  122: * No patent licenses or other rights except those expressly stated in
        -:  123: * the OpenSSL open source license shall be deemed granted or received
        -:  124: * expressly, by implication, estoppel, or otherwise.
        -:  125: *
        -:  126: * No assurances are provided by Nokia that the Contribution does not
        -:  127: * infringe the patent or other intellectual property rights of any third
        -:  128: * party or that the license provides you with all the necessary rights
        -:  129: * to make use of the Contribution.
        -:  130: *
        -:  131: * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
        -:  132: * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
        -:  133: * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
        -:  134: * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
        -:  135: * OTHERWISE.
        -:  136: */
        -:  137:
        -:  138:#include <stdio.h>
        -:  139:#include "ssl_locl.h"
        -:  140:#ifndef OPENSSL_NO_COMP
        -:  141:#include <openssl/comp.h>
        -:  142:#endif
        -:  143:#include <openssl/evp.h>
        -:  144:#include <openssl/hmac.h>
        -:  145:#include <openssl/md5.h>
        -:  146:#include <openssl/rand.h>
        -:  147:#ifdef KSSL_DEBUG
        -:  148:#include <openssl/des.h>
        -:  149:#endif
        -:  150:
        -:  151:/* seed1 through seed5 are virtually concatenated */
    50000:  152:static int tls1_P_hash(const EVP_MD *md, const unsigned char *sec,
        -:  153:			int sec_len,
        -:  154:			const void *seed1, int seed1_len,
        -:  155:			const void *seed2, int seed2_len,
        -:  156:			const void *seed3, int seed3_len,
        -:  157:			const void *seed4, int seed4_len,
        -:  158:			const void *seed5, int seed5_len,
        -:  159:			unsigned char *out, int olen)
        -:  160:	{
        -:  161:	int chunk;
        -:  162:	size_t j;
        -:  163:	EVP_MD_CTX ctx, ctx_tmp;
        -:  164:	EVP_PKEY *mac_key;
        -:  165:	unsigned char A1[EVP_MAX_MD_SIZE];
        -:  166:	size_t A1_len;
        -:  167:	int ret = 0;
        -:  168:	
    50000:  169:	chunk=EVP_MD_size(md);
    50000:  170:	OPENSSL_assert(chunk >= 0);
        -:  171:
    50000:  172:	EVP_MD_CTX_init(&ctx);
    50000:  173:	EVP_MD_CTX_init(&ctx_tmp);
    50000:  174:	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    50000:  175:	EVP_MD_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    50000:  176:	mac_key = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, sec, sec_len);
    50000:  177:	if (!mac_key)
        -:  178:		goto err;
    50000:  179:	if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
        -:  180:		goto err;
    50000:  181:	if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
        -:  182:		goto err;
    50000:  183:	if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
        -:  184:		goto err;
    50000:  185:	if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
        -:  186:		goto err;
    50000:  187:	if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
        -:  188:		goto err;
    50000:  189:	if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
        -:  190:		goto err;
    50000:  191:	if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
        -:  192:		goto err;
    50000:  193:	if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
        -:  194:		goto err;
        -:  195:
        -:  196:	for (;;)
        -:  197:		{
        -:  198:		/* Reinit mac contexts */
    60000:  199:		if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
        -:  200:			goto err;
    60000:  201:		if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
        -:  202:			goto err;
    60000:  203:		if (!EVP_DigestSignUpdate(&ctx,A1,A1_len))
        -:  204:			goto err;
    60000:  205:		if (!EVP_DigestSignUpdate(&ctx_tmp,A1,A1_len))
        -:  206:			goto err;
    60000:  207:		if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
        -:  208:			goto err;
    60000:  209:		if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
        -:  210:			goto err;
    60000:  211:		if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
        -:  212:			goto err;
    60000:  213:		if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
        -:  214:			goto err;
    60000:  215:		if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
        -:  216:			goto err;
        -:  217:
    60000:  218:		if (olen > chunk)
        -:  219:			{
    10000:  220:			if (!EVP_DigestSignFinal(&ctx,out,&j))
        -:  221:				goto err;
    10000:  222:			out+=j;
    10000:  223:			olen-=j;
        -:  224:			/* calc the next A1 value */
    10000:  225:			if (!EVP_DigestSignFinal(&ctx_tmp,A1,&A1_len))
        -:  226:				goto err;
        -:  227:			}
        -:  228:		else	/* last one */
        -:  229:			{
    50000:  230:			if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
        -:  231:				goto err;
    50000:  232:			memcpy(out,A1,olen);
        -:  233:			break;
        -:  234:			}
        -:  235:		}
        -:  236:	ret = 1;
        -:  237:err:
    50000:  238:	EVP_PKEY_free(mac_key);
    50000:  239:	EVP_MD_CTX_cleanup(&ctx);
    50000:  240:	EVP_MD_CTX_cleanup(&ctx_tmp);
    50000:  241:	OPENSSL_cleanse(A1,sizeof(A1));
    50000:  242:	return ret;
        -:  243:	}
        -:  244:
        -:  245:/* seed1 through seed5 are virtually concatenated */
    50000:  246:static int tls1_PRF(long digest_mask,
        -:  247:		     const void *seed1, int seed1_len,
        -:  248:		     const void *seed2, int seed2_len,
        -:  249:		     const void *seed3, int seed3_len,
        -:  250:		     const void *seed4, int seed4_len,
        -:  251:		     const void *seed5, int seed5_len,
        -:  252:		     const unsigned char *sec, int slen,
        -:  253:		     unsigned char *out1,
        -:  254:		     unsigned char *out2, int olen)
        -:  255:	{
        -:  256:	int len,i,idx,count;
        -:  257:	const unsigned char *S1;
        -:  258:	long m;
        -:  259:	const EVP_MD *md;
        -:  260:	int ret = 0;
        -:  261:
        -:  262:	/* Count number of digests and partition sec evenly */
        -:  263:	count=0;
   350000:  264:	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
   300000:  265:		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) count++;
        -:  266:	}	
    50000:  267:	len=slen/count;
    50000:  268:	if (count == 1)
        -:  269:		slen = 0;
        -:  270:	S1=sec;
    50000:  271:	memset(out1,0,olen);
   350000:  272:	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
   300000:  273:		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) {
    50000:  274:			if (!md) {
    #####:  275:				SSLerr(SSL_F_TLS1_PRF,
        -:  276:				SSL_R_UNSUPPORTED_DIGEST_TYPE);
    #####:  277:				goto err;				
        -:  278:			}
    50000:  279:			if (!tls1_P_hash(md ,S1,len+(slen&1),
        -:  280:					seed1,seed1_len,seed2,seed2_len,seed3,seed3_len,seed4,seed4_len,seed5,seed5_len,
        -:  281:					out2,olen))
        -:  282:				goto err;
    50000:  283:			S1+=len;
  1770000:  284:			for (i=0; i<olen; i++)
        -:  285:			{
  1720000:  286:				out1[i]^=out2[i];
        -:  287:			}
        -:  288:		}
        -:  289:	}
        -:  290:	ret = 1;
        -:  291:err:
    50000:  292:	return ret;
        -:  293:}
    10000:  294:static int tls1_generate_key_block(SSL *s, unsigned char *km,
        -:  295:	     unsigned char *tmp, int num)
        -:  296:	{
        -:  297:	int ret;
    20000:  298:	ret = tls1_PRF(ssl_get_algorithm2(s),
        -:  299:		 TLS_MD_KEY_EXPANSION_CONST,TLS_MD_KEY_EXPANSION_CONST_SIZE,
    10000:  300:		 s->s3->server_random,SSL3_RANDOM_SIZE,
    10000:  301:		 s->s3->client_random,SSL3_RANDOM_SIZE,
        -:  302:		 NULL,0,NULL,0,
    20000:  303:		 s->session->master_key,s->session->master_key_length,
        -:  304:		 km,tmp,num);
        -:  305:#ifdef KSSL_DEBUG
        -:  306:	printf("tls1_generate_key_block() ==> %d byte master_key =\n\t",
        -:  307:                s->session->master_key_length);
        -:  308:	{
        -:  309:        int i;
        -:  310:        for (i=0; i < s->session->master_key_length; i++)
        -:  311:                {
        -:  312:                printf("%02X", s->session->master_key[i]);
        -:  313:                }
        -:  314:        printf("\n");  }
        -:  315:#endif    /* KSSL_DEBUG */
    10000:  316:	return ret;
        -:  317:	}
        -:  318:
    20000:  319:int tls1_change_cipher_state(SSL *s, int which)
        -:  320:	{
        -:  321:	static const unsigned char empty[]="";
        -:  322:	unsigned char *p,*mac_secret;
        -:  323:	unsigned char *exp_label;
        -:  324:	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
        -:  325:	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
        -:  326:	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
        -:  327:	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
        -:  328:	unsigned char *ms,*key,*iv;
        -:  329:	int client_write;
        -:  330:	EVP_CIPHER_CTX *dd;
        -:  331:	const EVP_CIPHER *c;
        -:  332:#ifndef OPENSSL_NO_COMP
        -:  333:	const SSL_COMP *comp;
        -:  334:#endif
        -:  335:	const EVP_MD *m;
        -:  336:	int mac_type;
        -:  337:	int *mac_secret_size;
        -:  338:	EVP_MD_CTX *mac_ctx;
        -:  339:	EVP_PKEY *mac_key;
        -:  340:	int is_export,n,i,j,k,exp_label_len,cl;
        -:  341:	int reuse_dd = 0;
        -:  342:
    20000:  343:	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
    20000:  344:	c=s->s3->tmp.new_sym_enc;
    20000:  345:	m=s->s3->tmp.new_hash;
    20000:  346:	mac_type = s->s3->tmp.new_mac_pkey_type;
        -:  347:#ifndef OPENSSL_NO_COMP
    20000:  348:	comp=s->s3->tmp.new_compression;
        -:  349:#endif
        -:  350:
        -:  351:#ifdef KSSL_DEBUG
        -:  352:	printf("tls1_change_cipher_state(which= %d) w/\n", which);
        -:  353:	printf("\talg= %ld/%ld, comp= %p\n",
        -:  354:	       s->s3->tmp.new_cipher->algorithm_mkey,
        -:  355:	       s->s3->tmp.new_cipher->algorithm_auth,
        -:  356:	       comp);
        -:  357:	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", c);
        -:  358:	printf("\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n",
        -:  359:                c->nid,c->block_size,c->key_len,c->iv_len);
        -:  360:	printf("\tkey_block: len= %d, data= ", s->s3->tmp.key_block_length);
        -:  361:	{
        -:  362:        int i;
        -:  363:        for (i=0; i<s->s3->tmp.key_block_length; i++)
        -:  364:		printf("%02x", s->s3->tmp.key_block[i]);  printf("\n");
        -:  365:        }
        -:  366:#endif	/* KSSL_DEBUG */
        -:  367:
    20000:  368:	if (which & SSL3_CC_READ)
        -:  369:		{
    10000:  370:		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
    #####:  371:			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
        -:  372:		else
    10000:  373:			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;
        -:  374:
    10000:  375:		if (s->enc_read_ctx != NULL)
        -:  376:			reuse_dd = 1;
    10000:  377:		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
        -:  378:			goto err;
        -:  379:		else
        -:  380:			/* make sure it's intialized in case we exit later with an error */
    10000:  381:			EVP_CIPHER_CTX_init(s->enc_read_ctx);
    10000:  382:		dd= s->enc_read_ctx;
    10000:  383:		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
        -:  384:#ifndef OPENSSL_NO_COMP
    10000:  385:		if (s->expand != NULL)
        -:  386:			{
    #####:  387:			COMP_CTX_free(s->expand);
    #####:  388:			s->expand=NULL;
        -:  389:			}
    10000:  390:		if (comp != NULL)
        -:  391:			{
    #####:  392:			s->expand=COMP_CTX_new(comp->method);
    #####:  393:			if (s->expand == NULL)
        -:  394:				{
    #####:  395:				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
    #####:  396:				goto err2;
        -:  397:				}
    #####:  398:			if (s->s3->rrec.comp == NULL)
    #####:  399:				s->s3->rrec.comp=(unsigned char *)
    #####:  400:					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
    #####:  401:			if (s->s3->rrec.comp == NULL)
        -:  402:				goto err;
        -:  403:			}
        -:  404:#endif
        -:  405:		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
    10000:  406: 		if (s->version != DTLS1_VERSION)
    10000:  407:			memset(&(s->s3->read_sequence[0]),0,8);
    10000:  408:		mac_secret= &(s->s3->read_mac_secret[0]);
    10000:  409:		mac_secret_size=&(s->s3->read_mac_secret_size);
        -:  410:		}
        -:  411:	else
        -:  412:		{
    10000:  413:		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
    #####:  414:			s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
        -:  415:			else
    10000:  416:			s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
    10000:  417:		if (s->enc_write_ctx != NULL)
        -:  418:			reuse_dd = 1;
    10000:  419:		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
        -:  420:			goto err;
        -:  421:		else
        -:  422:			/* make sure it's intialized in case we exit later with an error */
    10000:  423:			EVP_CIPHER_CTX_init(s->enc_write_ctx);
    10000:  424:		dd= s->enc_write_ctx;
    10000:  425:		mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
        -:  426:#ifndef OPENSSL_NO_COMP
    10000:  427:		if (s->compress != NULL)
        -:  428:			{
    #####:  429:			COMP_CTX_free(s->compress);
    #####:  430:			s->compress=NULL;
        -:  431:			}
    10000:  432:		if (comp != NULL)
        -:  433:			{
    #####:  434:			s->compress=COMP_CTX_new(comp->method);
    #####:  435:			if (s->compress == NULL)
        -:  436:				{
    #####:  437:				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
    #####:  438:				goto err2;
        -:  439:				}
        -:  440:			}
        -:  441:#endif
        -:  442:		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
    10000:  443: 		if (s->version != DTLS1_VERSION)
    10000:  444:			memset(&(s->s3->write_sequence[0]),0,8);
    10000:  445:		mac_secret= &(s->s3->write_mac_secret[0]);
    10000:  446:		mac_secret_size = &(s->s3->write_mac_secret_size);
        -:  447:		}
        -:  448:
    20000:  449:	if (reuse_dd)
    #####:  450:		EVP_CIPHER_CTX_cleanup(dd);
        -:  451:
    20000:  452:	p=s->s3->tmp.key_block;
    20000:  453:	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;
        -:  454:
    20000:  455:	cl=EVP_CIPHER_key_length(c);
        -:  456:	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
    20000:  457:	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
        -:  458:	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
        -:  459:	/* If GCM mode only part of IV comes from PRF */
    20000:  460:	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
        -:  461:		k = EVP_GCM_TLS_FIXED_IV_LEN;
        -:  462:	else
    #####:  463:		k=EVP_CIPHER_iv_length(c);
    40000:  464:	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
    20000:  465:		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
        -:  466:		{
    10000:  467:		ms=  &(p[ 0]); n=i+i;
    10000:  468:		key= &(p[ n]); n+=j+j;
    10000:  469:		iv=  &(p[ n]); n+=k+k;
        -:  470:		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
        -:  471:		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
        -:  472:		client_write=1;
        -:  473:		}
        -:  474:	else
        -:  475:		{
        -:  476:		n=i;
    10000:  477:		ms=  &(p[ n]); n+=i+j;
    10000:  478:		key= &(p[ n]); n+=j+k;
    10000:  479:		iv=  &(p[ n]); n+=k;
        -:  480:		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
        -:  481:		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
        -:  482:		client_write=0;
        -:  483:		}
        -:  484:
    20000:  485:	if (n > s->s3->tmp.key_block_length)
        -:  486:		{
    #####:  487:		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
    #####:  488:		goto err2;
        -:  489:		}
        -:  490:
    20000:  491:	memcpy(mac_secret,ms,i);
        -:  492:
    20000:  493:	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
        -:  494:		{
    #####:  495:		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
        -:  496:				mac_secret,*mac_secret_size);
    #####:  497:		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
    #####:  498:		EVP_PKEY_free(mac_key);
        -:  499:		}
        -:  500:#ifdef TLS_DEBUG
        -:  501:printf("which = %04X\nmac key=",which);
        -:  502:{ int z; for (z=0; z<i; z++) printf("%02X%c",ms[z],((z+1)%16)?' ':'\n'); }
        -:  503:#endif
    20000:  504:	if (is_export)
        -:  505:		{
        -:  506:		/* In here I set both the read and write key/iv to the
        -:  507:		 * same value since only the correct one will be used :-).
        -:  508:		 */
    #####:  509:		if (!tls1_PRF(ssl_get_algorithm2(s),
        -:  510:				exp_label,exp_label_len,
    #####:  511:				s->s3->client_random,SSL3_RANDOM_SIZE,
    #####:  512:				s->s3->server_random,SSL3_RANDOM_SIZE,
        -:  513:				NULL,0,NULL,0,
        -:  514:				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
        -:  515:			goto err2;
        -:  516:		key=tmp1;
        -:  517:
    #####:  518:		if (k > 0)
        -:  519:			{
    #####:  520:			if (!tls1_PRF(ssl_get_algorithm2(s),
        -:  521:					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
    #####:  522:					s->s3->client_random,SSL3_RANDOM_SIZE,
    #####:  523:					s->s3->server_random,SSL3_RANDOM_SIZE,
        -:  524:					NULL,0,NULL,0,
        -:  525:					empty,0,iv1,iv2,k*2))
        -:  526:				goto err2;
    #####:  527:			if (client_write)
        -:  528:				iv=iv1;
        -:  529:			else
    #####:  530:				iv= &(iv1[k]);
        -:  531:			}
        -:  532:		}
        -:  533:
    20000:  534:	s->session->key_arg_length=0;
        -:  535:#ifdef KSSL_DEBUG
        -:  536:	{
        -:  537:        int i;
        -:  538:	printf("EVP_CipherInit_ex(dd,c,key=,iv=,which)\n");
        -:  539:	printf("\tkey= "); for (i=0; i<c->key_len; i++) printf("%02x", key[i]);
        -:  540:	printf("\n");
        -:  541:	printf("\t iv= "); for (i=0; i<c->iv_len; i++) printf("%02x", iv[i]);
        -:  542:	printf("\n");
        -:  543:	}
        -:  544:#endif	/* KSSL_DEBUG */
        -:  545:
    20000:  546:	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
        -:  547:		{
    20000:  548:		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
    20000:  549:		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
        -:  550:		}
        -:  551:	else	
    #####:  552:		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
        -:  553:
        -:  554:	/* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
    20000:  555:	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
    #####:  556:		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
        -:  557:				*mac_secret_size,mac_secret);
        -:  558:
        -:  559:#ifdef TLS_DEBUG
        -:  560:printf("which = %04X\nkey=",which);
        -:  561:{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf("%02X%c",key[z],((z+1)%16)?' ':'\n'); }
        -:  562:printf("\niv=");
        -:  563:{ int z; for (z=0; z<k; z++) printf("%02X%c",iv[z],((z+1)%16)?' ':'\n'); }
        -:  564:printf("\n");
        -:  565:#endif
        -:  566:
    20000:  567:	OPENSSL_cleanse(tmp1,sizeof(tmp1));
    20000:  568:	OPENSSL_cleanse(tmp2,sizeof(tmp1));
    20000:  569:	OPENSSL_cleanse(iv1,sizeof(iv1));
    20000:  570:	OPENSSL_cleanse(iv2,sizeof(iv2));
    20000:  571:	return(1);
        -:  572:err:
    #####:  573:	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
        -:  574:err2:
        -:  575:	return(0);
        -:  576:	}
        -:  577:
    10000:  578:int tls1_setup_key_block(SSL *s)
        -:  579:	{
        -:  580:	unsigned char *p1,*p2=NULL;
        -:  581:	const EVP_CIPHER *c;
        -:  582:	const EVP_MD *hash;
        -:  583:	int num;
        -:  584:	SSL_COMP *comp;
    10000:  585:	int mac_type= NID_undef,mac_secret_size=0;
        -:  586:	int ret=0;
        -:  587:
        -:  588:#ifdef KSSL_DEBUG
        -:  589:	printf ("tls1_setup_key_block()\n");
        -:  590:#endif	/* KSSL_DEBUG */
        -:  591:
    10000:  592:	if (s->s3->tmp.key_block_length != 0)
        -:  593:		return(1);
        -:  594:
    10000:  595:	if (!ssl_cipher_get_evp(s->session,&c,&hash,&mac_type,&mac_secret_size,&comp))
        -:  596:		{
    #####:  597:		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
    #####:  598:		return(0);
        -:  599:		}
        -:  600:
    10000:  601:	s->s3->tmp.new_sym_enc=c;
    10000:  602:	s->s3->tmp.new_hash=hash;
    10000:  603:	s->s3->tmp.new_mac_pkey_type = mac_type;
    10000:  604:	s->s3->tmp.new_mac_secret_size = mac_secret_size;
    10000:  605:	num=EVP_CIPHER_key_length(c)+mac_secret_size+EVP_CIPHER_iv_length(c);
    10000:  606:	num*=2;
        -:  607:
    10000:  608:	ssl3_cleanup_key_block(s);
        -:  609:
    10000:  610:	if ((p1=(unsigned char *)OPENSSL_malloc(num)) == NULL)
        -:  611:		{
    #####:  612:		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
    #####:  613:		goto err;
        -:  614:		}
        -:  615:
    10000:  616:	s->s3->tmp.key_block_length=num;
    10000:  617:	s->s3->tmp.key_block=p1;
        -:  618:
    10000:  619:	if ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)
        -:  620:		{
    #####:  621:		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
    #####:  622:		goto err;
        -:  623:		}
        -:  624:
        -:  625:#ifdef TLS_DEBUG
        -:  626:printf("client random\n");
        -:  627:{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->client_random[z],((z+1)%16)?' ':'\n'); }
        -:  628:printf("server random\n");
        -:  629:{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->server_random[z],((z+1)%16)?' ':'\n'); }
        -:  630:printf("pre-master\n");
        -:  631:{ int z; for (z=0; z<s->session->master_key_length; z++) printf("%02X%c",s->session->master_key[z],((z+1)%16)?' ':'\n'); }
        -:  632:#endif
    10000:  633:	if (!tls1_generate_key_block(s,p1,p2,num))
        -:  634:		goto err;
        -:  635:#ifdef TLS_DEBUG
        -:  636:printf("\nkey block\n");
        -:  637:{ int z; for (z=0; z<num; z++) printf("%02X%c",p1[z],((z+1)%16)?' ':'\n'); }
        -:  638:#endif
        -:  639:
    10000:  640:	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)
    10000:  641:		&& s->method->version <= TLS1_VERSION)
        -:  642:		{
        -:  643:		/* enable vulnerability countermeasure for CBC ciphers with
        -:  644:		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
        -:  645:		 */
    #####:  646:		s->s3->need_empty_fragments = 1;
        -:  647:
    #####:  648:		if (s->session->cipher != NULL)
        -:  649:			{
    #####:  650:			if (s->session->cipher->algorithm_enc == SSL_eNULL)
    #####:  651:				s->s3->need_empty_fragments = 0;
        -:  652:			
        -:  653:#ifndef OPENSSL_NO_RC4
    #####:  654:			if (s->session->cipher->algorithm_enc == SSL_RC4)
    #####:  655:				s->s3->need_empty_fragments = 0;
        -:  656:#endif
        -:  657:			}
        -:  658:		}
        -:  659:		
        -:  660:	ret = 1;
        -:  661:err:
    10000:  662:	if (p2)
        -:  663:		{
    10000:  664:		OPENSSL_cleanse(p2,num);
    10000:  665:		OPENSSL_free(p2);
        -:  666:		}
    10000:  667:	return(ret);
        -:  668:	}
        -:  669:
        -:  670:/* tls1_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
        -:  671: *
        -:  672: * Returns:
        -:  673: *   0: (in non-constant time) if the record is publically invalid (i.e. too
        -:  674: *       short etc).
        -:  675: *   1: if the record's padding is valid / the encryption was successful.
        -:  676: *   -1: if the record's padding/AEAD-authenticator is invalid or, if sending,
        -:  677: *       an internal error occured.
        -:  678: */
   100000:  679:int tls1_enc(SSL *s, int send)
        -:  680:	{
        -:  681:	SSL3_RECORD *rec;
        -:  682:	EVP_CIPHER_CTX *ds;
        -:  683:	unsigned long l;
        -:  684:	int bs,i,j,k,pad=0,ret,mac_size=0;
        -:  685:	const EVP_CIPHER *enc;
        -:  686:
   100000:  687:	if (send)
        -:  688:		{
    40000:  689:		if (EVP_MD_CTX_md(s->write_hash))
        -:  690:			{
    #####:  691:			int n=EVP_MD_CTX_size(s->write_hash);
    #####:  692:			OPENSSL_assert(n >= 0);
        -:  693:			}
    40000:  694:		ds=s->enc_write_ctx;
    40000:  695:		rec= &(s->s3->wrec);
    40000:  696:		if (s->enc_write_ctx == NULL)
        -:  697:			enc=NULL;
        -:  698:		else
        -:  699:			{
        -:  700:			int ivlen;
    20000:  701:			enc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
        -:  702:			/* For TLSv1.1 and later explicit IV */
    20000:  703:			if (s->version >= TLS1_1_VERSION
    20000:  704:				&& EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
    #####:  705:				ivlen = EVP_CIPHER_iv_length(enc);
        -:  706:			else
        -:  707:				ivlen = 0;
    20000:  708:			if (ivlen > 1)
        -:  709:				{
    #####:  710:				if ( rec->data != rec->input)
        -:  711:					/* we can't write into the input stream:
        -:  712:					 * Can this ever happen?? (steve)
        -:  713:					 */
    #####:  714:					fprintf(stderr,
        -:  715:						"%s:%d: rec->data != rec->input\n",
        -:  716:						__FILE__, __LINE__);
    #####:  717:				else if (RAND_bytes(rec->input, ivlen) <= 0)
        -:  718:					return -1;
        -:  719:				}
        -:  720:			}
        -:  721:		}
        -:  722:	else
        -:  723:		{
    60000:  724:		if (EVP_MD_CTX_md(s->read_hash))
        -:  725:			{
    #####:  726:			int n=EVP_MD_CTX_size(s->read_hash);
    #####:  727:			OPENSSL_assert(n >= 0);
        -:  728:			}
    60000:  729:		ds=s->enc_read_ctx;
    60000:  730:		rec= &(s->s3->rrec);
    60000:  731:		if (s->enc_read_ctx == NULL)
        -:  732:			enc=NULL;
        -:  733:		else
    10000:  734:			enc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
        -:  735:		}
        -:  736:
        -:  737:#ifdef KSSL_DEBUG
        -:  738:	printf("tls1_enc(%d)\n", send);
        -:  739:#endif    /* KSSL_DEBUG */
        -:  740:
   100000:  741:	if ((s->session == NULL) || (ds == NULL) || (enc == NULL))
        -:  742:		{
    70000:  743:		memmove(rec->data,rec->input,rec->length);
    70000:  744:		rec->input=rec->data;
    70000:  745:		ret = 1;
        -:  746:		}
        -:  747:	else
        -:  748:		{
    30000:  749:		l=rec->length;
    30000:  750:		bs=EVP_CIPHER_block_size(ds->cipher);
        -:  751:
    30000:  752:		if (EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
        -:  753:			{
        -:  754:			unsigned char buf[13],*seq;
        -:  755:
    30000:  756:			seq = send?s->s3->write_sequence:s->s3->read_sequence;
        -:  757:
    30000:  758:			if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
        -:  759:				{
        -:  760:				unsigned char dtlsseq[9],*p=dtlsseq;
        -:  761:
    #####:  762:				s2n(send?s->d1->w_epoch:s->d1->r_epoch,p);
    #####:  763:				memcpy(p,&seq[2],6);
        -:  764:				memcpy(buf,dtlsseq,8);
        -:  765:				}
        -:  766:			else
        -:  767:				{
        -:  768:				memcpy(buf,seq,8);
    30000:  769:				for (i=7; i>=0; i--)	/* increment */
        -:  770:					{
    30000:  771:					++seq[i];
    30000:  772:					if (seq[i] != 0) break; 
        -:  773:					}
        -:  774:				}
        -:  775:
    30000:  776:			buf[8]=rec->type;
    30000:  777:			buf[9]=(unsigned char)(s->version>>8);
    30000:  778:			buf[10]=(unsigned char)(s->version);
    30000:  779:			buf[11]=rec->length>>8;
    30000:  780:			buf[12]=rec->length&0xff;
    30000:  781:			pad=EVP_CIPHER_CTX_ctrl(ds,EVP_CTRL_AEAD_TLS1_AAD,13,buf);
    30000:  782:			if (send)
        -:  783:				{
    20000:  784:				l+=pad;
    20000:  785:				rec->length+=pad;
        -:  786:				}
        -:  787:			}
    #####:  788:		else if ((bs != 1) && send)
        -:  789:			{
    #####:  790:			i=bs-((int)l%bs);
        -:  791:
        -:  792:			/* Add weird padding of upto 256 bytes */
        -:  793:
        -:  794:			/* we need to add 'i' padding bytes of value j */
    #####:  795:			j=i-1;
    #####:  796:			if (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)
        -:  797:				{
    #####:  798:				if (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)
        -:  799:					j++;
        -:  800:				}
    #####:  801:			for (k=(int)l; k<(int)(l+i); k++)
    #####:  802:				rec->input[k]=j;
    #####:  803:			l+=i;
    #####:  804:			rec->length+=i;
        -:  805:			}
        -:  806:
        -:  807:#ifdef KSSL_DEBUG
        -:  808:		{
        -:  809:		unsigned long ui;
        -:  810:		printf("EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\n",
        -:  811:			ds,rec->data,rec->input,l);
        -:  812:		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
        -:  813:			ds->buf_len, ds->cipher->key_len,
        -:  814:			DES_KEY_SZ, DES_SCHEDULE_SZ,
        -:  815:			ds->cipher->iv_len);
        -:  816:		printf("\t\tIV: ");
        -:  817:		for (i=0; i<ds->cipher->iv_len; i++) printf("%02X", ds->iv[i]);
        -:  818:		printf("\n");
        -:  819:		printf("\trec->input=");
        -:  820:		for (ui=0; ui<l; ui++) printf(" %02x", rec->input[ui]);
        -:  821:		printf("\n");
        -:  822:		}
        -:  823:#endif	/* KSSL_DEBUG */
        -:  824:
    30000:  825:		if (!send)
        -:  826:			{
    10000:  827:			if (l == 0 || l%bs != 0)
        -:  828:				return 0;
        -:  829:			}
        -:  830:		
    30000:  831:		i = EVP_Cipher(ds,rec->data,rec->input,l);
    30000:  832:		if ((EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_CUSTOM_CIPHER)
        -:  833:						?(i<0)
        -:  834:						:(i==0))
        -:  835:			return -1;	/* AEAD can fail to verify MAC */
    30000:  836:		if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE && !send)
        -:  837:			{
    10000:  838:			rec->data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
    10000:  839:			rec->input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
    10000:  840:			rec->length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
        -:  841:			}
        -:  842:
        -:  843:#ifdef KSSL_DEBUG
        -:  844:		{
        -:  845:		unsigned long i;
        -:  846:		printf("\trec->data=");
        -:  847:		for (i=0; i<l; i++)
        -:  848:			printf(" %02x", rec->data[i]);  printf("\n");
        -:  849:		}
        -:  850:#endif	/* KSSL_DEBUG */
        -:  851:
        -:  852:		ret = 1;
    30000:  853:		if (EVP_MD_CTX_md(s->read_hash) != NULL)
    #####:  854:			mac_size = EVP_MD_CTX_size(s->read_hash);
    30000:  855:		if ((bs != 1) && !send)
    #####:  856:			ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
    30000:  857:		if (pad && !send)
    10000:  858:			rec->length -= pad;
        -:  859:		}
   100000:  860:	return ret;
        -:  861:	}
        -:  862:
    #####:  863:int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
        -:  864:	{
        -:  865:	unsigned int ret;
        -:  866:	EVP_MD_CTX ctx, *d=NULL;
        -:  867:	int i;
        -:  868:
    #####:  869:	if (s->s3->handshake_buffer) 
    #####:  870:		if (!ssl3_digest_cached_records(s))
        -:  871:			return 0;
        -:  872:
    #####:  873:	for (i=0;i<SSL_MAX_DIGEST;i++) 
        -:  874:		{
    #####:  875:		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
        -:  876:		  	{
    #####:  877:		  	d=s->s3->handshake_dgst[i];
    #####:  878:			break;
        -:  879:			}
        -:  880:		}
    #####:  881:	if (!d) {
    #####:  882:		SSLerr(SSL_F_TLS1_CERT_VERIFY_MAC,SSL_R_NO_REQUIRED_DIGEST);
    #####:  883:		return 0;
        -:  884:	}	
        -:  885:
    #####:  886:	EVP_MD_CTX_init(&ctx);
    #####:  887:	EVP_MD_CTX_copy_ex(&ctx,d);
    #####:  888:	EVP_DigestFinal_ex(&ctx,out,&ret);
    #####:  889:	EVP_MD_CTX_cleanup(&ctx);
    #####:  890:	return((int)ret);
        -:  891:	}
        -:  892:
    30000:  893:int tls1_final_finish_mac(SSL *s,
        -:  894:	     const char *str, int slen, unsigned char *out)
        -:  895:	{
        -:  896:	unsigned int i;
        -:  897:	EVP_MD_CTX ctx;
        -:  898:	unsigned char buf[2*EVP_MAX_MD_SIZE];
        -:  899:	unsigned char *q,buf2[12];
        -:  900:	int idx;
        -:  901:	long mask;
        -:  902:	int err=0;
        -:  903:	const EVP_MD *md; 
        -:  904:
        -:  905:	q=buf;
        -:  906:
    30000:  907:	if (s->s3->handshake_buffer) 
    #####:  908:		if (!ssl3_digest_cached_records(s))
        -:  909:			return 0;
        -:  910:
    30000:  911:	EVP_MD_CTX_init(&ctx);
        -:  912:
   210000:  913:	for (idx=0;ssl_get_handshake_digest(idx,&mask,&md);idx++)
        -:  914:		{
   180000:  915:		if (mask & ssl_get_algorithm2(s))
        -:  916:			{
    30000:  917:			int hashsize = EVP_MD_size(md);
    30000:  918:			if (hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q-buf)))
        -:  919:				{
        -:  920:				/* internal error: 'buf' is too small for this cipersuite! */
        -:  921:				err = 1;
        -:  922:				}
        -:  923:			else
        -:  924:				{
    30000:  925:				EVP_MD_CTX_copy_ex(&ctx,s->s3->handshake_dgst[idx]);
    30000:  926:				EVP_DigestFinal_ex(&ctx,q,&i);
    30000:  927:				if (i != (unsigned int)hashsize) /* can't really happen */
        -:  928:					err = 1;
    30000:  929:				q+=i;
        -:  930:				}
        -:  931:			}
        -:  932:		}
        -:  933:		
    60000:  934:	if (!tls1_PRF(ssl_get_algorithm2(s),
    30000:  935:			str,slen, buf,(int)(q-buf), NULL,0, NULL,0, NULL,0,
    60000:  936:			s->session->master_key,s->session->master_key_length,
        -:  937:			out,buf2,sizeof buf2))
        -:  938:		err = 1;
    30000:  939:	EVP_MD_CTX_cleanup(&ctx);
        -:  940:
    30000:  941:	if (err)
        -:  942:		return 0;
        -:  943:	else
    30000:  944:		return sizeof buf2;
        -:  945:	}
        -:  946:
    #####:  947:int tls1_mac(SSL *ssl, unsigned char *md, int send)
        -:  948:	{
        -:  949:	SSL3_RECORD *rec;
        -:  950:	unsigned char *seq;
        -:  951:	EVP_MD_CTX *hash;
        -:  952:	size_t md_size, orig_len;
        -:  953:	int i;
        -:  954:	EVP_MD_CTX hmac, *mac_ctx;
        -:  955:	unsigned char header[13];
    #####:  956:	int stream_mac = (send?(ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM):(ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));
        -:  957:	int t;
        -:  958:
    #####:  959:	if (send)
        -:  960:		{
    #####:  961:		rec= &(ssl->s3->wrec);
    #####:  962:		seq= &(ssl->s3->write_sequence[0]);
    #####:  963:		hash=ssl->write_hash;
        -:  964:		}
        -:  965:	else
        -:  966:		{
    #####:  967:		rec= &(ssl->s3->rrec);
    #####:  968:		seq= &(ssl->s3->read_sequence[0]);
    #####:  969:		hash=ssl->read_hash;
        -:  970:		}
        -:  971:
    #####:  972:	t=EVP_MD_CTX_size(hash);
    #####:  973:	OPENSSL_assert(t >= 0);
    #####:  974:	md_size=t;
        -:  975:
        -:  976:	/* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
    #####:  977:	if (stream_mac) 
        -:  978:		{
        -:  979:			mac_ctx = hash;
        -:  980:		}
        -:  981:		else
        -:  982:		{
    #####:  983:			EVP_MD_CTX_copy(&hmac,hash);
        -:  984:			mac_ctx = &hmac;
        -:  985:		}
        -:  986:
    #####:  987:	if (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER)
        -:  988:		{
        -:  989:		unsigned char dtlsseq[8],*p=dtlsseq;
        -:  990:
    #####:  991:		s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);
    #####:  992:		memcpy (p,&seq[2],6);
        -:  993:
        -:  994:		memcpy(header, dtlsseq, 8);
        -:  995:		}
        -:  996:	else
        -:  997:		memcpy(header, seq, 8);
        -:  998:
        -:  999:	/* kludge: tls1_cbc_remove_padding passes padding length in rec->type */
    #####: 1000:	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
    #####: 1001:	rec->type &= 0xff;
        -: 1002:
    #####: 1003:	header[8]=rec->type;
    #####: 1004:	header[9]=(unsigned char)(ssl->version>>8);
    #####: 1005:	header[10]=(unsigned char)(ssl->version);
    #####: 1006:	header[11]=(rec->length)>>8;
    #####: 1007:	header[12]=(rec->length)&0xff;
        -: 1008:
    #####: 1009:	if (!send &&
    #####: 1010:	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
    #####: 1011:	    ssl3_cbc_record_digest_supported(mac_ctx))
        -: 1012:		{
        -: 1013:		/* This is a CBC-encrypted record. We must avoid leaking any
        -: 1014:		 * timing-side channel information about how many blocks of
        -: 1015:		 * data we are hashing because that gives an attacker a
        -: 1016:		 * timing-oracle. */
    #####: 1017:		ssl3_cbc_digest_record(
        -: 1018:			mac_ctx,
        -: 1019:			md, &md_size,
    #####: 1020:			header, rec->input,
    #####: 1021:			rec->length + md_size, orig_len,
    #####: 1022:			ssl->s3->read_mac_secret,
    #####: 1023:			ssl->s3->read_mac_secret_size,
        -: 1024:			0 /* not SSLv3 */);
        -: 1025:		}
        -: 1026:	else
        -: 1027:		{
    #####: 1028:		EVP_DigestSignUpdate(mac_ctx,header,sizeof(header));
    #####: 1029:		EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);
    #####: 1030:		t=EVP_DigestSignFinal(mac_ctx,md,&md_size);
    #####: 1031:		OPENSSL_assert(t > 0);
        -: 1032:#ifdef OPENSSL_FIPS
        -: 1033:		if (!send && FIPS_mode())
        -: 1034:			tls_fips_digest_extra(
        -: 1035:	    				ssl->enc_read_ctx,
        -: 1036:					mac_ctx, rec->input,
        -: 1037:					rec->length, orig_len);
        -: 1038:#endif
        -: 1039:		}
        -: 1040:		
    #####: 1041:	if (!stream_mac)
    #####: 1042:		EVP_MD_CTX_cleanup(&hmac);
        -: 1043:#ifdef TLS_DEBUG
        -: 1044:printf("sec=");
        -: 1045:{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }
        -: 1046:printf("seq=");
        -: 1047:{int z; for (z=0; z<8; z++) printf("%02X ",seq[z]); printf("\n"); }
        -: 1048:printf("buf=");
        -: 1049:{int z; for (z=0; z<5; z++) printf("%02X ",buf[z]); printf("\n"); }
        -: 1050:printf("rec=");
        -: 1051:{unsigned int z; for (z=0; z<rec->length; z++) printf("%02X ",buf[z]); printf("\n"); }
        -: 1052:#endif
        -: 1053:
    #####: 1054:	if (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER)
        -: 1055:		{
    #####: 1056:		for (i=7; i>=0; i--)
        -: 1057:			{
    #####: 1058:			++seq[i];
    #####: 1059:			if (seq[i] != 0) break; 
        -: 1060:			}
        -: 1061:		}
        -: 1062:
        -: 1063:#ifdef TLS_DEBUG
        -: 1064:{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",md[z]); printf("\n"); }
        -: 1065:#endif
    #####: 1066:	return(md_size);
        -: 1067:	}
        -: 1068:
    10000: 1069:int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
        -: 1070:	     int len)
        -: 1071:	{
        -: 1072:	unsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];
        -: 1073:	const void *co = NULL, *so = NULL;
        -: 1074:	int col = 0, sol = 0;
        -: 1075:
        -: 1076:
        -: 1077:#ifdef KSSL_DEBUG
        -: 1078:	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s,out, p,len);
        -: 1079:#endif	/* KSSL_DEBUG */
        -: 1080:
        -: 1081:#ifdef TLSEXT_TYPE_opaque_prf_input
        -: 1082:	if (s->s3->client_opaque_prf_input != NULL && s->s3->server_opaque_prf_input != NULL &&
        -: 1083:	    s->s3->client_opaque_prf_input_len > 0 &&
        -: 1084:	    s->s3->client_opaque_prf_input_len == s->s3->server_opaque_prf_input_len)
        -: 1085:		{
        -: 1086:		co = s->s3->client_opaque_prf_input;
        -: 1087:		col = s->s3->server_opaque_prf_input_len;
        -: 1088:		so = s->s3->server_opaque_prf_input;
        -: 1089:		sol = s->s3->client_opaque_prf_input_len; /* must be same as col (see draft-rescorla-tls-opaque-prf-input-00.txt, section 3.1) */
        -: 1090:		}
        -: 1091:#endif
        -: 1092:
    10000: 1093:	tls1_PRF(ssl_get_algorithm2(s),
        -: 1094:		TLS_MD_MASTER_SECRET_CONST,TLS_MD_MASTER_SECRET_CONST_SIZE,
    10000: 1095:		s->s3->client_random,SSL3_RANDOM_SIZE,
        -: 1096:		co, col,
    10000: 1097:		s->s3->server_random,SSL3_RANDOM_SIZE,
        -: 1098:		so, sol,
        -: 1099:		p,len,
    10000: 1100:		s->session->master_key,buff,sizeof buff);
        -: 1101:#ifdef SSL_DEBUG
        -: 1102:	fprintf(stderr, "Premaster Secret:\n");
        -: 1103:	BIO_dump_fp(stderr, (char *)p, len);
        -: 1104:	fprintf(stderr, "Client Random:\n");
        -: 1105:	BIO_dump_fp(stderr, (char *)s->s3->client_random, SSL3_RANDOM_SIZE);
        -: 1106:	fprintf(stderr, "Server Random:\n");
        -: 1107:	BIO_dump_fp(stderr, (char *)s->s3->server_random, SSL3_RANDOM_SIZE);
        -: 1108:	fprintf(stderr, "Master Secret:\n");
        -: 1109:	BIO_dump_fp(stderr, (char *)s->session->master_key, SSL3_MASTER_SECRET_SIZE);
        -: 1110:#endif
        -: 1111:
        -: 1112:#ifdef KSSL_DEBUG
        -: 1113:	printf ("tls1_generate_master_secret() complete\n");
        -: 1114:#endif	/* KSSL_DEBUG */
    10000: 1115:	return(SSL3_MASTER_SECRET_SIZE);
        -: 1116:	}
        -: 1117:
    #####: 1118:int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
        -: 1119:	 const char *label, size_t llen, const unsigned char *context,
        -: 1120:	 size_t contextlen, int use_context)
        -: 1121:	{
        -: 1122:	unsigned char *buff;
        -: 1123:	unsigned char *val = NULL;
        -: 1124:	size_t vallen, currentvalpos;
        -: 1125:	int rv;
        -: 1126:
        -: 1127:#ifdef KSSL_DEBUG
        -: 1128:	printf ("tls1_export_keying_material(%p,%p,%d,%s,%d,%p,%d)\n", s, out, olen, label, llen, p, plen);
        -: 1129:#endif	/* KSSL_DEBUG */
        -: 1130:
    #####: 1131:	buff = OPENSSL_malloc(olen);
    #####: 1132:	if (buff == NULL) goto err2;
        -: 1133:
        -: 1134:	/* construct PRF arguments
        -: 1135:	 * we construct the PRF argument ourself rather than passing separate
        -: 1136:	 * values into the TLS PRF to ensure that the concatenation of values
        -: 1137:	 * does not create a prohibited label.
        -: 1138:	 */
    #####: 1139:	vallen = llen + SSL3_RANDOM_SIZE * 2;
    #####: 1140:	if (use_context)
        -: 1141:		{
    #####: 1142:		vallen += 2 + contextlen;
        -: 1143:		}
        -: 1144:
    #####: 1145:	val = OPENSSL_malloc(vallen);
    #####: 1146:	if (val == NULL) goto err2;
        -: 1147:	currentvalpos = 0;
        -: 1148:	memcpy(val + currentvalpos, (unsigned char *) label, llen);
        -: 1149:	currentvalpos += llen;
    #####: 1150:	memcpy(val + currentvalpos, s->s3->client_random, SSL3_RANDOM_SIZE);
    #####: 1151:	currentvalpos += SSL3_RANDOM_SIZE;
    #####: 1152:	memcpy(val + currentvalpos, s->s3->server_random, SSL3_RANDOM_SIZE);
        -: 1153:	currentvalpos += SSL3_RANDOM_SIZE;
        -: 1154:
    #####: 1155:	if (use_context)
        -: 1156:		{
    #####: 1157:		val[currentvalpos] = (contextlen >> 8) & 0xff;
    #####: 1158:		currentvalpos++;
    #####: 1159:		val[currentvalpos] = contextlen & 0xff;
    #####: 1160:		currentvalpos++;
    #####: 1161:		if ((contextlen > 0) || (context != NULL))
        -: 1162:			{
    #####: 1163:			memcpy(val + currentvalpos, context, contextlen);
        -: 1164:			}
        -: 1165:		}
        -: 1166:
        -: 1167:	/* disallow prohibited labels
        -: 1168:	 * note that SSL3_RANDOM_SIZE > max(prohibited label len) =
        -: 1169:	 * 15, so size of val > max(prohibited label len) = 15 and the
        -: 1170:	 * comparisons won't have buffer overflow
        -: 1171:	 */
    #####: 1172:	if (memcmp(val, TLS_MD_CLIENT_FINISH_CONST,
        -: 1173:		 TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0) goto err1;
    #####: 1174:	if (memcmp(val, TLS_MD_SERVER_FINISH_CONST,
        -: 1175:		 TLS_MD_SERVER_FINISH_CONST_SIZE) == 0) goto err1;
    #####: 1176:	if (memcmp(val, TLS_MD_MASTER_SECRET_CONST,
        -: 1177:		 TLS_MD_MASTER_SECRET_CONST_SIZE) == 0) goto err1;
    #####: 1178:	if (memcmp(val, TLS_MD_KEY_EXPANSION_CONST,
        -: 1179:		 TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0) goto err1;
        -: 1180:
    #####: 1181:	rv = tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
        -: 1182:		      val, vallen,
        -: 1183:		      NULL, 0,
        -: 1184:		      NULL, 0,
        -: 1185:		      NULL, 0,
        -: 1186:		      NULL, 0,
    #####: 1187:		      s->session->master_key,s->session->master_key_length,
        -: 1188:		      out,buff,olen);
        -: 1189:
        -: 1190:#ifdef KSSL_DEBUG
        -: 1191:	printf ("tls1_export_keying_material() complete\n");
        -: 1192:#endif	/* KSSL_DEBUG */
    #####: 1193:	goto ret;
        -: 1194:err1:
    #####: 1195:	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, SSL_R_TLS_ILLEGAL_EXPORTER_LABEL);
        -: 1196:	rv = 0;
    #####: 1197:	goto ret;
        -: 1198:err2:
    #####: 1199:	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, ERR_R_MALLOC_FAILURE);
        -: 1200:	rv = 0;
        -: 1201:ret:
    #####: 1202:	if (buff != NULL) OPENSSL_free(buff);
    #####: 1203:	if (val != NULL) OPENSSL_free(val);
    #####: 1204:	return(rv);
        -: 1205:	}
        -: 1206:
    10000: 1207:int tls1_alert_code(int code)
        -: 1208:	{
        -: 1209:	switch (code)
        -: 1210:		{
        -: 1211:	case SSL_AD_CLOSE_NOTIFY:	return(SSL3_AD_CLOSE_NOTIFY);
        -: 1212:	case SSL_AD_UNEXPECTED_MESSAGE:	return(SSL3_AD_UNEXPECTED_MESSAGE);
        -: 1213:	case SSL_AD_BAD_RECORD_MAC:	return(SSL3_AD_BAD_RECORD_MAC);
        -: 1214:	case SSL_AD_DECRYPTION_FAILED:	return(TLS1_AD_DECRYPTION_FAILED);
        -: 1215:	case SSL_AD_RECORD_OVERFLOW:	return(TLS1_AD_RECORD_OVERFLOW);
        -: 1216:	case SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);
        -: 1217:	case SSL_AD_HANDSHAKE_FAILURE:	return(SSL3_AD_HANDSHAKE_FAILURE);
        -: 1218:	case SSL_AD_NO_CERTIFICATE:	return(-1);
        -: 1219:	case SSL_AD_BAD_CERTIFICATE:	return(SSL3_AD_BAD_CERTIFICATE);
        -: 1220:	case SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);
        -: 1221:	case SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);
        -: 1222:	case SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);
        -: 1223:	case SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);
        -: 1224:	case SSL_AD_ILLEGAL_PARAMETER:	return(SSL3_AD_ILLEGAL_PARAMETER);
        -: 1225:	case SSL_AD_UNKNOWN_CA:		return(TLS1_AD_UNKNOWN_CA);
        -: 1226:	case SSL_AD_ACCESS_DENIED:	return(TLS1_AD_ACCESS_DENIED);
        -: 1227:	case SSL_AD_DECODE_ERROR:	return(TLS1_AD_DECODE_ERROR);
        -: 1228:	case SSL_AD_DECRYPT_ERROR:	return(TLS1_AD_DECRYPT_ERROR);
        -: 1229:	case SSL_AD_EXPORT_RESTRICTION:	return(TLS1_AD_EXPORT_RESTRICTION);
        -: 1230:	case SSL_AD_PROTOCOL_VERSION:	return(TLS1_AD_PROTOCOL_VERSION);
        -: 1231:	case SSL_AD_INSUFFICIENT_SECURITY:return(TLS1_AD_INSUFFICIENT_SECURITY);
        -: 1232:	case SSL_AD_INTERNAL_ERROR:	return(TLS1_AD_INTERNAL_ERROR);
        -: 1233:	case SSL_AD_USER_CANCELLED:	return(TLS1_AD_USER_CANCELLED);
        -: 1234:	case SSL_AD_NO_RENEGOTIATION:	return(TLS1_AD_NO_RENEGOTIATION);
        -: 1235:	case SSL_AD_UNSUPPORTED_EXTENSION: return(TLS1_AD_UNSUPPORTED_EXTENSION);
        -: 1236:	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(TLS1_AD_CERTIFICATE_UNOBTAINABLE);
        -: 1237:	case SSL_AD_UNRECOGNIZED_NAME:	return(TLS1_AD_UNRECOGNIZED_NAME);
        -: 1238:	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);
        -: 1239:	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);
        -: 1240:	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
        -: 1241:#if 0 /* not appropriate for TLS, not used for DTLS */
        -: 1242:	case DTLS1_AD_MISSING_HANDSHAKE_MESSAGE: return 
        -: 1243:					  (DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
        -: 1244:#endif
        -: 1245:	default:			return(-1);
        -: 1246:		}
        -: 1247:	}
