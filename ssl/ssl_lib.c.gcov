        -:    0:Source:ssl_lib.c
        -:    0:Graph:ssl_lib.gcno
        -:    0:Data:ssl_lib.gcda
        -:    0:Runs:10000
        -:    0:Programs:1
        -:    1:/*! \file ssl/ssl_lib.c
        -:    2: *  \brief Version independent SSL functions.
        -:    3: */
        -:    4:/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
        -:    5: * All rights reserved.
        -:    6: *
        -:    7: * This package is an SSL implementation written
        -:    8: * by Eric Young (eay@cryptsoft.com).
        -:    9: * The implementation was written so as to conform with Netscapes SSL.
        -:   10: * 
        -:   11: * This library is free for commercial and non-commercial use as long as
        -:   12: * the following conditions are aheared to.  The following conditions
        -:   13: * apply to all code found in this distribution, be it the RC4, RSA,
        -:   14: * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
        -:   15: * included with this distribution is covered by the same copyright terms
        -:   16: * except that the holder is Tim Hudson (tjh@cryptsoft.com).
        -:   17: * 
        -:   18: * Copyright remains Eric Young's, and as such any Copyright notices in
        -:   19: * the code are not to be removed.
        -:   20: * If this package is used in a product, Eric Young should be given attribution
        -:   21: * as the author of the parts of the library used.
        -:   22: * This can be in the form of a textual message at program startup or
        -:   23: * in documentation (online or textual) provided with the package.
        -:   24: * 
        -:   25: * Redistribution and use in source and binary forms, with or without
        -:   26: * modification, are permitted provided that the following conditions
        -:   27: * are met:
        -:   28: * 1. Redistributions of source code must retain the copyright
        -:   29: *    notice, this list of conditions and the following disclaimer.
        -:   30: * 2. Redistributions in binary form must reproduce the above copyright
        -:   31: *    notice, this list of conditions and the following disclaimer in the
        -:   32: *    documentation and/or other materials provided with the distribution.
        -:   33: * 3. All advertising materials mentioning features or use of this software
        -:   34: *    must display the following acknowledgement:
        -:   35: *    "This product includes cryptographic software written by
        -:   36: *     Eric Young (eay@cryptsoft.com)"
        -:   37: *    The word 'cryptographic' can be left out if the rouines from the library
        -:   38: *    being used are not cryptographic related :-).
        -:   39: * 4. If you include any Windows specific code (or a derivative thereof) from 
        -:   40: *    the apps directory (application code) you must include an acknowledgement:
        -:   41: *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
        -:   42: * 
        -:   43: * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
        -:   44: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   45: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   46: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   47: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   48: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   49: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   50: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   51: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   52: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   53: * SUCH DAMAGE.
        -:   54: * 
        -:   55: * The licence and distribution terms for any publically available version or
        -:   56: * derivative of this code cannot be changed.  i.e. this code cannot simply be
        -:   57: * copied and put under another distribution licence
        -:   58: * [including the GNU Public Licence.]
        -:   59: */
        -:   60:/* ====================================================================
        -:   61: * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
        -:   62: *
        -:   63: * Redistribution and use in source and binary forms, with or without
        -:   64: * modification, are permitted provided that the following conditions
        -:   65: * are met:
        -:   66: *
        -:   67: * 1. Redistributions of source code must retain the above copyright
        -:   68: *    notice, this list of conditions and the following disclaimer. 
        -:   69: *
        -:   70: * 2. Redistributions in binary form must reproduce the above copyright
        -:   71: *    notice, this list of conditions and the following disclaimer in
        -:   72: *    the documentation and/or other materials provided with the
        -:   73: *    distribution.
        -:   74: *
        -:   75: * 3. All advertising materials mentioning features or use of this
        -:   76: *    software must display the following acknowledgment:
        -:   77: *    "This product includes software developed by the OpenSSL Project
        -:   78: *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
        -:   79: *
        -:   80: * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
        -:   81: *    endorse or promote products derived from this software without
        -:   82: *    prior written permission. For written permission, please contact
        -:   83: *    openssl-core@openssl.org.
        -:   84: *
        -:   85: * 5. Products derived from this software may not be called "OpenSSL"
        -:   86: *    nor may "OpenSSL" appear in their names without prior written
        -:   87: *    permission of the OpenSSL Project.
        -:   88: *
        -:   89: * 6. Redistributions of any form whatsoever must retain the following
        -:   90: *    acknowledgment:
        -:   91: *    "This product includes software developed by the OpenSSL Project
        -:   92: *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
        -:   93: *
        -:   94: * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
        -:   95: * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   96: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        -:   97: * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
        -:   98: * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   99: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:  100: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:  101: * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:  102: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:  103: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        -:  104: * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
        -:  105: * OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  106: * ====================================================================
        -:  107: *
        -:  108: * This product includes cryptographic software written by Eric Young
        -:  109: * (eay@cryptsoft.com).  This product includes software written by Tim
        -:  110: * Hudson (tjh@cryptsoft.com).
        -:  111: *
        -:  112: */
        -:  113:/* ====================================================================
        -:  114: * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
        -:  115: * ECC cipher suite support in OpenSSL originally developed by 
        -:  116: * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
        -:  117: */
        -:  118:/* ====================================================================
        -:  119: * Copyright 2005 Nokia. All rights reserved.
        -:  120: *
        -:  121: * The portions of the attached software ("Contribution") is developed by
        -:  122: * Nokia Corporation and is licensed pursuant to the OpenSSL open source
        -:  123: * license.
        -:  124: *
        -:  125: * The Contribution, originally written by Mika Kousa and Pasi Eronen of
        -:  126: * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
        -:  127: * support (see RFC 4279) to OpenSSL.
        -:  128: *
        -:  129: * No patent licenses or other rights except those expressly stated in
        -:  130: * the OpenSSL open source license shall be deemed granted or received
        -:  131: * expressly, by implication, estoppel, or otherwise.
        -:  132: *
        -:  133: * No assurances are provided by Nokia that the Contribution does not
        -:  134: * infringe the patent or other intellectual property rights of any third
        -:  135: * party or that the license provides you with all the necessary rights
        -:  136: * to make use of the Contribution.
        -:  137: *
        -:  138: * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
        -:  139: * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
        -:  140: * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
        -:  141: * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
        -:  142: * OTHERWISE.
        -:  143: */
        -:  144:
        -:  145:#ifdef REF_CHECK
        -:  146:#  include <assert.h>
        -:  147:#endif
        -:  148:#include <stdio.h>
        -:  149:#include "ssl_locl.h"
        -:  150:#include "kssl_lcl.h"
        -:  151:#include <openssl/objects.h>
        -:  152:#include <openssl/lhash.h>
        -:  153:#include <openssl/x509v3.h>
        -:  154:#include <openssl/rand.h>
        -:  155:#include <openssl/ocsp.h>
        -:  156:#ifndef OPENSSL_NO_DH
        -:  157:#include <openssl/dh.h>
        -:  158:#endif
        -:  159:#ifndef OPENSSL_NO_ENGINE
        -:  160:#include <openssl/engine.h>
        -:  161:#endif
        -:  162:
        -:  163:const char *SSL_version_str=OPENSSL_VERSION_TEXT;
        -:  164:
        -:  165:SSL3_ENC_METHOD ssl3_undef_enc_method={
        -:  166:	/* evil casts, but these functions are only called if there's a library bug */
        -:  167:	(int (*)(SSL *,int))ssl_undefined_function,
        -:  168:	(int (*)(SSL *, unsigned char *, int))ssl_undefined_function,
        -:  169:	ssl_undefined_function,
        -:  170:	(int (*)(SSL *, unsigned char *, unsigned char *, int))ssl_undefined_function,
        -:  171:	(int (*)(SSL*, int))ssl_undefined_function,
        -:  172:	(int (*)(SSL *,  const char*, int, unsigned char *))ssl_undefined_function,
        -:  173:	0,	/* finish_mac_length */
        -:  174:	(int (*)(SSL *, int, unsigned char *))ssl_undefined_function,
        -:  175:	NULL,	/* client_finished_label */
        -:  176:	0,	/* client_finished_label_len */
        -:  177:	NULL,	/* server_finished_label */
        -:  178:	0,	/* server_finished_label_len */
        -:  179:	(int (*)(int))ssl_undefined_function,
        -:  180:	(int (*)(SSL *, unsigned char *, size_t, const char *,
        -:  181:		 size_t, const unsigned char *, size_t,
        -:  182:		 int use_context)) ssl_undefined_function,
        -:  183:	};
        -:  184:
    20000:  185:int SSL_clear(SSL *s)
        -:  186:	{
        -:  187:
    20000:  188:	if (s->method == NULL)
        -:  189:		{
    #####:  190:		SSLerr(SSL_F_SSL_CLEAR,SSL_R_NO_METHOD_SPECIFIED);
    #####:  191:		return(0);
        -:  192:		}
        -:  193:
    20000:  194:	if (ssl_clear_bad_session(s))
        -:  195:		{
    #####:  196:		SSL_SESSION_free(s->session);
    #####:  197:		s->session=NULL;
        -:  198:		}
        -:  199:
    20000:  200:	s->error=0;
    20000:  201:	s->hit=0;
    20000:  202:	s->shutdown=0;
        -:  203:
        -:  204:#if 0 /* Disabled since version 1.10 of this file (early return not
        -:  205:       * needed because SSL_clear is not called when doing renegotiation) */
        -:  206:	/* This is set if we are doing dynamic renegotiation so keep
        -:  207:	 * the old cipher.  It is sort of a SSL_clear_lite :-) */
        -:  208:	if (s->renegotiate) return(1);
        -:  209:#else
    20000:  210:	if (s->renegotiate)
        -:  211:		{
    #####:  212:		SSLerr(SSL_F_SSL_CLEAR,ERR_R_INTERNAL_ERROR);
    #####:  213:		return 0;
        -:  214:		}
        -:  215:#endif
        -:  216:
    20000:  217:	s->type=0;
        -:  218:
    20000:  219:	s->state=SSL_ST_BEFORE|((s->server)?SSL_ST_ACCEPT:SSL_ST_CONNECT);
        -:  220:
    20000:  221:	s->version=s->method->version;
    20000:  222:	s->client_version=s->version;
    20000:  223:	s->rwstate=SSL_NOTHING;
    20000:  224:	s->rstate=SSL_ST_READ_HEADER;
        -:  225:#if 0
        -:  226:	s->read_ahead=s->ctx->read_ahead;
        -:  227:#endif
        -:  228:
    20000:  229:	if (s->init_buf != NULL)
        -:  230:		{
    #####:  231:		BUF_MEM_free(s->init_buf);
    #####:  232:		s->init_buf=NULL;
        -:  233:		}
        -:  234:
    20000:  235:	ssl_clear_cipher_ctx(s);
        -:  236:	ssl_clear_hash_ctx(&s->read_hash);
        -:  237:	ssl_clear_hash_ctx(&s->write_hash);
        -:  238:
    20000:  239:	s->first_packet=0;
        -:  240:
        -:  241:#if 1
        -:  242:	/* Check to see if we were changed into a different method, if
        -:  243:	 * so, revert back if we are not doing session-id reuse. */
    20000:  244:	if (!s->in_handshake && (s->session == NULL) && (s->method != s->ctx->method))
        -:  245:		{
    #####:  246:		s->method->ssl_free(s);
    #####:  247:		s->method=s->ctx->method;
    #####:  248:		if (!s->method->ssl_new(s))
        -:  249:			return(0);
        -:  250:		}
        -:  251:	else
        -:  252:#endif
    20000:  253:		s->method->ssl_clear(s);
        -:  254:	return(1);
        -:  255:	}
        -:  256:
        -:  257:/** Used to change an SSL_CTXs default SSL method type */
    #####:  258:int SSL_CTX_set_ssl_version(SSL_CTX *ctx,const SSL_METHOD *meth)
        -:  259:	{
        -:  260:	STACK_OF(SSL_CIPHER) *sk;
        -:  261:
    #####:  262:	ctx->method=meth;
        -:  263:
    #####:  264:	sk=ssl_create_cipher_list(ctx->method,&(ctx->cipher_list),
        -:  265:		&(ctx->cipher_list_by_id),
    #####:  266:		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
    #####:  267:	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0))
        -:  268:		{
    #####:  269:		SSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
    #####:  270:		return(0);
        -:  271:		}
        -:  272:	return(1);
        -:  273:	}
        -:  274:
    10000:  275:SSL *SSL_new(SSL_CTX *ctx)
        -:  276:	{
        -:  277:	SSL *s;
        -:  278:
    10000:  279:	if (ctx == NULL)
        -:  280:		{
    #####:  281:		SSLerr(SSL_F_SSL_NEW,SSL_R_NULL_SSL_CTX);
    #####:  282:		return(NULL);
        -:  283:		}
    10000:  284:	if (ctx->method == NULL)
        -:  285:		{
    #####:  286:		SSLerr(SSL_F_SSL_NEW,SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
    #####:  287:		return(NULL);
        -:  288:		}
        -:  289:
    10000:  290:	s=(SSL *)OPENSSL_malloc(sizeof(SSL));
    10000:  291:	if (s == NULL) goto err;
        -:  292:	memset(s,0,sizeof(SSL));
        -:  293:
        -:  294:#ifndef	OPENSSL_NO_KRB5
        -:  295:	s->kssl_ctx = kssl_ctx_new();
        -:  296:#endif	/* OPENSSL_NO_KRB5 */
        -:  297:
    10000:  298:	s->options=ctx->options;
    10000:  299:	s->mode=ctx->mode;
    10000:  300:	s->max_cert_list=ctx->max_cert_list;
        -:  301:
    10000:  302:	if (ctx->cert != NULL)
        -:  303:		{
        -:  304:		/* Earlier library versions used to copy the pointer to
        -:  305:		 * the CERT, not its contents; only when setting new
        -:  306:		 * parameters for the per-SSL copy, ssl_cert_new would be
        -:  307:		 * called (and the direct reference to the per-SSL_CTX
        -:  308:		 * settings would be lost, but those still were indirectly
        -:  309:		 * accessed for various purposes, and for that reason they
        -:  310:		 * used to be known as s->ctx->default_cert).
        -:  311:		 * Now we don't look at the SSL_CTX's CERT after having
        -:  312:		 * duplicated it once. */
        -:  313:
    10000:  314:		s->cert = ssl_cert_dup(ctx->cert);
    10000:  315:		if (s->cert == NULL)
        -:  316:			goto err;
        -:  317:		}
        -:  318:	else
    #####:  319:		s->cert=NULL; /* Cannot really happen (see SSL_CTX_new) */
        -:  320:
    10000:  321:	s->read_ahead=ctx->read_ahead;
    10000:  322:	s->msg_callback=ctx->msg_callback;
    10000:  323:	s->msg_callback_arg=ctx->msg_callback_arg;
    10000:  324:	s->verify_mode=ctx->verify_mode;
        -:  325:#if 0
        -:  326:	s->verify_depth=ctx->verify_depth;
        -:  327:#endif
    10000:  328:	s->sid_ctx_length=ctx->sid_ctx_length;
    10000:  329:	OPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);
    10000:  330:	memcpy(&s->sid_ctx,&ctx->sid_ctx,sizeof(s->sid_ctx));
    10000:  331:	s->verify_callback=ctx->default_verify_callback;
    10000:  332:	s->generate_session_id=ctx->generate_session_id;
        -:  333:
    10000:  334:	s->param = X509_VERIFY_PARAM_new();
    10000:  335:	if (!s->param)
        -:  336:		goto err;
    10000:  337:	X509_VERIFY_PARAM_inherit(s->param, ctx->param);
        -:  338:#if 0
        -:  339:	s->purpose = ctx->purpose;
        -:  340:	s->trust = ctx->trust;
        -:  341:#endif
    10000:  342:	s->quiet_shutdown=ctx->quiet_shutdown;
    10000:  343:	s->max_send_fragment = ctx->max_send_fragment;
        -:  344:
    10000:  345:	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
    10000:  346:	s->ctx=ctx;
        -:  347:#ifndef OPENSSL_NO_TLSEXT
    10000:  348:	s->tlsext_debug_cb = 0;
    10000:  349:	s->tlsext_debug_arg = NULL;
    10000:  350:	s->tlsext_ticket_expected = 0;
    10000:  351:	s->tlsext_status_type = -1;
    10000:  352:	s->tlsext_status_expected = 0;
    10000:  353:	s->tlsext_ocsp_ids = NULL;
    10000:  354:	s->tlsext_ocsp_exts = NULL;
    10000:  355:	s->tlsext_ocsp_resp = NULL;
    10000:  356:	s->tlsext_ocsp_resplen = -1;
    10000:  357:	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
    10000:  358:	s->initial_ctx=ctx;
        -:  359:# ifndef OPENSSL_NO_NEXTPROTONEG
    10000:  360:	s->next_proto_negotiated = NULL;
        -:  361:# endif
        -:  362:#endif
        -:  363:
    10000:  364:	s->verify_result=X509_V_OK;
        -:  365:
    10000:  366:	s->method=ctx->method;
        -:  367:
    10000:  368:	if (!s->method->ssl_new(s))
        -:  369:		goto err;
        -:  370:
    10000:  371:	s->references=1;
    10000:  372:	s->server=(ctx->method->ssl_accept == ssl_undefined_function)?0:1;
        -:  373:
    10000:  374:	SSL_clear(s);
        -:  375:
    10000:  376:	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
        -:  377:
        -:  378:#ifndef OPENSSL_NO_PSK
    10000:  379:	s->psk_client_callback=ctx->psk_client_callback;
    10000:  380:	s->psk_server_callback=ctx->psk_server_callback;
        -:  381:#endif
        -:  382:
    10000:  383:	return(s);
        -:  384:err:
    #####:  385:	if (s != NULL)
        -:  386:		{
    #####:  387:		if (s->cert != NULL)
    #####:  388:			ssl_cert_free(s->cert);
    #####:  389:		if (s->ctx != NULL)
    #####:  390:			SSL_CTX_free(s->ctx); /* decrement reference count */
    #####:  391:		OPENSSL_free(s);
        -:  392:		}
    #####:  393:	SSLerr(SSL_F_SSL_NEW,ERR_R_MALLOC_FAILURE);
    #####:  394:	return(NULL);
        -:  395:	}
        -:  396:
    #####:  397:int SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
        -:  398:				   unsigned int sid_ctx_len)
        -:  399:    {
    #####:  400:    if(sid_ctx_len > sizeof ctx->sid_ctx)
        -:  401:	{
    #####:  402:	SSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
    #####:  403:	return 0;
        -:  404:	}
    #####:  405:    ctx->sid_ctx_length=sid_ctx_len;
    #####:  406:    memcpy(ctx->sid_ctx,sid_ctx,sid_ctx_len);
        -:  407:
    #####:  408:    return 1;
        -:  409:    }
        -:  410:
    #####:  411:int SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
        -:  412:			       unsigned int sid_ctx_len)
        -:  413:    {
    #####:  414:    if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
        -:  415:	{
    #####:  416:	SSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
    #####:  417:	return 0;
        -:  418:	}
    #####:  419:    ssl->sid_ctx_length=sid_ctx_len;
    #####:  420:    memcpy(ssl->sid_ctx,sid_ctx,sid_ctx_len);
        -:  421:
    #####:  422:    return 1;
        -:  423:    }
        -:  424:
    #####:  425:int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)
        -:  426:	{
    #####:  427:	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
    #####:  428:	ctx->generate_session_id = cb;
    #####:  429:	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
    #####:  430:	return 1;
        -:  431:	}
        -:  432:
    #####:  433:int SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)
        -:  434:	{
    #####:  435:	CRYPTO_w_lock(CRYPTO_LOCK_SSL);
    #####:  436:	ssl->generate_session_id = cb;
    #####:  437:	CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
    #####:  438:	return 1;
        -:  439:	}
        -:  440:
    #####:  441:int SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
        -:  442:				unsigned int id_len)
        -:  443:	{
        -:  444:	/* A quick examination of SSL_SESSION_hash and SSL_SESSION_cmp shows how
        -:  445:	 * we can "construct" a session to give us the desired check - ie. to
        -:  446:	 * find if there's a session in the hash table that would conflict with
        -:  447:	 * any new session built out of this id/id_len and the ssl_version in
        -:  448:	 * use by this SSL. */
        -:  449:	SSL_SESSION r, *p;
        -:  450:
    #####:  451:	if(id_len > sizeof r.session_id)
        -:  452:		return 0;
        -:  453:
    #####:  454:	r.ssl_version = ssl->version;
    #####:  455:	r.session_id_length = id_len;
    #####:  456:	memcpy(r.session_id, id, id_len);
        -:  457:	/* NB: SSLv2 always uses a fixed 16-byte session ID, so even if a
        -:  458:	 * callback is calling us to check the uniqueness of a shorter ID, it
        -:  459:	 * must be compared as a padded-out ID because that is what it will be
        -:  460:	 * converted to when the callback has finished choosing it. */
    #####:  461:	if((r.ssl_version == SSL2_VERSION) &&
        -:  462:			(id_len < SSL2_SSL_SESSION_ID_LENGTH))
        -:  463:		{
    #####:  464:		memset(r.session_id + id_len, 0,
    #####:  465:			SSL2_SSL_SESSION_ID_LENGTH - id_len);
    #####:  466:		r.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
        -:  467:		}
        -:  468:
    #####:  469:	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
    #####:  470:	p = lh_SSL_SESSION_retrieve(ssl->ctx->sessions, &r);
    #####:  471:	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
    #####:  472:	return (p != NULL);
        -:  473:	}
        -:  474:
    #####:  475:int SSL_CTX_set_purpose(SSL_CTX *s, int purpose)
        -:  476:	{
    #####:  477:	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
        -:  478:	}
        -:  479:
    #####:  480:int SSL_set_purpose(SSL *s, int purpose)
        -:  481:	{
    #####:  482:	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
        -:  483:	}
        -:  484:
    #####:  485:int SSL_CTX_set_trust(SSL_CTX *s, int trust)
        -:  486:	{
    #####:  487:	return X509_VERIFY_PARAM_set_trust(s->param, trust);
        -:  488:	}
        -:  489:
    #####:  490:int SSL_set_trust(SSL *s, int trust)
        -:  491:	{
    #####:  492:	return X509_VERIFY_PARAM_set_trust(s->param, trust);
        -:  493:	}
        -:  494:
    #####:  495:int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)
        -:  496:	{
    #####:  497:	return X509_VERIFY_PARAM_set1(ctx->param, vpm);
        -:  498:	}
        -:  499:
    #####:  500:int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)
        -:  501:	{
    #####:  502:	return X509_VERIFY_PARAM_set1(ssl->param, vpm);
        -:  503:	}
        -:  504:
    10000:  505:void SSL_free(SSL *s)
        -:  506:	{
        -:  507:	int i;
        -:  508:
    10000:  509:	if(s == NULL)
        -:  510:	    return;
        -:  511:
    10000:  512:	i=CRYPTO_add(&s->references,-1,CRYPTO_LOCK_SSL);
        -:  513:#ifdef REF_PRINT
        -:  514:	REF_PRINT("SSL",s);
        -:  515:#endif
    10000:  516:	if (i > 0) return;
        -:  517:#ifdef REF_CHECK
        -:  518:	if (i < 0)
        -:  519:		{
        -:  520:		fprintf(stderr,"SSL_free, bad reference count\n");
        -:  521:		abort(); /* ok */
        -:  522:		}
        -:  523:#endif
        -:  524:
    10000:  525:	if (s->param)
    10000:  526:		X509_VERIFY_PARAM_free(s->param);
        -:  527:
    10000:  528:	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
        -:  529:
    10000:  530:	if (s->bbio != NULL)
        -:  531:		{
        -:  532:		/* If the buffering BIO is in place, pop it off */
    #####:  533:		if (s->bbio == s->wbio)
        -:  534:			{
    #####:  535:			s->wbio=BIO_pop(s->wbio);
        -:  536:			}
    #####:  537:		BIO_free(s->bbio);
    #####:  538:		s->bbio=NULL;
        -:  539:		}
    10000:  540:	if (s->rbio != NULL)
    10000:  541:		BIO_free_all(s->rbio);
    10000:  542:	if ((s->wbio != NULL) && (s->wbio != s->rbio))
    #####:  543:		BIO_free_all(s->wbio);
        -:  544:
    10000:  545:	if (s->init_buf != NULL) BUF_MEM_free(s->init_buf);
        -:  546:
        -:  547:	/* add extra stuff */
    10000:  548:	if (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);
    10000:  549:	if (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);
        -:  550:
        -:  551:	/* Make the next call work :-) */
    10000:  552:	if (s->session != NULL)
        -:  553:		{
    10000:  554:		ssl_clear_bad_session(s);
    10000:  555:		SSL_SESSION_free(s->session);
        -:  556:		}
        -:  557:
    10000:  558:	ssl_clear_cipher_ctx(s);
        -:  559:	ssl_clear_hash_ctx(&s->read_hash);
        -:  560:	ssl_clear_hash_ctx(&s->write_hash);
        -:  561:
    10000:  562:	if (s->cert != NULL) ssl_cert_free(s->cert);
        -:  563:	/* Free up if allocated */
        -:  564:
        -:  565:#ifndef OPENSSL_NO_TLSEXT
    10000:  566:	if (s->tlsext_hostname)
    #####:  567:		OPENSSL_free(s->tlsext_hostname);
    10000:  568:	if (s->initial_ctx) SSL_CTX_free(s->initial_ctx);
        -:  569:#ifndef OPENSSL_NO_EC
    10000:  570:	if (s->tlsext_ecpointformatlist) OPENSSL_free(s->tlsext_ecpointformatlist);
    10000:  571:	if (s->tlsext_ellipticcurvelist) OPENSSL_free(s->tlsext_ellipticcurvelist);
        -:  572:#endif /* OPENSSL_NO_EC */
    10000:  573:	if (s->tlsext_opaque_prf_input) OPENSSL_free(s->tlsext_opaque_prf_input);
    10000:  574:	if (s->tlsext_ocsp_exts)
    #####:  575:		sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
        -:  576:						X509_EXTENSION_free);
    10000:  577:	if (s->tlsext_ocsp_ids)
    #####:  578:		sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);
    10000:  579:	if (s->tlsext_ocsp_resp)
    #####:  580:		OPENSSL_free(s->tlsext_ocsp_resp);
        -:  581:#endif
        -:  582:
    10000:  583:	if (s->client_CA != NULL)
    #####:  584:		sk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);
        -:  585:
    10000:  586:	if (s->method != NULL) s->method->ssl_free(s);
        -:  587:
    10000:  588:	if (s->ctx) SSL_CTX_free(s->ctx);
        -:  589:
        -:  590:#ifndef	OPENSSL_NO_KRB5
        -:  591:	if (s->kssl_ctx != NULL)
        -:  592:		kssl_ctx_free(s->kssl_ctx);
        -:  593:#endif	/* OPENSSL_NO_KRB5 */
        -:  594:
        -:  595:#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
    10000:  596:	if (s->next_proto_negotiated)
    #####:  597:		OPENSSL_free(s->next_proto_negotiated);
        -:  598:#endif
        -:  599:
        -:  600:#ifndef OPENSSL_NO_SRTP
    10000:  601:        if (s->srtp_profiles)
    #####:  602:            sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);
        -:  603:#endif
        -:  604:
    10000:  605:	OPENSSL_free(s);
        -:  606:	}
        -:  607:
    10000:  608:void SSL_set_bio(SSL *s,BIO *rbio,BIO *wbio)
        -:  609:	{
        -:  610:	/* If the output buffering BIO is still in place, remove it
        -:  611:	 */
    10000:  612:	if (s->bbio != NULL)
        -:  613:		{
    #####:  614:		if (s->wbio == s->bbio)
        -:  615:			{
    #####:  616:			s->wbio=s->wbio->next_bio;
    #####:  617:			s->bbio->next_bio=NULL;
        -:  618:			}
        -:  619:		}
    10000:  620:	if ((s->rbio != NULL) && (s->rbio != rbio))
    #####:  621:		BIO_free_all(s->rbio);
    10000:  622:	if ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))
    #####:  623:		BIO_free_all(s->wbio);
    10000:  624:	s->rbio=rbio;
    10000:  625:	s->wbio=wbio;
    10000:  626:	}
        -:  627:
    10000:  628:BIO *SSL_get_rbio(const SSL *s)
   160000:  629:	{ return(s->rbio); }
        -:  630:
    10000:  631:BIO *SSL_get_wbio(const SSL *s)
    10000:  632:	{ return(s->wbio); }
        -:  633:
   150000:  634:int SSL_get_fd(const SSL *s)
        -:  635:	{
   150000:  636:	return(SSL_get_rfd(s));
        -:  637:	}
        -:  638:
   150000:  639:int SSL_get_rfd(const SSL *s)
        -:  640:	{
   150000:  641:	int ret= -1;
        -:  642:	BIO *b,*r;
        -:  643:
        -:  644:	b=SSL_get_rbio(s);
   150000:  645:	r=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);
   150000:  646:	if (r != NULL)
   150000:  647:		BIO_get_fd(r,&ret);
   150000:  648:	return(ret);
        -:  649:	}
        -:  650:
    #####:  651:int SSL_get_wfd(const SSL *s)
        -:  652:	{
    #####:  653:	int ret= -1;
        -:  654:	BIO *b,*r;
        -:  655:
        -:  656:	b=SSL_get_wbio(s);
    #####:  657:	r=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);
    #####:  658:	if (r != NULL)
    #####:  659:		BIO_get_fd(r,&ret);
    #####:  660:	return(ret);
        -:  661:	}
        -:  662:
        -:  663:#ifndef OPENSSL_NO_SOCK
    #####:  664:int SSL_set_fd(SSL *s,int fd)
        -:  665:	{
        -:  666:	int ret=0;
        -:  667:	BIO *bio=NULL;
        -:  668:
    #####:  669:	bio=BIO_new(BIO_s_socket());
        -:  670:
    #####:  671:	if (bio == NULL)
        -:  672:		{
    #####:  673:		SSLerr(SSL_F_SSL_SET_FD,ERR_R_BUF_LIB);
    #####:  674:		goto err;
        -:  675:		}
    #####:  676:	BIO_set_fd(bio,fd,BIO_NOCLOSE);
    #####:  677:	SSL_set_bio(s,bio,bio);
        -:  678:	ret=1;
        -:  679:err:
    #####:  680:	return(ret);
        -:  681:	}
        -:  682:
    #####:  683:int SSL_set_wfd(SSL *s,int fd)
        -:  684:	{
        -:  685:	int ret=0;
        -:  686:	BIO *bio=NULL;
        -:  687:
    #####:  688:	if ((s->rbio == NULL) || (BIO_method_type(s->rbio) != BIO_TYPE_SOCKET)
    #####:  689:		|| ((int)BIO_get_fd(s->rbio,NULL) != fd))
        -:  690:		{
    #####:  691:		bio=BIO_new(BIO_s_socket());
        -:  692:
    #####:  693:		if (bio == NULL)
    #####:  694:			{ SSLerr(SSL_F_SSL_SET_WFD,ERR_R_BUF_LIB); goto err; }
    #####:  695:		BIO_set_fd(bio,fd,BIO_NOCLOSE);
    #####:  696:		SSL_set_bio(s,SSL_get_rbio(s),bio);
        -:  697:		}
        -:  698:	else
    #####:  699:		SSL_set_bio(s,SSL_get_rbio(s),SSL_get_rbio(s));
        -:  700:	ret=1;
        -:  701:err:
    #####:  702:	return(ret);
        -:  703:	}
        -:  704:
    #####:  705:int SSL_set_rfd(SSL *s,int fd)
        -:  706:	{
        -:  707:	int ret=0;
        -:  708:	BIO *bio=NULL;
        -:  709:
    #####:  710:	if ((s->wbio == NULL) || (BIO_method_type(s->wbio) != BIO_TYPE_SOCKET)
    #####:  711:		|| ((int)BIO_get_fd(s->wbio,NULL) != fd))
        -:  712:		{
    #####:  713:		bio=BIO_new(BIO_s_socket());
        -:  714:
    #####:  715:		if (bio == NULL)
        -:  716:			{
    #####:  717:			SSLerr(SSL_F_SSL_SET_RFD,ERR_R_BUF_LIB);
    #####:  718:			goto err;
        -:  719:			}
    #####:  720:		BIO_set_fd(bio,fd,BIO_NOCLOSE);
    #####:  721:		SSL_set_bio(s,bio,SSL_get_wbio(s));
        -:  722:		}
        -:  723:	else
    #####:  724:		SSL_set_bio(s,SSL_get_wbio(s),SSL_get_wbio(s));
        -:  725:	ret=1;
        -:  726:err:
    #####:  727:	return(ret);
        -:  728:	}
        -:  729:#endif
        -:  730:
        -:  731:
        -:  732:/* return length of latest Finished message we sent, copy to 'buf' */
    #####:  733:size_t SSL_get_finished(const SSL *s, void *buf, size_t count)
        -:  734:	{
        -:  735:	size_t ret = 0;
        -:  736:	
    #####:  737:	if (s->s3 != NULL)
        -:  738:		{
    #####:  739:		ret = s->s3->tmp.finish_md_len;
    #####:  740:		if (count > ret)
        -:  741:			count = ret;
    #####:  742:		memcpy(buf, s->s3->tmp.finish_md, count);
        -:  743:		}
    #####:  744:	return ret;
        -:  745:	}
        -:  746:
        -:  747:/* return length of latest Finished message we expected, copy to 'buf' */
    #####:  748:size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count)
        -:  749:	{
        -:  750:	size_t ret = 0;
        -:  751:	
    #####:  752:	if (s->s3 != NULL)
        -:  753:		{
    #####:  754:		ret = s->s3->tmp.peer_finish_md_len;
    #####:  755:		if (count > ret)
        -:  756:			count = ret;
    #####:  757:		memcpy(buf, s->s3->tmp.peer_finish_md, count);
        -:  758:		}
    #####:  759:	return ret;
        -:  760:	}
        -:  761:
        -:  762:
    #####:  763:int SSL_get_verify_mode(const SSL *s)
        -:  764:	{
    #####:  765:	return(s->verify_mode);
        -:  766:	}
        -:  767:
    #####:  768:int SSL_get_verify_depth(const SSL *s)
        -:  769:	{
    #####:  770:	return X509_VERIFY_PARAM_get_depth(s->param);
        -:  771:	}
        -:  772:
    #####:  773:int (*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *)
        -:  774:	{
    #####:  775:	return(s->verify_callback);
        -:  776:	}
        -:  777:
    #####:  778:int SSL_CTX_get_verify_mode(const SSL_CTX *ctx)
        -:  779:	{
    #####:  780:	return(ctx->verify_mode);
        -:  781:	}
        -:  782:
    #####:  783:int SSL_CTX_get_verify_depth(const SSL_CTX *ctx)
        -:  784:	{
    #####:  785:	return X509_VERIFY_PARAM_get_depth(ctx->param);
        -:  786:	}
        -:  787:
    #####:  788:int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *)
        -:  789:	{
    #####:  790:	return(ctx->default_verify_callback);
        -:  791:	}
        -:  792:
    #####:  793:void SSL_set_verify(SSL *s,int mode,
        -:  794:		    int (*callback)(int ok,X509_STORE_CTX *ctx))
        -:  795:	{
    #####:  796:	s->verify_mode=mode;
    #####:  797:	if (callback != NULL)
    #####:  798:		s->verify_callback=callback;
    #####:  799:	}
        -:  800:
    #####:  801:void SSL_set_verify_depth(SSL *s,int depth)
        -:  802:	{
    #####:  803:	X509_VERIFY_PARAM_set_depth(s->param, depth);
    #####:  804:	}
        -:  805:
    #####:  806:void SSL_set_read_ahead(SSL *s,int yes)
        -:  807:	{
    #####:  808:	s->read_ahead=yes;
    #####:  809:	}
        -:  810:
    #####:  811:int SSL_get_read_ahead(const SSL *s)
        -:  812:	{
    #####:  813:	return(s->read_ahead);
        -:  814:	}
        -:  815:
    20000:  816:int SSL_pending(const SSL *s)
        -:  817:	{
        -:  818:	/* SSL_pending cannot work properly if read-ahead is enabled
        -:  819:	 * (SSL_[CTX_]ctrl(..., SSL_CTRL_SET_READ_AHEAD, 1, NULL)),
        -:  820:	 * and it is impossible to fix since SSL_pending cannot report
        -:  821:	 * errors that may be observed while scanning the new data.
        -:  822:	 * (Note that SSL_pending() is often used as a boolean value,
        -:  823:	 * so we'd better not return -1.)
        -:  824:	 */
    20000:  825:	return(s->method->ssl_pending(s));
        -:  826:	}
        -:  827:
    10000:  828:X509 *SSL_get_peer_certificate(const SSL *s)
        -:  829:	{
        -:  830:	X509 *r;
        -:  831:	
    10000:  832:	if ((s == NULL) || (s->session == NULL))
        -:  833:		r=NULL;
        -:  834:	else
    10000:  835:		r=s->session->peer;
        -:  836:
    10000:  837:	if (r == NULL) return(r);
        -:  838:
    10000:  839:	CRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);
        -:  840:
    10000:  841:	return(r);
        -:  842:	}
        -:  843:
    10000:  844:STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s)
        -:  845:	{
        -:  846:	STACK_OF(X509) *r;
        -:  847:	
    10000:  848:	if ((s == NULL) || (s->session == NULL) || (s->session->sess_cert == NULL))
        -:  849:		r=NULL;
        -:  850:	else
    10000:  851:		r=s->session->sess_cert->cert_chain;
        -:  852:
        -:  853:	/* If we are a client, cert_chain includes the peer's own
        -:  854:	 * certificate; if we are a server, it does not. */
        -:  855:	
    10000:  856:	return(r);
        -:  857:	}
        -:  858:
        -:  859:/* Now in theory, since the calling process own 't' it should be safe to
        -:  860: * modify.  We need to be able to read f without being hassled */
    #####:  861:void SSL_copy_session_id(SSL *t,const SSL *f)
        -:  862:	{
        -:  863:	CERT *tmp;
        -:  864:
        -:  865:	/* Do we need to to SSL locking? */
    #####:  866:	SSL_set_session(t,SSL_get_session(f));
        -:  867:
        -:  868:	/* what if we are setup as SSLv2 but want to talk SSLv3 or
        -:  869:	 * vice-versa */
    #####:  870:	if (t->method != f->method)
        -:  871:		{
    #####:  872:		t->method->ssl_free(t);	/* cleanup current */
    #####:  873:		t->method=f->method;	/* change method */
    #####:  874:		t->method->ssl_new(t);	/* setup new */
        -:  875:		}
        -:  876:
    #####:  877:	tmp=t->cert;
    #####:  878:	if (f->cert != NULL)
        -:  879:		{
    #####:  880:		CRYPTO_add(&f->cert->references,1,CRYPTO_LOCK_SSL_CERT);
    #####:  881:		t->cert=f->cert;
        -:  882:		}
        -:  883:	else
    #####:  884:		t->cert=NULL;
    #####:  885:	if (tmp != NULL) ssl_cert_free(tmp);
    #####:  886:	SSL_set_session_id_context(t,f->sid_ctx,f->sid_ctx_length);
    #####:  887:	}
        -:  888:
        -:  889:/* Fix this so it checks all the valid key/cert options */
    #####:  890:int SSL_CTX_check_private_key(const SSL_CTX *ctx)
        -:  891:	{
    #####:  892:	if (	(ctx == NULL) ||
    #####:  893:		(ctx->cert == NULL) ||
    #####:  894:		(ctx->cert->key->x509 == NULL))
        -:  895:		{
    #####:  896:		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
    #####:  897:		return(0);
        -:  898:		}
    #####:  899:	if 	(ctx->cert->key->privatekey == NULL)
        -:  900:		{
    #####:  901:		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);
    #####:  902:		return(0);
        -:  903:		}
    #####:  904:	return(X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));
        -:  905:	}
        -:  906:
        -:  907:/* Fix this function so that it takes an optional type parameter */
    #####:  908:int SSL_check_private_key(const SSL *ssl)
        -:  909:	{
    #####:  910:	if (ssl == NULL)
        -:  911:		{
    #####:  912:		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,ERR_R_PASSED_NULL_PARAMETER);
    #####:  913:		return(0);
        -:  914:		}
    #####:  915:	if (ssl->cert == NULL)
        -:  916:		{
    #####:  917:		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
    #####:  918:		return 0;
        -:  919:		}
    #####:  920:	if (ssl->cert->key->x509 == NULL)
        -:  921:		{
    #####:  922:		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
    #####:  923:		return(0);
        -:  924:		}
    #####:  925:	if (ssl->cert->key->privatekey == NULL)
        -:  926:		{
    #####:  927:		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);
    #####:  928:		return(0);
        -:  929:		}
    #####:  930:	return(X509_check_private_key(ssl->cert->key->x509,
        -:  931:		ssl->cert->key->privatekey));
        -:  932:	}
        -:  933:
    #####:  934:int SSL_accept(SSL *s)
        -:  935:	{
    #####:  936:	if (s->handshake_func == 0)
        -:  937:		/* Not properly initialized yet */
    #####:  938:		SSL_set_accept_state(s);
        -:  939:
    #####:  940:	return(s->method->ssl_accept(s));
        -:  941:	}
        -:  942:
    10000:  943:int SSL_connect(SSL *s)
        -:  944:	{
    10000:  945:	if (s->handshake_func == 0)
        -:  946:		/* Not properly initialized yet */
    #####:  947:		SSL_set_connect_state(s);
        -:  948:
    10000:  949:	return(s->method->ssl_connect(s));
        -:  950:	}
        -:  951:
    #####:  952:long SSL_get_default_timeout(const SSL *s)
        -:  953:	{
    #####:  954:	return(s->method->get_timeout());
        -:  955:	}
        -:  956:
    10000:  957:int SSL_read(SSL *s,void *buf,int num)
        -:  958:	{
    10000:  959:	if (s->handshake_func == 0)
        -:  960:		{
    #####:  961:		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
    #####:  962:		return -1;
        -:  963:		}
        -:  964:
    10000:  965:	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
        -:  966:		{
    #####:  967:		s->rwstate=SSL_NOTHING;
    #####:  968:		return(0);
        -:  969:		}
    10000:  970:	return(s->method->ssl_read(s,buf,num));
        -:  971:	}
        -:  972:
    #####:  973:int SSL_peek(SSL *s,void *buf,int num)
        -:  974:	{
    #####:  975:	if (s->handshake_func == 0)
        -:  976:		{
    #####:  977:		SSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);
    #####:  978:		return -1;
        -:  979:		}
        -:  980:
    #####:  981:	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
        -:  982:		{
        -:  983:		return(0);
        -:  984:		}
    #####:  985:	return(s->method->ssl_peek(s,buf,num));
        -:  986:	}
        -:  987:
    20000:  988:int SSL_write(SSL *s,const void *buf,int num)
        -:  989:	{
    20000:  990:	if (s->handshake_func == 0)
        -:  991:		{
    #####:  992:		SSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);
    #####:  993:		return -1;
        -:  994:		}
        -:  995:
    20000:  996:	if (s->shutdown & SSL_SENT_SHUTDOWN)
        -:  997:		{
    #####:  998:		s->rwstate=SSL_NOTHING;
    #####:  999:		SSLerr(SSL_F_SSL_WRITE,SSL_R_PROTOCOL_IS_SHUTDOWN);
    #####: 1000:		return(-1);
        -: 1001:		}
    20000: 1002:	return(s->method->ssl_write(s,buf,num));
        -: 1003:	}
        -: 1004:
    10000: 1005:int SSL_shutdown(SSL *s)
        -: 1006:	{
        -: 1007:	/* Note that this function behaves differently from what one might
        -: 1008:	 * expect.  Return values are 0 for no success (yet),
        -: 1009:	 * 1 for success; but calling it once is usually not enough,
        -: 1010:	 * even if blocking I/O is used (see ssl3_shutdown).
        -: 1011:	 */
        -: 1012:
    10000: 1013:	if (s->handshake_func == 0)
        -: 1014:		{
    #####: 1015:		SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);
    #####: 1016:		return -1;
        -: 1017:		}
        -: 1018:
    20000: 1019:	if ((s != NULL) && !SSL_in_init(s))
    10000: 1020:		return(s->method->ssl_shutdown(s));
        -: 1021:	else
        -: 1022:		return(1);
        -: 1023:	}
        -: 1024:
    #####: 1025:int SSL_renegotiate(SSL *s)
        -: 1026:	{
    #####: 1027:	if (s->renegotiate == 0)
    #####: 1028:		s->renegotiate=1;
        -: 1029:
    #####: 1030:	s->new_session=1;
        -: 1031:
    #####: 1032:	return(s->method->ssl_renegotiate(s));
        -: 1033:	}
        -: 1034:
    #####: 1035:int SSL_renegotiate_abbreviated(SSL *s)
        -: 1036:	{
    #####: 1037:	if (s->renegotiate == 0)
    #####: 1038:		s->renegotiate=1;
        -: 1039:
    #####: 1040:	s->new_session=0;
        -: 1041:
    #####: 1042:	return(s->method->ssl_renegotiate(s));
        -: 1043:	}
        -: 1044:
    #####: 1045:int SSL_renegotiate_pending(SSL *s)
        -: 1046:	{
        -: 1047:	/* becomes true when negotiation is requested;
        -: 1048:	 * false again once a handshake has finished */
    #####: 1049:	return (s->renegotiate != 0);
        -: 1050:	}
        -: 1051:
    40000: 1052:long SSL_ctrl(SSL *s,int cmd,long larg,void *parg)
        -: 1053:	{
        -: 1054:	long l;
        -: 1055:
    40000: 1056:	switch (cmd)
        -: 1057:		{
        -: 1058:	case SSL_CTRL_GET_READ_AHEAD:
    #####: 1059:		return(s->read_ahead);
        -: 1060:	case SSL_CTRL_SET_READ_AHEAD:
    #####: 1061:		l=s->read_ahead;
    #####: 1062:		s->read_ahead=larg;
    #####: 1063:		return(l);
        -: 1064:
        -: 1065:	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
    #####: 1066:		s->msg_callback_arg = parg;
    #####: 1067:		return 1;
        -: 1068:
        -: 1069:	case SSL_CTRL_OPTIONS:
    20000: 1070:		return(s->options|=larg);
        -: 1071:	case SSL_CTRL_CLEAR_OPTIONS:
    #####: 1072:		return(s->options&=~larg);
        -: 1073:	case SSL_CTRL_MODE:
    #####: 1074:		return(s->mode|=larg);
        -: 1075:	case SSL_CTRL_CLEAR_MODE:
    #####: 1076:		return(s->mode &=~larg);
        -: 1077:	case SSL_CTRL_GET_MAX_CERT_LIST:
    #####: 1078:		return(s->max_cert_list);
        -: 1079:	case SSL_CTRL_SET_MAX_CERT_LIST:
    #####: 1080:		l=s->max_cert_list;
    #####: 1081:		s->max_cert_list=larg;
    #####: 1082:		return(l);
        -: 1083:	case SSL_CTRL_SET_MTU:
        -: 1084:#ifndef OPENSSL_NO_DTLS1
    #####: 1085:		if (larg < (long)dtls1_min_mtu())
        -: 1086:			return 0;
        -: 1087:#endif
        -: 1088:
    #####: 1089:		if (SSL_version(s) == DTLS1_VERSION ||
        -: 1090:		    SSL_version(s) == DTLS1_BAD_VER)
        -: 1091:			{
    #####: 1092:			s->d1->mtu = larg;
    #####: 1093:			return larg;
        -: 1094:			}
        -: 1095:		return 0;
        -: 1096:	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
    #####: 1097:		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
        -: 1098:			return 0;
    #####: 1099:		s->max_send_fragment = larg;
    #####: 1100:		return 1;
        -: 1101:	case SSL_CTRL_GET_RI_SUPPORT:
    10000: 1102:		if (s->s3)
    10000: 1103:			return s->s3->send_connection_binding;
        -: 1104:		else return 0;
        -: 1105:	default:
    10000: 1106:		return(s->method->ssl_ctrl(s,cmd,larg,parg));
        -: 1107:		}
        -: 1108:	}
        -: 1109:
    #####: 1110:long SSL_callback_ctrl(SSL *s, int cmd, void (*fp)(void))
        -: 1111:	{
    #####: 1112:	switch(cmd)
        -: 1113:		{
        -: 1114:	case SSL_CTRL_SET_MSG_CALLBACK:
    #####: 1115:		s->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
    #####: 1116:		return 1;
        -: 1117:		
        -: 1118:	default:
    #####: 1119:		return(s->method->ssl_callback_ctrl(s,cmd,fp));
        -: 1120:		}
        -: 1121:	}
        -: 1122:
    #####: 1123:LHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx)
        -: 1124:	{
    #####: 1125:	return ctx->sessions;
        -: 1126:	}
        -: 1127:
    10000: 1128:long SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,void *parg)
        -: 1129:	{
        -: 1130:	long l;
        -: 1131:
    10000: 1132:	switch (cmd)
        -: 1133:		{
        -: 1134:	case SSL_CTRL_GET_READ_AHEAD:
    #####: 1135:		return(ctx->read_ahead);
        -: 1136:	case SSL_CTRL_SET_READ_AHEAD:
    #####: 1137:		l=ctx->read_ahead;
    #####: 1138:		ctx->read_ahead=larg;
    #####: 1139:		return(l);
        -: 1140:		
        -: 1141:	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
    #####: 1142:		ctx->msg_callback_arg = parg;
    #####: 1143:		return 1;
        -: 1144:
        -: 1145:	case SSL_CTRL_GET_MAX_CERT_LIST:
    #####: 1146:		return(ctx->max_cert_list);
        -: 1147:	case SSL_CTRL_SET_MAX_CERT_LIST:
    #####: 1148:		l=ctx->max_cert_list;
    #####: 1149:		ctx->max_cert_list=larg;
    #####: 1150:		return(l);
        -: 1151:
        -: 1152:	case SSL_CTRL_SET_SESS_CACHE_SIZE:
    #####: 1153:		l=ctx->session_cache_size;
    #####: 1154:		ctx->session_cache_size=larg;
    #####: 1155:		return(l);
        -: 1156:	case SSL_CTRL_GET_SESS_CACHE_SIZE:
    #####: 1157:		return(ctx->session_cache_size);
        -: 1158:	case SSL_CTRL_SET_SESS_CACHE_MODE:
    #####: 1159:		l=ctx->session_cache_mode;
    #####: 1160:		ctx->session_cache_mode=larg;
    #####: 1161:		return(l);
        -: 1162:	case SSL_CTRL_GET_SESS_CACHE_MODE:
    #####: 1163:		return(ctx->session_cache_mode);
        -: 1164:
        -: 1165:	case SSL_CTRL_SESS_NUMBER:
    #####: 1166:		return(lh_SSL_SESSION_num_items(ctx->sessions));
        -: 1167:	case SSL_CTRL_SESS_CONNECT:
    #####: 1168:		return(ctx->stats.sess_connect);
        -: 1169:	case SSL_CTRL_SESS_CONNECT_GOOD:
    #####: 1170:		return(ctx->stats.sess_connect_good);
        -: 1171:	case SSL_CTRL_SESS_CONNECT_RENEGOTIATE:
    #####: 1172:		return(ctx->stats.sess_connect_renegotiate);
        -: 1173:	case SSL_CTRL_SESS_ACCEPT:
    #####: 1174:		return(ctx->stats.sess_accept);
        -: 1175:	case SSL_CTRL_SESS_ACCEPT_GOOD:
    #####: 1176:		return(ctx->stats.sess_accept_good);
        -: 1177:	case SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:
    #####: 1178:		return(ctx->stats.sess_accept_renegotiate);
        -: 1179:	case SSL_CTRL_SESS_HIT:
    #####: 1180:		return(ctx->stats.sess_hit);
        -: 1181:	case SSL_CTRL_SESS_CB_HIT:
    #####: 1182:		return(ctx->stats.sess_cb_hit);
        -: 1183:	case SSL_CTRL_SESS_MISSES:
    #####: 1184:		return(ctx->stats.sess_miss);
        -: 1185:	case SSL_CTRL_SESS_TIMEOUTS:
    #####: 1186:		return(ctx->stats.sess_timeout);
        -: 1187:	case SSL_CTRL_SESS_CACHE_FULL:
    #####: 1188:		return(ctx->stats.sess_cache_full);
        -: 1189:	case SSL_CTRL_OPTIONS:
    10000: 1190:		return(ctx->options|=larg);
        -: 1191:	case SSL_CTRL_CLEAR_OPTIONS:
    #####: 1192:		return(ctx->options&=~larg);
        -: 1193:	case SSL_CTRL_MODE:
    #####: 1194:		return(ctx->mode|=larg);
        -: 1195:	case SSL_CTRL_CLEAR_MODE:
    #####: 1196:		return(ctx->mode&=~larg);
        -: 1197:	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
    #####: 1198:		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
        -: 1199:			return 0;
    #####: 1200:		ctx->max_send_fragment = larg;
    #####: 1201:		return 1;
        -: 1202:	default:
    #####: 1203:		return(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));
        -: 1204:		}
        -: 1205:	}
        -: 1206:
    #####: 1207:long SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))
        -: 1208:	{
    #####: 1209:	switch(cmd)
        -: 1210:		{
        -: 1211:	case SSL_CTRL_SET_MSG_CALLBACK:
    #####: 1212:		ctx->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
    #####: 1213:		return 1;
        -: 1214:
        -: 1215:	default:
    #####: 1216:		return(ctx->method->ssl_ctx_callback_ctrl(ctx,cmd,fp));
        -: 1217:		}
        -: 1218:	}
        -: 1219:
    #####: 1220:int ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)
        -: 1221:	{
        -: 1222:	long l;
        -: 1223:
    40000: 1224:	l=a->id-b->id;
    40000: 1225:	if (l == 0L)
        -: 1226:		return(0);
        -: 1227:	else
    30000: 1228:		return((l > 0)?1:-1);
        -: 1229:	}
        -: 1230:
  4090000: 1231:int ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
        -: 1232:			const SSL_CIPHER * const *bp)
        -: 1233:	{
        -: 1234:	long l;
        -: 1235:
  4090000: 1236:	l=(*ap)->id-(*bp)->id;
  4090000: 1237:	if (l == 0L)
        -: 1238:		return(0);
        -: 1239:	else
  4080000: 1240:		return((l > 0)?1:-1);
        -: 1241:	}
        -: 1242:
        -: 1243:/** return a STACK of the ciphers available for the SSL and in order of
        -: 1244: * preference */
    30000: 1245:STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s)
        -: 1246:	{
    30000: 1247:	if (s != NULL)
        -: 1248:		{
    30000: 1249:		if (s->cipher_list != NULL)
        -: 1250:			{
        -: 1251:			return(s->cipher_list);
        -: 1252:			}
    60000: 1253:		else if ((s->ctx != NULL) &&
    30000: 1254:			(s->ctx->cipher_list != NULL))
        -: 1255:			{
    30000: 1256:			return(s->ctx->cipher_list);
        -: 1257:			}
        -: 1258:		}
        -: 1259:	return(NULL);
        -: 1260:	}
        -: 1261:
        -: 1262:/** return a STACK of the ciphers available for the SSL and in order of
        -: 1263: * algorithm id */
    10000: 1264:STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s)
        -: 1265:	{
    10000: 1266:	if (s != NULL)
        -: 1267:		{
    10000: 1268:		if (s->cipher_list_by_id != NULL)
        -: 1269:			{
        -: 1270:			return(s->cipher_list_by_id);
        -: 1271:			}
    20000: 1272:		else if ((s->ctx != NULL) &&
    10000: 1273:			(s->ctx->cipher_list_by_id != NULL))
        -: 1274:			{
    10000: 1275:			return(s->ctx->cipher_list_by_id);
        -: 1276:			}
        -: 1277:		}
        -: 1278:	return(NULL);
        -: 1279:	}
        -: 1280:
        -: 1281:/** The old interface to get the same thing as SSL_get_ciphers() */
    #####: 1282:const char *SSL_get_cipher_list(const SSL *s,int n)
        -: 1283:	{
        -: 1284:	SSL_CIPHER *c;
        -: 1285:	STACK_OF(SSL_CIPHER) *sk;
        -: 1286:
    #####: 1287:	if (s == NULL) return(NULL);
        -: 1288:	sk=SSL_get_ciphers(s);
    #####: 1289:	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        -: 1290:		return(NULL);
    #####: 1291:	c=sk_SSL_CIPHER_value(sk,n);
    #####: 1292:	if (c == NULL) return(NULL);
    #####: 1293:	return(c->name);
        -: 1294:	}
        -: 1295:
        -: 1296:/** specify the ciphers to be used by default by the SSL_CTX */
    #####: 1297:int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
        -: 1298:	{
        -: 1299:	STACK_OF(SSL_CIPHER) *sk;
        -: 1300:	
    #####: 1301:	sk=ssl_create_cipher_list(ctx->method,&ctx->cipher_list,
        -: 1302:		&ctx->cipher_list_by_id,str);
        -: 1303:	/* ssl_create_cipher_list may return an empty stack if it
        -: 1304:	 * was unable to find a cipher matching the given rule string
        -: 1305:	 * (for example if the rule string specifies a cipher which
        -: 1306:	 * has been disabled). This is not an error as far as
        -: 1307:	 * ssl_create_cipher_list is concerned, and hence
        -: 1308:	 * ctx->cipher_list and ctx->cipher_list_by_id has been
        -: 1309:	 * updated. */
    #####: 1310:	if (sk == NULL)
        -: 1311:		return 0;
    #####: 1312:	else if (sk_SSL_CIPHER_num(sk) == 0)
        -: 1313:		{
    #####: 1314:		SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
    #####: 1315:		return 0;
        -: 1316:		}
        -: 1317:	return 1;
        -: 1318:	}
        -: 1319:
        -: 1320:/** specify the ciphers to be used by the SSL */
    #####: 1321:int SSL_set_cipher_list(SSL *s,const char *str)
        -: 1322:	{
        -: 1323:	STACK_OF(SSL_CIPHER) *sk;
        -: 1324:	
    #####: 1325:	sk=ssl_create_cipher_list(s->ctx->method,&s->cipher_list,
        -: 1326:		&s->cipher_list_by_id,str);
        -: 1327:	/* see comment in SSL_CTX_set_cipher_list */
    #####: 1328:	if (sk == NULL)
        -: 1329:		return 0;
    #####: 1330:	else if (sk_SSL_CIPHER_num(sk) == 0)
        -: 1331:		{
    #####: 1332:		SSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
    #####: 1333:		return 0;
        -: 1334:		}
        -: 1335:	return 1;
        -: 1336:	}
        -: 1337:
        -: 1338:/* works well for SSLv2, not so good for SSLv3 */
    10000: 1339:char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
        -: 1340:	{
        -: 1341:	char *p;
        -: 1342:	STACK_OF(SSL_CIPHER) *sk;
        -: 1343:	SSL_CIPHER *c;
        -: 1344:	int i;
        -: 1345:
    10000: 1346:	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
        -: 1347:		(len < 2))
        -: 1348:		return(NULL);
        -: 1349:
        -: 1350:	p=buf;
        -: 1351:	sk=s->session->ciphers;
    #####: 1352:	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
        -: 1353:		{
        -: 1354:		int n;
        -: 1355:
    #####: 1356:		c=sk_SSL_CIPHER_value(sk,i);
    #####: 1357:		n=strlen(c->name);
    #####: 1358:		if (n+1 > len)
        -: 1359:			{
    #####: 1360:			if (p != buf)
    #####: 1361:				--p;
    #####: 1362:			*p='\0';
    #####: 1363:			return buf;
        -: 1364:			}
        -: 1365:		strcpy(p,c->name);
    #####: 1366:		p+=n;
    #####: 1367:		*(p++)=':';
    #####: 1368:		len-=n+1;
        -: 1369:		}
    #####: 1370:	p[-1]='\0';
    #####: 1371:	return(buf);
        -: 1372:	}
        -: 1373:
    10000: 1374:int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p,
        -: 1375:			     int (*put_cb)(const SSL_CIPHER *, unsigned char *))
        -: 1376:	{
        -: 1377:	int i,j=0;
        -: 1378:	SSL_CIPHER *c;
        -: 1379:	unsigned char *q;
        -: 1380:#ifndef OPENSSL_NO_KRB5
        -: 1381:	int nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
        -: 1382:#endif /* OPENSSL_NO_KRB5 */
        -: 1383:
    10000: 1384:	if (sk == NULL) return(0);
        -: 1385:	q=p;
        -: 1386:
   830000: 1387:	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
        -: 1388:		{
   830000: 1389:		c=sk_SSL_CIPHER_value(sk,i);
        -: 1390:		/* Skip TLS v1.2 only ciphersuites if lower than v1.2 */
  1110000: 1391:		if ((c->algorithm_ssl & SSL_TLSV1_2) && 
   560000: 1392:			(TLS1_get_client_version(s) < TLS1_2_VERSION))
    #####: 1393:			continue;
        -: 1394:#ifndef OPENSSL_NO_KRB5
        -: 1395:		if (((c->algorithm_mkey & SSL_kKRB5) || (c->algorithm_auth & SSL_aKRB5)) &&
        -: 1396:		    nokrb5)
        -: 1397:		    continue;
        -: 1398:#endif /* OPENSSL_NO_KRB5 */
        -: 1399:#ifndef OPENSSL_NO_PSK
        -: 1400:		/* with PSK there must be client callback set */
   870000: 1401:		if (((c->algorithm_mkey & SSL_kPSK) || (c->algorithm_auth & SSL_aPSK)) &&
    40000: 1402:		    s->psk_client_callback == NULL)
    40000: 1403:			continue;
        -: 1404:#endif /* OPENSSL_NO_PSK */
   790000: 1405:		j = put_cb ? put_cb(c,p) : ssl_put_cipher_by_char(s,c,p);
   790000: 1406:		p+=j;
        -: 1407:		}
        -: 1408:	/* If p == q, no ciphers and caller indicates an error. Otherwise
        -: 1409:	 * add SCSV if not renegotiating.
        -: 1410:	 */
    10000: 1411:	if (p != q && !s->renegotiate)
        -: 1412:		{
        -: 1413:		static SSL_CIPHER scsv =
        -: 1414:			{
        -: 1415:			0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
        -: 1416:			};
    10000: 1417:		j = put_cb ? put_cb(&scsv,p) : ssl_put_cipher_by_char(s,&scsv,p);
    10000: 1418:		p+=j;
        -: 1419:#ifdef OPENSSL_RI_DEBUG
        -: 1420:		fprintf(stderr, "SCSV sent by client\n");
        -: 1421:#endif
        -: 1422:		}
        -: 1423:
    10000: 1424:	return(p-q);
        -: 1425:	}
        -: 1426:
    #####: 1427:STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,
        -: 1428:					       STACK_OF(SSL_CIPHER) **skp)
        -: 1429:	{
        -: 1430:	const SSL_CIPHER *c;
        -: 1431:	STACK_OF(SSL_CIPHER) *sk;
        -: 1432:	int i,n;
    #####: 1433:	if (s->s3)
    #####: 1434:		s->s3->send_connection_binding = 0;
        -: 1435:
    #####: 1436:	n=ssl_put_cipher_by_char(s,NULL,NULL);
    #####: 1437:	if ((num%n) != 0)
        -: 1438:		{
    #####: 1439:		SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
    #####: 1440:		return(NULL);
        -: 1441:		}
    #####: 1442:	if ((skp == NULL) || (*skp == NULL))
    #####: 1443:		sk=sk_SSL_CIPHER_new_null(); /* change perhaps later */
        -: 1444:	else
        -: 1445:		{
        -: 1446:		sk= *skp;
    #####: 1447:		sk_SSL_CIPHER_zero(sk);
        -: 1448:		}
        -: 1449:
    #####: 1450:	for (i=0; i<num; i+=n)
        -: 1451:		{
        -: 1452:		/* Check for SCSV */
    #####: 1453:		if (s->s3 && (n != 3 || !p[0]) &&
    #####: 1454:			(p[n-2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
    #####: 1455:			(p[n-1] == (SSL3_CK_SCSV & 0xff)))
        -: 1456:			{
        -: 1457:			/* SCSV fatal if renegotiating */
    #####: 1458:			if (s->renegotiate)
        -: 1459:				{
    #####: 1460:				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
    #####: 1461:				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); 
    #####: 1462:				goto err;
        -: 1463:				}
    #####: 1464:			s->s3->send_connection_binding = 1;
    #####: 1465:			p += n;
        -: 1466:#ifdef OPENSSL_RI_DEBUG
        -: 1467:			fprintf(stderr, "SCSV received by server\n");
        -: 1468:#endif
    #####: 1469:			continue;
        -: 1470:			}
        -: 1471:
    #####: 1472:		c=ssl_get_cipher_by_char(s,p);
    #####: 1473:		p+=n;
    #####: 1474:		if (c != NULL)
        -: 1475:			{
    #####: 1476:			if (!sk_SSL_CIPHER_push(sk,c))
        -: 1477:				{
    #####: 1478:				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
    #####: 1479:				goto err;
        -: 1480:				}
        -: 1481:			}
        -: 1482:		}
        -: 1483:
    #####: 1484:	if (skp != NULL)
    #####: 1485:		*skp=sk;
    #####: 1486:	return(sk);
        -: 1487:err:
    #####: 1488:	if ((skp == NULL) || (*skp == NULL))
    #####: 1489:		sk_SSL_CIPHER_free(sk);
        -: 1490:	return(NULL);
        -: 1491:	}
        -: 1492:
        -: 1493:
        -: 1494:#ifndef OPENSSL_NO_TLSEXT
        -: 1495:/** return a servername extension value if provided in Client Hello, or NULL.
        -: 1496: * So far, only host_name types are defined (RFC 3546).
        -: 1497: */
        -: 1498:
    #####: 1499:const char *SSL_get_servername(const SSL *s, const int type)
        -: 1500:	{
    #####: 1501:	if (type != TLSEXT_NAMETYPE_host_name)
        -: 1502:		return NULL;
        -: 1503:
    #####: 1504:	return s->session && !s->tlsext_hostname ?
    #####: 1505:		s->session->tlsext_hostname :
        -: 1506:		s->tlsext_hostname;
        -: 1507:	}
        -: 1508:
    #####: 1509:int SSL_get_servername_type(const SSL *s)
        -: 1510:	{
    #####: 1511:	if (s->session && (!s->tlsext_hostname ? s->session->tlsext_hostname : s->tlsext_hostname))
        -: 1512:		return TLSEXT_NAMETYPE_host_name;
    #####: 1513:	return -1;
        -: 1514:	}
        -: 1515:
        -: 1516:# ifndef OPENSSL_NO_NEXTPROTONEG
        -: 1517:/* SSL_select_next_proto implements the standard protocol selection. It is
        -: 1518: * expected that this function is called from the callback set by
        -: 1519: * SSL_CTX_set_next_proto_select_cb.
        -: 1520: *
        -: 1521: * The protocol data is assumed to be a vector of 8-bit, length prefixed byte
        -: 1522: * strings. The length byte itself is not included in the length. A byte
        -: 1523: * string of length 0 is invalid. No byte string may be truncated.
        -: 1524: *
        -: 1525: * The current, but experimental algorithm for selecting the protocol is:
        -: 1526: *
        -: 1527: * 1) If the server doesn't support NPN then this is indicated to the
        -: 1528: * callback. In this case, the client application has to abort the connection
        -: 1529: * or have a default application level protocol.
        -: 1530: *
        -: 1531: * 2) If the server supports NPN, but advertises an empty list then the
        -: 1532: * client selects the first protcol in its list, but indicates via the
        -: 1533: * API that this fallback case was enacted.
        -: 1534: *
        -: 1535: * 3) Otherwise, the client finds the first protocol in the server's list
        -: 1536: * that it supports and selects this protocol. This is because it's
        -: 1537: * assumed that the server has better information about which protocol
        -: 1538: * a client should use.
        -: 1539: *
        -: 1540: * 4) If the client doesn't support any of the server's advertised
        -: 1541: * protocols, then this is treated the same as case 2.
        -: 1542: *
        -: 1543: * It returns either
        -: 1544: * OPENSSL_NPN_NEGOTIATED if a common protocol was found, or
        -: 1545: * OPENSSL_NPN_NO_OVERLAP if the fallback case was reached.
        -: 1546: */
    #####: 1547:int SSL_select_next_proto(unsigned char **out, unsigned char *outlen, const unsigned char *server, unsigned int server_len, const unsigned char *client, unsigned int client_len)
        -: 1548:	{
        -: 1549:	unsigned int i, j;
        -: 1550:	const unsigned char *result;
        -: 1551:	int status = OPENSSL_NPN_UNSUPPORTED;
        -: 1552:
        -: 1553:	/* For each protocol in server preference order, see if we support it. */
    #####: 1554:	for (i = 0; i < server_len; )
        -: 1555:		{
    #####: 1556:		for (j = 0; j < client_len; )
        -: 1557:			{
    #####: 1558:			if (server[i] == client[j] &&
    #####: 1559:			    memcmp(&server[i+1], &client[j+1], server[i]) == 0)
        -: 1560:				{
        -: 1561:				/* We found a match */
        -: 1562:				result = &server[i];
        -: 1563:				status = OPENSSL_NPN_NEGOTIATED;
        -: 1564:				goto found;
        -: 1565:				}
    #####: 1566:			j += client[j];
    #####: 1567:			j++;
        -: 1568:			}
    #####: 1569:		i += server[i];
    #####: 1570:		i++;
        -: 1571:		}
        -: 1572:
        -: 1573:	/* There's no overlap between our protocols and the server's list. */
        -: 1574:	result = client;
        -: 1575:	status = OPENSSL_NPN_NO_OVERLAP;
        -: 1576:
        -: 1577:	found:
    #####: 1578:	*out = (unsigned char *) result + 1;
    #####: 1579:	*outlen = result[0];
    #####: 1580:	return status;
        -: 1581:	}
        -: 1582:
        -: 1583:/* SSL_get0_next_proto_negotiated sets *data and *len to point to the client's
        -: 1584: * requested protocol for this connection and returns 0. If the client didn't
        -: 1585: * request any protocol, then *data is set to NULL.
        -: 1586: *
        -: 1587: * Note that the client can request any protocol it chooses. The value returned
        -: 1588: * from this function need not be a member of the list of supported protocols
        -: 1589: * provided by the callback.
        -: 1590: */
    #####: 1591:void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data, unsigned *len)
        -: 1592:	{
    #####: 1593:	*data = s->next_proto_negotiated;
    #####: 1594:	if (!*data) {
    #####: 1595:		*len = 0;
        -: 1596:	} else {
    #####: 1597:		*len = s->next_proto_negotiated_len;
        -: 1598:	}
    #####: 1599:}
        -: 1600:
        -: 1601:/* SSL_CTX_set_next_protos_advertised_cb sets a callback that is called when a
        -: 1602: * TLS server needs a list of supported protocols for Next Protocol
        -: 1603: * Negotiation. The returned list must be in wire format.  The list is returned
        -: 1604: * by setting |out| to point to it and |outlen| to its length. This memory will
        -: 1605: * not be modified, but one should assume that the SSL* keeps a reference to
        -: 1606: * it.
        -: 1607: *
        -: 1608: * The callback should return SSL_TLSEXT_ERR_OK if it wishes to advertise. Otherwise, no
        -: 1609: * such extension will be included in the ServerHello. */
    #####: 1610:void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl, const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
        -: 1611:	{
    #####: 1612:	ctx->next_protos_advertised_cb = cb;
    #####: 1613:	ctx->next_protos_advertised_cb_arg = arg;
    #####: 1614:	}
        -: 1615:
        -: 1616:/* SSL_CTX_set_next_proto_select_cb sets a callback that is called when a
        -: 1617: * client needs to select a protocol from the server's provided list. |out|
        -: 1618: * must be set to point to the selected protocol (which may be within |in|).
        -: 1619: * The length of the protocol name must be written into |outlen|. The server's
        -: 1620: * advertised protocols are provided in |in| and |inlen|. The callback can
        -: 1621: * assume that |in| is syntactically valid.
        -: 1622: *
        -: 1623: * The client must select a protocol. It is fatal to the connection if this
        -: 1624: * callback returns a value other than SSL_TLSEXT_ERR_OK.
        -: 1625: */
    #####: 1626:void SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg), void *arg)
        -: 1627:	{
    #####: 1628:	ctx->next_proto_select_cb = cb;
    #####: 1629:	ctx->next_proto_select_cb_arg = arg;
    #####: 1630:	}
        -: 1631:# endif
        -: 1632:#endif
        -: 1633:
    #####: 1634:int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
        -: 1635:	const char *label, size_t llen, const unsigned char *p, size_t plen,
        -: 1636:	int use_context)
        -: 1637:	{
    #####: 1638:	if (s->version < TLS1_VERSION)
        -: 1639:		return -1;
        -: 1640:
    #####: 1641:	return s->method->ssl3_enc->export_keying_material(s, out, olen, label,
        -: 1642:							   llen, p, plen,
        -: 1643:							   use_context);
        -: 1644:	}
        -: 1645:
        -: 1646:static unsigned long ssl_session_hash(const SSL_SESSION *a)
        -: 1647:	{
        -: 1648:	unsigned long l;
        -: 1649:
    #####: 1650:	l=(unsigned long)
    #####: 1651:		((unsigned int) a->session_id[0]     )|
    #####: 1652:		((unsigned int) a->session_id[1]<< 8L)|
    #####: 1653:		((unsigned long)a->session_id[2]<<16L)|
    #####: 1654:		((unsigned long)a->session_id[3]<<24L);
        -: 1655:	return(l);
        -: 1656:	}
        -: 1657:
        -: 1658:/* NB: If this function (or indeed the hash function which uses a sort of
        -: 1659: * coarser function than this one) is changed, ensure
        -: 1660: * SSL_CTX_has_matching_session_id() is checked accordingly. It relies on being
        -: 1661: * able to construct an SSL_SESSION that will collide with any existing session
        -: 1662: * with a matching session ID. */
    #####: 1663:static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)
        -: 1664:	{
    #####: 1665:	if (a->ssl_version != b->ssl_version)
        -: 1666:		return(1);
    #####: 1667:	if (a->session_id_length != b->session_id_length)
        -: 1668:		return(1);
    #####: 1669:	return(memcmp(a->session_id,b->session_id,a->session_id_length));
        -: 1670:	}
        -: 1671:
        -: 1672:/* These wrapper functions should remain rather than redeclaring
        -: 1673: * SSL_SESSION_hash and SSL_SESSION_cmp for void* types and casting each
        -: 1674: * variable. The reason is that the functions aren't static, they're exposed via
        -: 1675: * ssl.h. */
    #####: 1676:static IMPLEMENT_LHASH_HASH_FN(ssl_session, SSL_SESSION)
    #####: 1677:static IMPLEMENT_LHASH_COMP_FN(ssl_session, SSL_SESSION)
        -: 1678:
    10000: 1679:SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)
        -: 1680:	{
        -: 1681:	SSL_CTX *ret=NULL;
        -: 1682:
    10000: 1683:	if (meth == NULL)
        -: 1684:		{
    #####: 1685:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_NULL_SSL_METHOD_PASSED);
    #####: 1686:		return(NULL);
        -: 1687:		}
        -: 1688:
        -: 1689:#ifdef OPENSSL_FIPS
        -: 1690:	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
        -: 1691:		{
        -: 1692:		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
        -: 1693:		return NULL;
        -: 1694:		}
        -: 1695:#endif
        -: 1696:
    10000: 1697:	if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0)
        -: 1698:		{
    #####: 1699:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
    #####: 1700:		goto err;
        -: 1701:		}
    10000: 1702:	ret=(SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));
    10000: 1703:	if (ret == NULL)
        -: 1704:		goto err;
        -: 1705:
        -: 1706:	memset(ret,0,sizeof(SSL_CTX));
        -: 1707:
    10000: 1708:	ret->method=meth;
        -: 1709:
    10000: 1710:	ret->cert_store=NULL;
    10000: 1711:	ret->session_cache_mode=SSL_SESS_CACHE_SERVER;
    10000: 1712:	ret->session_cache_size=SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;
    10000: 1713:	ret->session_cache_head=NULL;
    10000: 1714:	ret->session_cache_tail=NULL;
        -: 1715:
        -: 1716:	/* We take the system default */
    10000: 1717:	ret->session_timeout=meth->get_timeout();
        -: 1718:
    10000: 1719:	ret->new_session_cb=0;
    10000: 1720:	ret->remove_session_cb=0;
    10000: 1721:	ret->get_session_cb=0;
    10000: 1722:	ret->generate_session_id=0;
        -: 1723:
    10000: 1724:	memset((char *)&ret->stats,0,sizeof(ret->stats));
        -: 1725:
    10000: 1726:	ret->references=1;
    10000: 1727:	ret->quiet_shutdown=0;
        -: 1728:
        -: 1729:/*	ret->cipher=NULL;*/
        -: 1730:/*	ret->s2->challenge=NULL;
        -: 1731:	ret->master_key=NULL;
        -: 1732:	ret->key_arg=NULL;
        -: 1733:	ret->s2->conn_id=NULL; */
        -: 1734:
    10000: 1735:	ret->info_callback=NULL;
        -: 1736:
    10000: 1737:	ret->app_verify_callback=0;
    10000: 1738:	ret->app_verify_arg=NULL;
        -: 1739:
    10000: 1740:	ret->max_cert_list=SSL_MAX_CERT_LIST_DEFAULT;
    10000: 1741:	ret->read_ahead=0;
    10000: 1742:	ret->msg_callback=0;
    10000: 1743:	ret->msg_callback_arg=NULL;
    10000: 1744:	ret->verify_mode=SSL_VERIFY_NONE;
        -: 1745:#if 0
        -: 1746:	ret->verify_depth=-1; /* Don't impose a limit (but x509_lu.c does) */
        -: 1747:#endif
    10000: 1748:	ret->sid_ctx_length=0;
    10000: 1749:	ret->default_verify_callback=NULL;
    10000: 1750:	if ((ret->cert=ssl_cert_new()) == NULL)
        -: 1751:		goto err;
        -: 1752:
    10000: 1753:	ret->default_passwd_callback=0;
    10000: 1754:	ret->default_passwd_callback_userdata=NULL;
    10000: 1755:	ret->client_cert_cb=0;
    10000: 1756:	ret->app_gen_cookie_cb=0;
    10000: 1757:	ret->app_verify_cookie_cb=0;
        -: 1758:
    10000: 1759:	ret->sessions=lh_SSL_SESSION_new();
    10000: 1760:	if (ret->sessions == NULL) goto err;
    10000: 1761:	ret->cert_store=X509_STORE_new();
    10000: 1762:	if (ret->cert_store == NULL) goto err;
        -: 1763:
    10000: 1764:	ssl_create_cipher_list(ret->method,
        -: 1765:		&ret->cipher_list,&ret->cipher_list_by_id,
    10000: 1766:		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
    10000: 1767:	if (ret->cipher_list == NULL
    10000: 1768:	    || sk_SSL_CIPHER_num(ret->cipher_list) <= 0)
        -: 1769:		{
    #####: 1770:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_LIBRARY_HAS_NO_CIPHERS);
    #####: 1771:		goto err2;
        -: 1772:		}
        -: 1773:
    10000: 1774:	ret->param = X509_VERIFY_PARAM_new();
    10000: 1775:	if (!ret->param)
        -: 1776:		goto err;
        -: 1777:
    10000: 1778:	if ((ret->rsa_md5=EVP_get_digestbyname("ssl2-md5")) == NULL)
        -: 1779:		{
    #####: 1780:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);
    #####: 1781:		goto err2;
        -: 1782:		}
    10000: 1783:	if ((ret->md5=EVP_get_digestbyname("ssl3-md5")) == NULL)
        -: 1784:		{
    #####: 1785:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
    #####: 1786:		goto err2;
        -: 1787:		}
    10000: 1788:	if ((ret->sha1=EVP_get_digestbyname("ssl3-sha1")) == NULL)
        -: 1789:		{
    #####: 1790:		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
    #####: 1791:		goto err2;
        -: 1792:		}
        -: 1793:
    10000: 1794:	if ((ret->client_CA=sk_X509_NAME_new_null()) == NULL)
        -: 1795:		goto err;
        -: 1796:
    10000: 1797:	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data);
        -: 1798:
    10000: 1799:	ret->extra_certs=NULL;
    10000: 1800:	ret->comp_methods=SSL_COMP_get_compression_methods();
        -: 1801:
    10000: 1802:	ret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;
        -: 1803:
        -: 1804:#ifndef OPENSSL_NO_TLSEXT
    10000: 1805:	ret->tlsext_servername_callback = 0;
    10000: 1806:	ret->tlsext_servername_arg = NULL;
        -: 1807:	/* Setup RFC4507 ticket keys */
    10000: 1808:	if ((RAND_pseudo_bytes(ret->tlsext_tick_key_name, 16) <= 0)
    10000: 1809:		|| (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
    10000: 1810:		|| (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
    #####: 1811:		ret->options |= SSL_OP_NO_TICKET;
        -: 1812:
    10000: 1813:	ret->tlsext_status_cb = 0;
    10000: 1814:	ret->tlsext_status_arg = NULL;
        -: 1815:
        -: 1816:# ifndef OPENSSL_NO_NEXTPROTONEG
    10000: 1817:	ret->next_protos_advertised_cb = 0;
    10000: 1818:	ret->next_proto_select_cb = 0;
        -: 1819:# endif
        -: 1820:#endif
        -: 1821:#ifndef OPENSSL_NO_PSK
    10000: 1822:	ret->psk_identity_hint=NULL;
    10000: 1823:	ret->psk_client_callback=NULL;
    10000: 1824:	ret->psk_server_callback=NULL;
        -: 1825:#endif
        -: 1826:#ifndef OPENSSL_NO_SRP
    10000: 1827:	SSL_CTX_SRP_CTX_init(ret);
        -: 1828:#endif
        -: 1829:#ifndef OPENSSL_NO_BUF_FREELISTS
    10000: 1830:	ret->freelist_max_len = SSL_MAX_BUF_FREELIST_LEN_DEFAULT;
    10000: 1831:	ret->rbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
    10000: 1832:	if (!ret->rbuf_freelist)
        -: 1833:		goto err;
    10000: 1834:	ret->rbuf_freelist->chunklen = 0;
    10000: 1835:	ret->rbuf_freelist->len = 0;
    10000: 1836:	ret->rbuf_freelist->head = NULL;
    10000: 1837:	ret->wbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
    10000: 1838:	if (!ret->wbuf_freelist)
        -: 1839:		{
    #####: 1840:		OPENSSL_free(ret->rbuf_freelist);
    #####: 1841:		goto err;
        -: 1842:		}
    10000: 1843:	ret->wbuf_freelist->chunklen = 0;
    10000: 1844:	ret->wbuf_freelist->len = 0;
    10000: 1845:	ret->wbuf_freelist->head = NULL;
        -: 1846:#endif
        -: 1847:#ifndef OPENSSL_NO_ENGINE
    10000: 1848:	ret->client_cert_engine = NULL;
        -: 1849:#ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO
        -: 1850:#define eng_strx(x)	#x
        -: 1851:#define eng_str(x)	eng_strx(x)
        -: 1852:	/* Use specific client engine automatically... ignore errors */
        -: 1853:	{
        -: 1854:	ENGINE *eng;
        -: 1855:	eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
        -: 1856:	if (!eng)
        -: 1857:		{
        -: 1858:		ERR_clear_error();
        -: 1859:		ENGINE_load_builtin_engines();
        -: 1860:		eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
        -: 1861:		}
        -: 1862:	if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))
        -: 1863:		ERR_clear_error();
        -: 1864:	}
        -: 1865:#endif
        -: 1866:#endif
        -: 1867:	/* Default is to connect to non-RI servers. When RI is more widely
        -: 1868:	 * deployed might change this.
        -: 1869:	 */
    10000: 1870:	ret->options |= SSL_OP_LEGACY_SERVER_CONNECT;
        -: 1871:
    10000: 1872:	return(ret);
        -: 1873:err:
    #####: 1874:	SSLerr(SSL_F_SSL_CTX_NEW,ERR_R_MALLOC_FAILURE);
        -: 1875:err2:
    #####: 1876:	if (ret != NULL) SSL_CTX_free(ret);
        -: 1877:	return(NULL);
        -: 1878:	}
        -: 1879:
        -: 1880:#if 0
        -: 1881:static void SSL_COMP_free(SSL_COMP *comp)
        -: 1882:    { OPENSSL_free(comp); }
        -: 1883:#endif
        -: 1884:
        -: 1885:#ifndef OPENSSL_NO_BUF_FREELISTS
        -: 1886:static void
    20000: 1887:ssl_buf_freelist_free(SSL3_BUF_FREELIST *list)
        -: 1888:	{
        -: 1889:	SSL3_BUF_FREELIST_ENTRY *ent, *next;
    60000: 1890:	for (ent = list->head; ent; ent = next)
        -: 1891:		{
    20000: 1892:		next = ent->next;
    20000: 1893:		OPENSSL_free(ent);
        -: 1894:		}
    20000: 1895:	OPENSSL_free(list);
    20000: 1896:	}
        -: 1897:#endif
        -: 1898:
    30000: 1899:void SSL_CTX_free(SSL_CTX *a)
        -: 1900:	{
        -: 1901:	int i;
        -: 1902:
    30000: 1903:	if (a == NULL) return;
        -: 1904:
    30000: 1905:	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_SSL_CTX);
        -: 1906:#ifdef REF_PRINT
        -: 1907:	REF_PRINT("SSL_CTX",a);
        -: 1908:#endif
    30000: 1909:	if (i > 0) return;
        -: 1910:#ifdef REF_CHECK
        -: 1911:	if (i < 0)
        -: 1912:		{
        -: 1913:		fprintf(stderr,"SSL_CTX_free, bad reference count\n");
        -: 1914:		abort(); /* ok */
        -: 1915:		}
        -: 1916:#endif
        -: 1917:
    10000: 1918:	if (a->param)
    10000: 1919:		X509_VERIFY_PARAM_free(a->param);
        -: 1920:
        -: 1921:	/*
        -: 1922:	 * Free internal session cache. However: the remove_cb() may reference
        -: 1923:	 * the ex_data of SSL_CTX, thus the ex_data store can only be removed
        -: 1924:	 * after the sessions were flushed.
        -: 1925:	 * As the ex_data handling routines might also touch the session cache,
        -: 1926:	 * the most secure solution seems to be: empty (flush) the cache, then
        -: 1927:	 * free ex_data, then finally free the cache.
        -: 1928:	 * (See ticket [openssl.org #212].)
        -: 1929:	 */
    10000: 1930:	if (a->sessions != NULL)
    10000: 1931:		SSL_CTX_flush_sessions(a,0);
        -: 1932:
    10000: 1933:	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);
        -: 1934:
    10000: 1935:	if (a->sessions != NULL)
    10000: 1936:		lh_SSL_SESSION_free(a->sessions);
        -: 1937:
    10000: 1938:	if (a->cert_store != NULL)
    10000: 1939:		X509_STORE_free(a->cert_store);
    10000: 1940:	if (a->cipher_list != NULL)
    10000: 1941:		sk_SSL_CIPHER_free(a->cipher_list);
    10000: 1942:	if (a->cipher_list_by_id != NULL)
    10000: 1943:		sk_SSL_CIPHER_free(a->cipher_list_by_id);
    10000: 1944:	if (a->cert != NULL)
    10000: 1945:		ssl_cert_free(a->cert);
    10000: 1946:	if (a->client_CA != NULL)
    10000: 1947:		sk_X509_NAME_pop_free(a->client_CA,X509_NAME_free);
    10000: 1948:	if (a->extra_certs != NULL)
    #####: 1949:		sk_X509_pop_free(a->extra_certs,X509_free);
        -: 1950:#if 0 /* This should never be done, since it removes a global database */
        -: 1951:	if (a->comp_methods != NULL)
        -: 1952:		sk_SSL_COMP_pop_free(a->comp_methods,SSL_COMP_free);
        -: 1953:#else
    10000: 1954:	a->comp_methods = NULL;
        -: 1955:#endif
        -: 1956:
        -: 1957:#ifndef OPENSSL_NO_SRTP
    10000: 1958:        if (a->srtp_profiles)
    #####: 1959:                sk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);
        -: 1960:#endif
        -: 1961:
        -: 1962:#ifndef OPENSSL_NO_PSK
    10000: 1963:	if (a->psk_identity_hint)
    #####: 1964:		OPENSSL_free(a->psk_identity_hint);
        -: 1965:#endif
        -: 1966:#ifndef OPENSSL_NO_SRP
    10000: 1967:	SSL_CTX_SRP_CTX_free(a);
        -: 1968:#endif
        -: 1969:#ifndef OPENSSL_NO_ENGINE
    10000: 1970:	if (a->client_cert_engine)
    #####: 1971:		ENGINE_finish(a->client_cert_engine);
        -: 1972:#endif
        -: 1973:
        -: 1974:#ifndef OPENSSL_NO_BUF_FREELISTS
    10000: 1975:	if (a->wbuf_freelist)
    10000: 1976:		ssl_buf_freelist_free(a->wbuf_freelist);
    10000: 1977:	if (a->rbuf_freelist)
    10000: 1978:		ssl_buf_freelist_free(a->rbuf_freelist);
        -: 1979:#endif
        -: 1980:
    10000: 1981:	OPENSSL_free(a);
        -: 1982:	}
        -: 1983:
    #####: 1984:void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)
        -: 1985:	{
    #####: 1986:	ctx->default_passwd_callback=cb;
    #####: 1987:	}
        -: 1988:
    #####: 1989:void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx,void *u)
        -: 1990:	{
    #####: 1991:	ctx->default_passwd_callback_userdata=u;
    #####: 1992:	}
        -: 1993:
    #####: 1994:void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg)
        -: 1995:	{
    #####: 1996:	ctx->app_verify_callback=cb;
    #####: 1997:	ctx->app_verify_arg=arg;
    #####: 1998:	}
        -: 1999:
    10000: 2000:void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*cb)(int, X509_STORE_CTX *))
        -: 2001:	{
    10000: 2002:	ctx->verify_mode=mode;
    10000: 2003:	ctx->default_verify_callback=cb;
    10000: 2004:	}
        -: 2005:
    #####: 2006:void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth)
        -: 2007:	{
    #####: 2008:	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
    #####: 2009:	}
        -: 2010:
    #####: 2011:void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
        -: 2012:	{
        -: 2013:	CERT_PKEY *cpk;
        -: 2014:	int rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;
        -: 2015:	int rsa_enc_export,dh_rsa_export,dh_dsa_export;
        -: 2016:	int rsa_tmp_export,dh_tmp_export,kl;
        -: 2017:	unsigned long mask_k,mask_a,emask_k,emask_a;
        -: 2018:	int have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;
        -: 2019:#ifndef OPENSSL_NO_ECDH
        -: 2020:	int have_ecdh_tmp;
        -: 2021:#endif
        -: 2022:	X509 *x = NULL;
        -: 2023:	EVP_PKEY *ecc_pkey = NULL;
    #####: 2024:	int signature_nid = 0, pk_nid = 0, md_nid = 0;
        -: 2025:
    #####: 2026:	if (c == NULL) return;
        -: 2027:
    #####: 2028:	kl=SSL_C_EXPORT_PKEYLENGTH(cipher);
        -: 2029:
        -: 2030:#ifndef OPENSSL_NO_RSA
    #####: 2031:	rsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);
    #####: 2032:	rsa_tmp_export=(c->rsa_tmp_cb != NULL ||
    #####: 2033:		(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));
        -: 2034:#else
        -: 2035:	rsa_tmp=rsa_tmp_export=0;
        -: 2036:#endif
        -: 2037:#ifndef OPENSSL_NO_DH
    #####: 2038:	dh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);
    #####: 2039:	dh_tmp_export=(c->dh_tmp_cb != NULL ||
    #####: 2040:		(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));
        -: 2041:#else
        -: 2042:	dh_tmp=dh_tmp_export=0;
        -: 2043:#endif
        -: 2044:
        -: 2045:#ifndef OPENSSL_NO_ECDH
    #####: 2046:	have_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);
        -: 2047:#endif
        -: 2048:	cpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);
    #####: 2049:	rsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);
    #####: 2050:	rsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
        -: 2051:	cpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);
    #####: 2052:	rsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
        -: 2053:	cpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);
    #####: 2054:	dsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
        -: 2055:	cpk= &(c->pkeys[SSL_PKEY_DH_RSA]);
    #####: 2056:	dh_rsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
    #####: 2057:	dh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
        -: 2058:	cpk= &(c->pkeys[SSL_PKEY_DH_DSA]);
        -: 2059:/* FIX THIS EAY EAY EAY */
    #####: 2060:	dh_dsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
    #####: 2061:	dh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
        -: 2062:	cpk= &(c->pkeys[SSL_PKEY_ECC]);
    #####: 2063:	have_ecc_cert= (cpk->x509 != NULL && cpk->privatekey != NULL);
        -: 2064:	mask_k=0;
        -: 2065:	mask_a=0;
        -: 2066:	emask_k=0;
        -: 2067:	emask_a=0;
        -: 2068:
        -: 2069:	
        -: 2070:
        -: 2071:#ifdef CIPHER_DEBUG
        -: 2072:	printf("rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\n",
        -: 2073:	        rsa_tmp,rsa_tmp_export,dh_tmp,have_ecdh_tmp,
        -: 2074:		rsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);
        -: 2075:#endif
        -: 2076:	
        -: 2077:	cpk = &(c->pkeys[SSL_PKEY_GOST01]);
    #####: 2078:	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
        -: 2079:		mask_k |= SSL_kGOST;
        -: 2080:		mask_a |= SSL_aGOST01;
        -: 2081:	}
        -: 2082:	cpk = &(c->pkeys[SSL_PKEY_GOST94]);
    #####: 2083:	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
        -: 2084:		mask_k |= SSL_kGOST;
    #####: 2085:		mask_a |= SSL_aGOST94;
        -: 2086:	}
        -: 2087:
    #####: 2088:	if (rsa_enc || (rsa_tmp && rsa_sign))
    #####: 2089:		mask_k|=SSL_kRSA;
    #####: 2090:	if (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))
        -: 2091:		emask_k|=SSL_kRSA;
        -: 2092:
        -: 2093:#if 0
        -: 2094:	/* The match needs to be both kEDH and aRSA or aDSA, so don't worry */
        -: 2095:	if (	(dh_tmp || dh_rsa || dh_dsa) &&
        -: 2096:		(rsa_enc || rsa_sign || dsa_sign))
        -: 2097:		mask_k|=SSL_kEDH;
        -: 2098:	if ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&
        -: 2099:		(rsa_enc || rsa_sign || dsa_sign))
        -: 2100:		emask_k|=SSL_kEDH;
        -: 2101:#endif
        -: 2102:
    #####: 2103:	if (dh_tmp_export)
    #####: 2104:		emask_k|=SSL_kEDH;
        -: 2105:
    #####: 2106:	if (dh_tmp)
    #####: 2107:		mask_k|=SSL_kEDH;
        -: 2108:
    #####: 2109:	if (dh_rsa) mask_k|=SSL_kDHr;
    #####: 2110:	if (dh_rsa_export) emask_k|=SSL_kDHr;
        -: 2111:
    #####: 2112:	if (dh_dsa) mask_k|=SSL_kDHd;
    #####: 2113:	if (dh_dsa_export) emask_k|=SSL_kDHd;
        -: 2114:
    #####: 2115:	if (rsa_enc || rsa_sign)
        -: 2116:		{
    #####: 2117:		mask_a|=SSL_aRSA;
        -: 2118:		emask_a|=SSL_aRSA;
        -: 2119:		}
        -: 2120:
    #####: 2121:	if (dsa_sign)
        -: 2122:		{
    #####: 2123:		mask_a|=SSL_aDSS;
    #####: 2124:		emask_a|=SSL_aDSS;
        -: 2125:		}
        -: 2126:
    #####: 2127:	mask_a|=SSL_aNULL;
    #####: 2128:	emask_a|=SSL_aNULL;
        -: 2129:
        -: 2130:#ifndef OPENSSL_NO_KRB5
        -: 2131:	mask_k|=SSL_kKRB5;
        -: 2132:	mask_a|=SSL_aKRB5;
        -: 2133:	emask_k|=SSL_kKRB5;
        -: 2134:	emask_a|=SSL_aKRB5;
        -: 2135:#endif
        -: 2136:
        -: 2137:	/* An ECC certificate may be usable for ECDH and/or
        -: 2138:	 * ECDSA cipher suites depending on the key usage extension.
        -: 2139:	 */
    #####: 2140:	if (have_ecc_cert)
        -: 2141:		{
        -: 2142:		/* This call populates extension flags (ex_flags) */
        -: 2143:		x = (c->pkeys[SSL_PKEY_ECC]).x509;
    #####: 2144:		X509_check_purpose(x, -1, 0);
    #####: 2145:		ecdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
    #####: 2146:		    (x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;
    #####: 2147:		ecdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
    #####: 2148:		    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;
    #####: 2149:		ecc_pkey = X509_get_pubkey(x);
        -: 2150:		ecc_pkey_size = (ecc_pkey != NULL) ?
    #####: 2151:		    EVP_PKEY_bits(ecc_pkey) : 0;
    #####: 2152:		EVP_PKEY_free(ecc_pkey);
    #####: 2153:		if ((x->sig_alg) && (x->sig_alg->algorithm))
        -: 2154:			{
    #####: 2155:			signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
    #####: 2156:			OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
        -: 2157:			}
        -: 2158:#ifndef OPENSSL_NO_ECDH
    #####: 2159:		if (ecdh_ok)
        -: 2160:			{
        -: 2161:
    #####: 2162:			if (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa)
        -: 2163:				{
    #####: 2164:				mask_k|=SSL_kECDHr;
    #####: 2165:				mask_a|=SSL_aECDH;
    #####: 2166:				if (ecc_pkey_size <= 163)
        -: 2167:					{
    #####: 2168:					emask_k|=SSL_kECDHr;
    #####: 2169:					emask_a|=SSL_aECDH;
        -: 2170:					}
        -: 2171:				}
        -: 2172:
    #####: 2173:			if (pk_nid == NID_X9_62_id_ecPublicKey)
        -: 2174:				{
    #####: 2175:				mask_k|=SSL_kECDHe;
    #####: 2176:				mask_a|=SSL_aECDH;
    #####: 2177:				if (ecc_pkey_size <= 163)
        -: 2178:					{
    #####: 2179:					emask_k|=SSL_kECDHe;
    #####: 2180:					emask_a|=SSL_aECDH;
        -: 2181:					}
        -: 2182:				}
        -: 2183:			}
        -: 2184:#endif
        -: 2185:#ifndef OPENSSL_NO_ECDSA
    #####: 2186:		if (ecdsa_ok)
        -: 2187:			{
    #####: 2188:			mask_a|=SSL_aECDSA;
    #####: 2189:			emask_a|=SSL_aECDSA;
        -: 2190:			}
        -: 2191:#endif
        -: 2192:		}
        -: 2193:
        -: 2194:#ifndef OPENSSL_NO_ECDH
    #####: 2195:	if (have_ecdh_tmp)
        -: 2196:		{
    #####: 2197:		mask_k|=SSL_kEECDH;
    #####: 2198:		emask_k|=SSL_kEECDH;
        -: 2199:		}
        -: 2200:#endif
        -: 2201:
        -: 2202:#ifndef OPENSSL_NO_PSK
    #####: 2203:	mask_k |= SSL_kPSK;
    #####: 2204:	mask_a |= SSL_aPSK;
    #####: 2205:	emask_k |= SSL_kPSK;
    #####: 2206:	emask_a |= SSL_aPSK;
        -: 2207:#endif
        -: 2208:
    #####: 2209:	c->mask_k=mask_k;
    #####: 2210:	c->mask_a=mask_a;
    #####: 2211:	c->export_mask_k=emask_k;
    #####: 2212:	c->export_mask_a=emask_a;
    #####: 2213:	c->valid=1;
        -: 2214:	}
        -: 2215:
        -: 2216:/* This handy macro borrowed from crypto/x509v3/v3_purp.c */
        -: 2217:#define ku_reject(x, usage) \
        -: 2218:	(((x)->ex_flags & EXFLAG_KUSAGE) && !((x)->ex_kusage & (usage)))
        -: 2219:
        -: 2220:#ifndef OPENSSL_NO_EC
        -: 2221:
    #####: 2222:int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)
        -: 2223:	{
        -: 2224:	unsigned long alg_k, alg_a;
        -: 2225:	EVP_PKEY *pkey = NULL;
        -: 2226:	int keysize = 0;
    #####: 2227:	int signature_nid = 0, md_nid = 0, pk_nid = 0;
    #####: 2228:	const SSL_CIPHER *cs = s->s3->tmp.new_cipher;
        -: 2229:
    #####: 2230:	alg_k = cs->algorithm_mkey;
    #####: 2231:	alg_a = cs->algorithm_auth;
        -: 2232:
    #####: 2233:	if (SSL_C_IS_EXPORT(cs))
        -: 2234:		{
        -: 2235:		/* ECDH key length in export ciphers must be <= 163 bits */
    #####: 2236:		pkey = X509_get_pubkey(x);
    #####: 2237:		if (pkey == NULL) return 0;
    #####: 2238:		keysize = EVP_PKEY_bits(pkey);
    #####: 2239:		EVP_PKEY_free(pkey);
    #####: 2240:		if (keysize > 163) return 0;
        -: 2241:		}
        -: 2242:
        -: 2243:	/* This call populates the ex_flags field correctly */
    #####: 2244:	X509_check_purpose(x, -1, 0);
    #####: 2245:	if ((x->sig_alg) && (x->sig_alg->algorithm))
        -: 2246:		{
    #####: 2247:		signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
    #####: 2248:		OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
        -: 2249:		}
    #####: 2250:	if (alg_k & SSL_kECDHe || alg_k & SSL_kECDHr)
        -: 2251:		{
        -: 2252:		/* key usage, if present, must allow key agreement */
    #####: 2253:		if (ku_reject(x, X509v3_KU_KEY_AGREEMENT))
        -: 2254:			{
    #####: 2255:			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT);
    #####: 2256:			return 0;
        -: 2257:			}
    #####: 2258:		if ((alg_k & SSL_kECDHe) && TLS1_get_version(s) < TLS1_2_VERSION)
        -: 2259:			{
        -: 2260:			/* signature alg must be ECDSA */
    #####: 2261:			if (pk_nid != NID_X9_62_id_ecPublicKey)
        -: 2262:				{
    #####: 2263:				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE);
    #####: 2264:				return 0;
        -: 2265:				}
        -: 2266:			}
    #####: 2267:		if ((alg_k & SSL_kECDHr) && TLS1_get_version(s) < TLS1_2_VERSION)
        -: 2268:			{
        -: 2269:			/* signature alg must be RSA */
        -: 2270:
    #####: 2271:			if (pk_nid != NID_rsaEncryption && pk_nid != NID_rsa)
        -: 2272:				{
    #####: 2273:				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE);
    #####: 2274:				return 0;
        -: 2275:				}
        -: 2276:			}
        -: 2277:		}
    #####: 2278:	if (alg_a & SSL_aECDSA)
        -: 2279:		{
        -: 2280:		/* key usage, if present, must allow signing */
    #####: 2281:		if (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))
        -: 2282:			{
    #####: 2283:			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_SIGNING);
    #####: 2284:			return 0;
        -: 2285:			}
        -: 2286:		}
        -: 2287:
        -: 2288:	return 1;  /* all checks are ok */
        -: 2289:	}
        -: 2290:
        -: 2291:#endif
        -: 2292:
        -: 2293:/* THIS NEEDS CLEANING UP */
    #####: 2294:CERT_PKEY *ssl_get_server_send_pkey(const SSL *s)
        -: 2295:	{
        -: 2296:	unsigned long alg_k,alg_a;
        -: 2297:	CERT *c;
        -: 2298:	int i;
        -: 2299:
    #####: 2300:	c=s->cert;
    #####: 2301:	ssl_set_cert_masks(c, s->s3->tmp.new_cipher);
        -: 2302:	
    #####: 2303:	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
    #####: 2304:	alg_a = s->s3->tmp.new_cipher->algorithm_auth;
        -: 2305:
    #####: 2306:	if (alg_k & (SSL_kECDHr|SSL_kECDHe))
        -: 2307:		{
        -: 2308:		/* we don't need to look at SSL_kEECDH
        -: 2309:		 * since no certificate is needed for
        -: 2310:		 * anon ECDH and for authenticated
        -: 2311:		 * EECDH, the check for the auth
        -: 2312:		 * algorithm will set i correctly
        -: 2313:		 * NOTE: For ECDH-RSA, we need an ECC
        -: 2314:		 * not an RSA cert but for EECDH-RSA
        -: 2315:		 * we need an RSA cert. Placing the
        -: 2316:		 * checks for SSL_kECDH before RSA
        -: 2317:		 * checks ensures the correct cert is chosen.
        -: 2318:		 */
        -: 2319:		i=SSL_PKEY_ECC;
        -: 2320:		}
    #####: 2321:	else if (alg_a & SSL_aECDSA)
        -: 2322:		{
        -: 2323:		i=SSL_PKEY_ECC;
        -: 2324:		}
    #####: 2325:	else if (alg_k & SSL_kDHr)
        -: 2326:		i=SSL_PKEY_DH_RSA;
    #####: 2327:	else if (alg_k & SSL_kDHd)
        -: 2328:		i=SSL_PKEY_DH_DSA;
    #####: 2329:	else if (alg_a & SSL_aDSS)
        -: 2330:		i=SSL_PKEY_DSA_SIGN;
    #####: 2331:	else if (alg_a & SSL_aRSA)
        -: 2332:		{
    #####: 2333:		if (c->pkeys[SSL_PKEY_RSA_ENC].x509 == NULL)
        -: 2334:			i=SSL_PKEY_RSA_SIGN;
        -: 2335:		else
        -: 2336:			i=SSL_PKEY_RSA_ENC;
        -: 2337:		}
    #####: 2338:	else if (alg_a & SSL_aKRB5)
        -: 2339:		{
        -: 2340:		/* VRS something else here? */
        -: 2341:		return(NULL);
        -: 2342:		}
    #####: 2343:	else if (alg_a & SSL_aGOST94) 
        -: 2344:		i=SSL_PKEY_GOST94;
    #####: 2345:	else if (alg_a & SSL_aGOST01)
        -: 2346:		i=SSL_PKEY_GOST01;
        -: 2347:	else /* if (alg_a & SSL_aNULL) */
        -: 2348:		{
    #####: 2349:		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY,ERR_R_INTERNAL_ERROR);
    #####: 2350:		return(NULL);
        -: 2351:		}
        -: 2352:
    #####: 2353:	return c->pkeys + i;
        -: 2354:	}
        -: 2355:
    #####: 2356:X509 *ssl_get_server_send_cert(const SSL *s)
        -: 2357:	{
        -: 2358:	CERT_PKEY *cpk;
    #####: 2359:	cpk = ssl_get_server_send_pkey(s);
    #####: 2360:	if (!cpk)
        -: 2361:		return NULL;
    #####: 2362:	return cpk->x509;
        -: 2363:	}
        -: 2364:
    #####: 2365:EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *cipher, const EVP_MD **pmd)
        -: 2366:	{
        -: 2367:	unsigned long alg_a;
        -: 2368:	CERT *c;
        -: 2369:	int idx = -1;
        -: 2370:
    #####: 2371:	alg_a = cipher->algorithm_auth;
    #####: 2372:	c=s->cert;
        -: 2373:
    #####: 2374:	if ((alg_a & SSL_aDSS) &&
    #####: 2375:		(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))
        -: 2376:		idx = SSL_PKEY_DSA_SIGN;
    #####: 2377:	else if (alg_a & SSL_aRSA)
        -: 2378:		{
    #####: 2379:		if (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)
        -: 2380:			idx = SSL_PKEY_RSA_SIGN;
    #####: 2381:		else if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)
        -: 2382:			idx = SSL_PKEY_RSA_ENC;
        -: 2383:		}
    #####: 2384:	else if ((alg_a & SSL_aECDSA) &&
    #####: 2385:	         (c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
        -: 2386:		idx = SSL_PKEY_ECC;
    #####: 2387:	if (idx == -1)
        -: 2388:		{
    #####: 2389:		SSLerr(SSL_F_SSL_GET_SIGN_PKEY,ERR_R_INTERNAL_ERROR);
    #####: 2390:		return(NULL);
        -: 2391:		}
    #####: 2392:	if (pmd)
    #####: 2393:		*pmd = c->pkeys[idx].digest;
    #####: 2394:	return c->pkeys[idx].privatekey;
        -: 2395:	}
        -: 2396:
    10000: 2397:void ssl_update_cache(SSL *s,int mode)
        -: 2398:	{
        -: 2399:	int i;
        -: 2400:
        -: 2401:	/* If the session_id_length is 0, we are not supposed to cache it,
        -: 2402:	 * and it would be rather hard to do anyway :-) */
    20000: 2403:	if (s->session->session_id_length == 0) return;
        -: 2404:
    10000: 2405:	i=s->session_ctx->session_cache_mode;
    10000: 2406:	if ((i & mode) && (!s->hit)
    #####: 2407:		&& ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)
    #####: 2408:		    || SSL_CTX_add_session(s->session_ctx,s->session))
    #####: 2409:		&& (s->session_ctx->new_session_cb != NULL))
        -: 2410:		{
    #####: 2411:		CRYPTO_add(&s->session->references,1,CRYPTO_LOCK_SSL_SESSION);
    #####: 2412:		if (!s->session_ctx->new_session_cb(s,s->session))
    #####: 2413:			SSL_SESSION_free(s->session);
        -: 2414:		}
        -: 2415:
        -: 2416:	/* auto flush every 255 connections */
    10000: 2417:	if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
        -: 2418:		((i & mode) == mode))
        -: 2419:		{
    #####: 2420:		if (  (((mode & SSL_SESS_CACHE_CLIENT)
    #####: 2421:			?s->session_ctx->stats.sess_connect_good
    #####: 2422:			:s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff)
        -: 2423:			{
    #####: 2424:			SSL_CTX_flush_sessions(s->session_ctx,(unsigned long)time(NULL));
        -: 2425:			}
        -: 2426:		}
        -: 2427:	}
        -: 2428:
    #####: 2429:const SSL_METHOD *SSL_get_ssl_method(SSL *s)
        -: 2430:	{
    #####: 2431:	return(s->method);
        -: 2432:	}
        -: 2433:
    #####: 2434:int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
        -: 2435:	{
        -: 2436:	int conn= -1;
        -: 2437:	int ret=1;
        -: 2438:
    #####: 2439:	if (s->method != meth)
        -: 2440:		{
    #####: 2441:		if (s->handshake_func != NULL)
    #####: 2442:			conn=(s->handshake_func == s->method->ssl_connect);
        -: 2443:
    #####: 2444:		if (s->method->version == meth->version)
    #####: 2445:			s->method=meth;
        -: 2446:		else
        -: 2447:			{
    #####: 2448:			s->method->ssl_free(s);
    #####: 2449:			s->method=meth;
    #####: 2450:			ret=s->method->ssl_new(s);
        -: 2451:			}
        -: 2452:
    #####: 2453:		if (conn == 1)
    #####: 2454:			s->handshake_func=meth->ssl_connect;
    #####: 2455:		else if (conn == 0)
    #####: 2456:			s->handshake_func=meth->ssl_accept;
        -: 2457:		}
    #####: 2458:	return(ret);
        -: 2459:	}
        -: 2460:
    20000: 2461:int SSL_get_error(const SSL *s,int i)
        -: 2462:	{
        -: 2463:	int reason;
        -: 2464:	unsigned long l;
        -: 2465:	BIO *bio;
        -: 2466:
    20000: 2467:	if (i > 0) return(SSL_ERROR_NONE);
        -: 2468:
        -: 2469:	/* Make things return SSL_ERROR_SYSCALL when doing SSL_do_handshake
        -: 2470:	 * etc, where we do encode the error */
    20000: 2471:	if ((l=ERR_peek_error()) != 0)
        -: 2472:		{
    #####: 2473:		if (ERR_GET_LIB(l) == ERR_LIB_SYS)
        -: 2474:			return(SSL_ERROR_SYSCALL);
        -: 2475:		else
    #####: 2476:			return(SSL_ERROR_SSL);
        -: 2477:		}
        -: 2478:
    20000: 2479:	if ((i < 0) && SSL_want_read(s))
        -: 2480:		{
        -: 2481:		bio=SSL_get_rbio(s);
    #####: 2482:		if (BIO_should_read(bio))
        -: 2483:			return(SSL_ERROR_WANT_READ);
    #####: 2484:		else if (BIO_should_write(bio))
        -: 2485:			/* This one doesn't make too much sense ... We never try
        -: 2486:			 * to write to the rbio, and an application program where
        -: 2487:			 * rbio and wbio are separate couldn't even know what it
        -: 2488:			 * should wait for.
        -: 2489:			 * However if we ever set s->rwstate incorrectly
        -: 2490:			 * (so that we have SSL_want_read(s) instead of
        -: 2491:			 * SSL_want_write(s)) and rbio and wbio *are* the same,
        -: 2492:			 * this test works around that bug; so it might be safer
        -: 2493:			 * to keep it. */
        -: 2494:			return(SSL_ERROR_WANT_WRITE);
    #####: 2495:		else if (BIO_should_io_special(bio))
        -: 2496:			{
    #####: 2497:			reason=BIO_get_retry_reason(bio);
    #####: 2498:			if (reason == BIO_RR_CONNECT)
        -: 2499:				return(SSL_ERROR_WANT_CONNECT);
    #####: 2500:			else if (reason == BIO_RR_ACCEPT)
        -: 2501:				return(SSL_ERROR_WANT_ACCEPT);
        -: 2502:			else
    #####: 2503:				return(SSL_ERROR_SYSCALL); /* unknown */
        -: 2504:			}
        -: 2505:		}
        -: 2506:
    20000: 2507:	if ((i < 0) && SSL_want_write(s))
        -: 2508:		{
        -: 2509:		bio=SSL_get_wbio(s);
    #####: 2510:		if (BIO_should_write(bio))
        -: 2511:			return(SSL_ERROR_WANT_WRITE);
    #####: 2512:		else if (BIO_should_read(bio))
        -: 2513:			/* See above (SSL_want_read(s) with BIO_should_write(bio)) */
        -: 2514:			return(SSL_ERROR_WANT_READ);
    #####: 2515:		else if (BIO_should_io_special(bio))
        -: 2516:			{
    #####: 2517:			reason=BIO_get_retry_reason(bio);
    #####: 2518:			if (reason == BIO_RR_CONNECT)
        -: 2519:				return(SSL_ERROR_WANT_CONNECT);
    #####: 2520:			else if (reason == BIO_RR_ACCEPT)
        -: 2521:				return(SSL_ERROR_WANT_ACCEPT);
        -: 2522:			else
    #####: 2523:				return(SSL_ERROR_SYSCALL);
        -: 2524:			}
        -: 2525:		}
    20000: 2526:	if ((i < 0) && SSL_want_x509_lookup(s))
        -: 2527:		{
        -: 2528:		return(SSL_ERROR_WANT_X509_LOOKUP);
        -: 2529:		}
        -: 2530:
    20000: 2531:	if (i == 0)
        -: 2532:		{
    20000: 2533:		if (s->version == SSL2_VERSION)
        -: 2534:			{
        -: 2535:			/* assume it is the socket being closed */
        -: 2536:			return(SSL_ERROR_ZERO_RETURN);
        -: 2537:			}
        -: 2538:		else
        -: 2539:			{
    20000: 2540:			if ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&
    #####: 2541:				(s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))
        -: 2542:				return(SSL_ERROR_ZERO_RETURN);
        -: 2543:			}
        -: 2544:		}
    20000: 2545:	return(SSL_ERROR_SYSCALL);
        -: 2546:	}
        -: 2547:
    #####: 2548:int SSL_do_handshake(SSL *s)
        -: 2549:	{
        -: 2550:	int ret=1;
        -: 2551:
    #####: 2552:	if (s->handshake_func == NULL)
        -: 2553:		{
    #####: 2554:		SSLerr(SSL_F_SSL_DO_HANDSHAKE,SSL_R_CONNECTION_TYPE_NOT_SET);
    #####: 2555:		return(-1);
        -: 2556:		}
        -: 2557:
    #####: 2558:	s->method->ssl_renegotiate_check(s);
        -: 2559:
    #####: 2560:	if (SSL_in_init(s) || SSL_in_before(s))
        -: 2561:		{
    #####: 2562:		ret=s->handshake_func(s);
        -: 2563:		}
    #####: 2564:	return(ret);
        -: 2565:	}
        -: 2566:
        -: 2567:/* For the next 2 functions, SSL_clear() sets shutdown and so
        -: 2568: * one of these calls will reset it */
    #####: 2569:void SSL_set_accept_state(SSL *s)
        -: 2570:	{
    #####: 2571:	s->server=1;
    #####: 2572:	s->shutdown=0;
    #####: 2573:	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
    #####: 2574:	s->handshake_func=s->method->ssl_accept;
        -: 2575:	/* clear the current cipher */
    #####: 2576:	ssl_clear_cipher_ctx(s);
        -: 2577:	ssl_clear_hash_ctx(&s->read_hash);
        -: 2578:	ssl_clear_hash_ctx(&s->write_hash);
    #####: 2579:	}
        -: 2580:
    10000: 2581:void SSL_set_connect_state(SSL *s)
        -: 2582:	{
    10000: 2583:	s->server=0;
    10000: 2584:	s->shutdown=0;
    10000: 2585:	s->state=SSL_ST_CONNECT|SSL_ST_BEFORE;
    10000: 2586:	s->handshake_func=s->method->ssl_connect;
        -: 2587:	/* clear the current cipher */
    10000: 2588:	ssl_clear_cipher_ctx(s);
        -: 2589:	ssl_clear_hash_ctx(&s->read_hash);
        -: 2590:	ssl_clear_hash_ctx(&s->write_hash);
    10000: 2591:	}
        -: 2592:
    #####: 2593:int ssl_undefined_function(SSL *s)
        -: 2594:	{
    #####: 2595:	SSLerr(SSL_F_SSL_UNDEFINED_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
    #####: 2596:	return(0);
        -: 2597:	}
        -: 2598:
    #####: 2599:int ssl_undefined_void_function(void)
        -: 2600:	{
    #####: 2601:	SSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
    #####: 2602:	return(0);
        -: 2603:	}
        -: 2604:
    10000: 2605:int ssl_undefined_const_function(const SSL *s)
        -: 2606:	{
    10000: 2607:	SSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
    10000: 2608:	return(0);
        -: 2609:	}
        -: 2610:
    #####: 2611:SSL_METHOD *ssl_bad_method(int ver)
        -: 2612:	{
    #####: 2613:	SSLerr(SSL_F_SSL_BAD_METHOD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
    #####: 2614:	return(NULL);
        -: 2615:	}
        -: 2616:
    #####: 2617:const char *SSL_get_version(const SSL *s)
        -: 2618:	{
    #####: 2619:	if (s->version == TLS1_2_VERSION)
        -: 2620:		return("TLSv1.2");
    #####: 2621:	else if (s->version == TLS1_1_VERSION)
        -: 2622:		return("TLSv1.1");
    #####: 2623:	else if (s->version == TLS1_VERSION)
        -: 2624:		return("TLSv1");
    #####: 2625:	else if (s->version == SSL3_VERSION)
        -: 2626:		return("SSLv3");
    #####: 2627:	else if (s->version == SSL2_VERSION)
        -: 2628:		return("SSLv2");
        -: 2629:	else
    #####: 2630:		return("unknown");
        -: 2631:	}
        -: 2632:
    #####: 2633:SSL *SSL_dup(SSL *s)
        -: 2634:	{
        -: 2635:	STACK_OF(X509_NAME) *sk;
        -: 2636:	X509_NAME *xn;
        -: 2637:	SSL *ret;
        -: 2638:	int i;
        -: 2639:	
    #####: 2640:	if ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL)
        -: 2641:	    return(NULL);
        -: 2642:
    #####: 2643:	ret->version = s->version;
    #####: 2644:	ret->type = s->type;
    #####: 2645:	ret->method = s->method;
        -: 2646:
    #####: 2647:	if (s->session != NULL)
        -: 2648:		{
        -: 2649:		/* This copies session-id, SSL_METHOD, sid_ctx, and 'cert' */
    #####: 2650:		SSL_copy_session_id(ret,s);
        -: 2651:		}
        -: 2652:	else
        -: 2653:		{
        -: 2654:		/* No session has been established yet, so we have to expect
        -: 2655:		 * that s->cert or ret->cert will be changed later --
        -: 2656:		 * they should not both point to the same object,
        -: 2657:		 * and thus we can't use SSL_copy_session_id. */
        -: 2658:
    #####: 2659:		ret->method->ssl_free(ret);
    #####: 2660:		ret->method = s->method;
    #####: 2661:		ret->method->ssl_new(ret);
        -: 2662:
    #####: 2663:		if (s->cert != NULL)
        -: 2664:			{
    #####: 2665:			if (ret->cert != NULL)
        -: 2666:				{
    #####: 2667:				ssl_cert_free(ret->cert);
        -: 2668:				}
    #####: 2669:			ret->cert = ssl_cert_dup(s->cert);
    #####: 2670:			if (ret->cert == NULL)
        -: 2671:				goto err;
        -: 2672:			}
        -: 2673:				
    #####: 2674:		SSL_set_session_id_context(ret,
    #####: 2675:			s->sid_ctx, s->sid_ctx_length);
        -: 2676:		}
        -: 2677:
    #####: 2678:	ret->options=s->options;
    #####: 2679:	ret->mode=s->mode;
    #####: 2680:	SSL_set_max_cert_list(ret,SSL_get_max_cert_list(s));
        -: 2681:	SSL_set_read_ahead(ret,SSL_get_read_ahead(s));
    #####: 2682:	ret->msg_callback = s->msg_callback;
    #####: 2683:	ret->msg_callback_arg = s->msg_callback_arg;
        -: 2684:	SSL_set_verify(ret,SSL_get_verify_mode(s),
        -: 2685:		SSL_get_verify_callback(s));
        -: 2686:	SSL_set_verify_depth(ret,SSL_get_verify_depth(s));
    #####: 2687:	ret->generate_session_id = s->generate_session_id;
        -: 2688:
        -: 2689:	SSL_set_info_callback(ret,SSL_get_info_callback(s));
        -: 2690:	
    #####: 2691:	ret->debug=s->debug;
        -: 2692:
        -: 2693:	/* copy app data, a little dangerous perhaps */
    #####: 2694:	if (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL, &ret->ex_data, &s->ex_data))
        -: 2695:		goto err;
        -: 2696:
        -: 2697:	/* setup rbio, and wbio */
    #####: 2698:	if (s->rbio != NULL)
        -: 2699:		{
    #####: 2700:		if (!BIO_dup_state(s->rbio,(char *)&ret->rbio))
        -: 2701:			goto err;
        -: 2702:		}
    #####: 2703:	if (s->wbio != NULL)
        -: 2704:		{
    #####: 2705:		if (s->wbio != s->rbio)
        -: 2706:			{
    #####: 2707:			if (!BIO_dup_state(s->wbio,(char *)&ret->wbio))
        -: 2708:				goto err;
        -: 2709:			}
        -: 2710:		else
    #####: 2711:			ret->wbio=ret->rbio;
        -: 2712:		}
    #####: 2713:	ret->rwstate = s->rwstate;
    #####: 2714:	ret->in_handshake = s->in_handshake;
    #####: 2715:	ret->handshake_func = s->handshake_func;
    #####: 2716:	ret->server = s->server;
    #####: 2717:	ret->renegotiate = s->renegotiate;
    #####: 2718:	ret->new_session = s->new_session;
    #####: 2719:	ret->quiet_shutdown = s->quiet_shutdown;
    #####: 2720:	ret->shutdown=s->shutdown;
    #####: 2721:	ret->state=s->state; /* SSL_dup does not really work at any state, though */
    #####: 2722:	ret->rstate=s->rstate;
    #####: 2723:	ret->init_num = 0; /* would have to copy ret->init_buf, ret->init_msg, ret->init_num, ret->init_off */
    #####: 2724:	ret->hit=s->hit;
        -: 2725:
    #####: 2726:	X509_VERIFY_PARAM_inherit(ret->param, s->param);
        -: 2727:
        -: 2728:	/* dup the cipher_list and cipher_list_by_id stacks */
    #####: 2729:	if (s->cipher_list != NULL)
        -: 2730:		{
    #####: 2731:		if ((ret->cipher_list=sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)
        -: 2732:			goto err;
        -: 2733:		}
    #####: 2734:	if (s->cipher_list_by_id != NULL)
    #####: 2735:		if ((ret->cipher_list_by_id=sk_SSL_CIPHER_dup(s->cipher_list_by_id))
        -: 2736:			== NULL)
        -: 2737:			goto err;
        -: 2738:
        -: 2739:	/* Dup the client_CA list */
    #####: 2740:	if (s->client_CA != NULL)
        -: 2741:		{
    #####: 2742:		if ((sk=sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;
    #####: 2743:		ret->client_CA=sk;
    #####: 2744:		for (i=0; i<sk_X509_NAME_num(sk); i++)
        -: 2745:			{
    #####: 2746:			xn=sk_X509_NAME_value(sk,i);
    #####: 2747:			if (sk_X509_NAME_set(sk,i,X509_NAME_dup(xn)) == NULL)
        -: 2748:				{
    #####: 2749:				X509_NAME_free(xn);
    #####: 2750:				goto err;
        -: 2751:				}
        -: 2752:			}
        -: 2753:		}
        -: 2754:
        -: 2755:	if (0)
        -: 2756:		{
        -: 2757:err:
    #####: 2758:		if (ret != NULL) SSL_free(ret);
        -: 2759:		ret=NULL;
        -: 2760:		}
    #####: 2761:	return(ret);
        -: 2762:	}
        -: 2763:
    40000: 2764:void ssl_clear_cipher_ctx(SSL *s)
        -: 2765:	{
    40000: 2766:	if (s->enc_read_ctx != NULL)
        -: 2767:		{
    10000: 2768:		EVP_CIPHER_CTX_cleanup(s->enc_read_ctx);
    10000: 2769:		OPENSSL_free(s->enc_read_ctx);
    10000: 2770:		s->enc_read_ctx=NULL;
        -: 2771:		}
    40000: 2772:	if (s->enc_write_ctx != NULL)
        -: 2773:		{
    10000: 2774:		EVP_CIPHER_CTX_cleanup(s->enc_write_ctx);
    10000: 2775:		OPENSSL_free(s->enc_write_ctx);
    10000: 2776:		s->enc_write_ctx=NULL;
        -: 2777:		}
        -: 2778:#ifndef OPENSSL_NO_COMP
    40000: 2779:	if (s->expand != NULL)
        -: 2780:		{
    #####: 2781:		COMP_CTX_free(s->expand);
    #####: 2782:		s->expand=NULL;
        -: 2783:		}
    40000: 2784:	if (s->compress != NULL)
        -: 2785:		{
    #####: 2786:		COMP_CTX_free(s->compress);
    #####: 2787:		s->compress=NULL;
        -: 2788:		}
        -: 2789:#endif
    40000: 2790:	}
        -: 2791:
        -: 2792:/* Fix this function so that it takes an optional type parameter */
    #####: 2793:X509 *SSL_get_certificate(const SSL *s)
        -: 2794:	{
    #####: 2795:	if (s->server)
    #####: 2796:		return(ssl_get_server_send_cert(s));
    #####: 2797:	else if (s->cert != NULL)
    #####: 2798:		return(s->cert->key->x509);
        -: 2799:	else
        -: 2800:		return(NULL);
        -: 2801:	}
        -: 2802:
        -: 2803:/* Fix this function so that it takes an optional type parameter */
    #####: 2804:EVP_PKEY *SSL_get_privatekey(SSL *s)
        -: 2805:	{
    #####: 2806:	if (s->cert != NULL)
    #####: 2807:		return(s->cert->key->privatekey);
        -: 2808:	else
        -: 2809:		return(NULL);
        -: 2810:	}
        -: 2811:
    10000: 2812:const SSL_CIPHER *SSL_get_current_cipher(const SSL *s)
        -: 2813:	{
    10000: 2814:	if ((s->session != NULL) && (s->session->cipher != NULL))
    10000: 2815:		return(s->session->cipher);
        -: 2816:	return(NULL);
        -: 2817:	}
        -: 2818:#ifdef OPENSSL_NO_COMP
        -: 2819:const void *SSL_get_current_compression(SSL *s)
        -: 2820:	{
        -: 2821:	return NULL;
        -: 2822:	}
        -: 2823:const void *SSL_get_current_expansion(SSL *s)
        -: 2824:	{
        -: 2825:	return NULL;
        -: 2826:	}
        -: 2827:#else
        -: 2828:
    10000: 2829:const COMP_METHOD *SSL_get_current_compression(SSL *s)
        -: 2830:	{
    10000: 2831:	if (s->compress != NULL)
    #####: 2832:		return(s->compress->meth);
        -: 2833:	return(NULL);
        -: 2834:	}
        -: 2835:
    10000: 2836:const COMP_METHOD *SSL_get_current_expansion(SSL *s)
        -: 2837:	{
    10000: 2838:	if (s->expand != NULL)
    #####: 2839:		return(s->expand->meth);
        -: 2840:	return(NULL);
        -: 2841:	}
        -: 2842:#endif
        -: 2843:
    10000: 2844:int ssl_init_wbio_buffer(SSL *s,int push)
        -: 2845:	{
        -: 2846:	BIO *bbio;
        -: 2847:
    10000: 2848:	if (s->bbio == NULL)
        -: 2849:		{
    10000: 2850:		bbio=BIO_new(BIO_f_buffer());
    10000: 2851:		if (bbio == NULL) return(0);
    10000: 2852:		s->bbio=bbio;
        -: 2853:		}
        -: 2854:	else
        -: 2855:		{
        -: 2856:		bbio=s->bbio;
    #####: 2857:		if (s->bbio == s->wbio)
    #####: 2858:			s->wbio=BIO_pop(s->wbio);
        -: 2859:		}
    10000: 2860:	(void)BIO_reset(bbio);
        -: 2861:/*	if (!BIO_set_write_buffer_size(bbio,16*1024)) */
    10000: 2862:	if (!BIO_set_read_buffer_size(bbio,1))
        -: 2863:		{
    #####: 2864:		SSLerr(SSL_F_SSL_INIT_WBIO_BUFFER,ERR_R_BUF_LIB);
    #####: 2865:		return(0);
        -: 2866:		}
    10000: 2867:	if (push)
        -: 2868:		{
    10000: 2869:		if (s->wbio != bbio)
    10000: 2870:			s->wbio=BIO_push(bbio,s->wbio);
        -: 2871:		}
        -: 2872:	else
        -: 2873:		{
    #####: 2874:		if (s->wbio == bbio)
    #####: 2875:			s->wbio=BIO_pop(bbio);
        -: 2876:		}
        -: 2877:	return(1);
        -: 2878:	}
        -: 2879:
    50000: 2880:void ssl_free_wbio_buffer(SSL *s)
        -: 2881:	{
   100000: 2882:	if (s->bbio == NULL) return;
        -: 2883:
    10000: 2884:	if (s->bbio == s->wbio)
        -: 2885:		{
        -: 2886:		/* remove buffering */
    10000: 2887:		s->wbio=BIO_pop(s->wbio);
        -: 2888:#ifdef REF_CHECK /* not the usual REF_CHECK, but this avoids adding one more preprocessor symbol */
        -: 2889:		assert(s->wbio != NULL);
        -: 2890:#endif
        -: 2891:	}
    10000: 2892:	BIO_free(s->bbio);
    10000: 2893:	s->bbio=NULL;
        -: 2894:	}
        -: 2895:	
    #####: 2896:void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode)
        -: 2897:	{
    #####: 2898:	ctx->quiet_shutdown=mode;
    #####: 2899:	}
        -: 2900:
    #####: 2901:int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)
        -: 2902:	{
    #####: 2903:	return(ctx->quiet_shutdown);
        -: 2904:	}
        -: 2905:
    #####: 2906:void SSL_set_quiet_shutdown(SSL *s,int mode)
        -: 2907:	{
    #####: 2908:	s->quiet_shutdown=mode;
    #####: 2909:	}
        -: 2910:
    #####: 2911:int SSL_get_quiet_shutdown(const SSL *s)
        -: 2912:	{
    #####: 2913:	return(s->quiet_shutdown);
        -: 2914:	}
        -: 2915:
    #####: 2916:void SSL_set_shutdown(SSL *s,int mode)
        -: 2917:	{
    #####: 2918:	s->shutdown=mode;
    #####: 2919:	}
        -: 2920:
    #####: 2921:int SSL_get_shutdown(const SSL *s)
        -: 2922:	{
    #####: 2923:	return(s->shutdown);
        -: 2924:	}
        -: 2925:
   590000: 2926:int SSL_version(const SSL *s)
        -: 2927:	{
   590000: 2928:	return(s->version);
        -: 2929:	}
        -: 2930:
    #####: 2931:SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl)
        -: 2932:	{
    #####: 2933:	return(ssl->ctx);
        -: 2934:	}
        -: 2935:
    #####: 2936:SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx)
        -: 2937:	{
    #####: 2938:	if (ssl->ctx == ctx)
        -: 2939:		return ssl->ctx;
        -: 2940:#ifndef OPENSSL_NO_TLSEXT
    #####: 2941:	if (ctx == NULL)
    #####: 2942:		ctx = ssl->initial_ctx;
        -: 2943:#endif
    #####: 2944:	if (ssl->cert != NULL)
    #####: 2945:		ssl_cert_free(ssl->cert);
    #####: 2946:	ssl->cert = ssl_cert_dup(ctx->cert);
    #####: 2947:	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
    #####: 2948:	if (ssl->ctx != NULL)
    #####: 2949:		SSL_CTX_free(ssl->ctx); /* decrement reference count */
    #####: 2950:	ssl->ctx = ctx;
    #####: 2951:	return(ssl->ctx);
        -: 2952:	}
        -: 2953:
        -: 2954:#ifndef OPENSSL_NO_STDIO
    10000: 2955:int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)
        -: 2956:	{
    10000: 2957:	return(X509_STORE_set_default_paths(ctx->cert_store));
        -: 2958:	}
        -: 2959:
    10000: 2960:int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
        -: 2961:		const char *CApath)
        -: 2962:	{
    10000: 2963:	return(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));
        -: 2964:	}
        -: 2965:#endif
        -: 2966:
    #####: 2967:void SSL_set_info_callback(SSL *ssl,
        -: 2968:	void (*cb)(const SSL *ssl,int type,int val))
        -: 2969:	{
    #####: 2970:	ssl->info_callback=cb;
    #####: 2971:	}
        -: 2972:
        -: 2973:/* One compiler (Diab DCC) doesn't like argument names in returned
        -: 2974:   function pointer.  */
    #####: 2975:void (*SSL_get_info_callback(const SSL *ssl))(const SSL * /*ssl*/,int /*type*/,int /*val*/)
        -: 2976:	{
    #####: 2977:	return ssl->info_callback;
        -: 2978:	}
        -: 2979:
   210000: 2980:int SSL_state(const SSL *ssl)
        -: 2981:	{
   220000: 2982:	return(ssl->state);
        -: 2983:	}
        -: 2984:
    #####: 2985:void SSL_set_state(SSL *ssl, int state)
        -: 2986:	{
    #####: 2987:	ssl->state = state;
    #####: 2988:	}
        -: 2989:
    #####: 2990:void SSL_set_verify_result(SSL *ssl,long arg)
        -: 2991:	{
    #####: 2992:	ssl->verify_result=arg;
    #####: 2993:	}
        -: 2994:
    #####: 2995:long SSL_get_verify_result(const SSL *ssl)
        -: 2996:	{
    #####: 2997:	return(ssl->verify_result);
        -: 2998:	}
        -: 2999:
    #####: 3000:int SSL_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
        -: 3001:			 CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
        -: 3002:	{
    #####: 3003:	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
        -: 3004:				new_func, dup_func, free_func);
        -: 3005:	}
        -: 3006:
    #####: 3007:int SSL_set_ex_data(SSL *s,int idx,void *arg)
        -: 3008:	{
    #####: 3009:	return(CRYPTO_set_ex_data(&s->ex_data,idx,arg));
        -: 3010:	}
        -: 3011:
    #####: 3012:void *SSL_get_ex_data(const SSL *s,int idx)
        -: 3013:	{
    #####: 3014:	return(CRYPTO_get_ex_data(&s->ex_data,idx));
        -: 3015:	}
        -: 3016:
    #####: 3017:int SSL_CTX_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
        -: 3018:			     CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
        -: 3019:	{
    #####: 3020:	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,
        -: 3021:				new_func, dup_func, free_func);
        -: 3022:	}
        -: 3023:
    #####: 3024:int SSL_CTX_set_ex_data(SSL_CTX *s,int idx,void *arg)
        -: 3025:	{
    #####: 3026:	return(CRYPTO_set_ex_data(&s->ex_data,idx,arg));
        -: 3027:	}
        -: 3028:
    #####: 3029:void *SSL_CTX_get_ex_data(const SSL_CTX *s,int idx)
        -: 3030:	{
    #####: 3031:	return(CRYPTO_get_ex_data(&s->ex_data,idx));
        -: 3032:	}
        -: 3033:
    #####: 3034:int ssl_ok(SSL *s)
        -: 3035:	{
    #####: 3036:	return(1);
        -: 3037:	}
        -: 3038:
    #####: 3039:X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx)
        -: 3040:	{
    #####: 3041:	return(ctx->cert_store);
        -: 3042:	}
        -: 3043:
    #####: 3044:void SSL_CTX_set_cert_store(SSL_CTX *ctx,X509_STORE *store)
        -: 3045:	{
    #####: 3046:	if (ctx->cert_store != NULL)
    #####: 3047:		X509_STORE_free(ctx->cert_store);
    #####: 3048:	ctx->cert_store=store;
    #####: 3049:	}
        -: 3050:
    #####: 3051:int SSL_want(const SSL *s)
        -: 3052:	{
    #####: 3053:	return(s->rwstate);
        -: 3054:	}
        -: 3055:
        -: 3056:/*!
        -: 3057: * \brief Set the callback for generating temporary RSA keys.
        -: 3058: * \param ctx the SSL context.
        -: 3059: * \param cb the callback
        -: 3060: */
        -: 3061:
        -: 3062:#ifndef OPENSSL_NO_RSA
    #####: 3063:void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,RSA *(*cb)(SSL *ssl,
        -: 3064:							  int is_export,
        -: 3065:							  int keylength))
        -: 3066:    {
        -: 3067:    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
    #####: 3068:    }
        -: 3069:
    #####: 3070:void SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,
        -: 3071:						  int is_export,
        -: 3072:						  int keylength))
        -: 3073:    {
        -: 3074:    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
    #####: 3075:    }
        -: 3076:#endif
        -: 3077:
        -: 3078:#ifdef DOXYGEN
        -: 3079:/*!
        -: 3080: * \brief The RSA temporary key callback function.
        -: 3081: * \param ssl the SSL session.
        -: 3082: * \param is_export \c TRUE if the temp RSA key is for an export ciphersuite.
        -: 3083: * \param keylength if \c is_export is \c TRUE, then \c keylength is the size
        -: 3084: * of the required key in bits.
        -: 3085: * \return the temporary RSA key.
        -: 3086: * \sa SSL_CTX_set_tmp_rsa_callback, SSL_set_tmp_rsa_callback
        -: 3087: */
        -: 3088:
        -: 3089:RSA *cb(SSL *ssl,int is_export,int keylength)
        -: 3090:    {}
        -: 3091:#endif
        -: 3092:
        -: 3093:/*!
        -: 3094: * \brief Set the callback for generating temporary DH keys.
        -: 3095: * \param ctx the SSL context.
        -: 3096: * \param dh the callback
        -: 3097: */
        -: 3098:
        -: 3099:#ifndef OPENSSL_NO_DH
    #####: 3100:void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,DH *(*dh)(SSL *ssl,int is_export,
        -: 3101:                                                        int keylength))
        -: 3102:	{
        -: 3103:	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
    #####: 3104:	}
        -: 3105:
    #####: 3106:void SSL_set_tmp_dh_callback(SSL *ssl,DH *(*dh)(SSL *ssl,int is_export,
        -: 3107:                                                int keylength))
        -: 3108:	{
        -: 3109:	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
    #####: 3110:	}
        -: 3111:#endif
        -: 3112:
        -: 3113:#ifndef OPENSSL_NO_ECDH
    #####: 3114:void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
        -: 3115:                                                                int keylength))
        -: 3116:	{
        -: 3117:	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
    #####: 3118:	}
        -: 3119:
    #####: 3120:void SSL_set_tmp_ecdh_callback(SSL *ssl,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
        -: 3121:                                                        int keylength))
        -: 3122:	{
        -: 3123:	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
    #####: 3124:	}
        -: 3125:#endif
        -: 3126:
        -: 3127:#ifndef OPENSSL_NO_PSK
    #####: 3128:int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint)
        -: 3129:	{
    #####: 3130:	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
        -: 3131:		{
    #####: 3132:		SSLerr(SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
    #####: 3133:		return 0;
        -: 3134:		}
    #####: 3135:	if (ctx->psk_identity_hint != NULL)
    #####: 3136:		OPENSSL_free(ctx->psk_identity_hint);
    #####: 3137:	if (identity_hint != NULL)
        -: 3138:		{
    #####: 3139:		ctx->psk_identity_hint = BUF_strdup(identity_hint);
    #####: 3140:		if (ctx->psk_identity_hint == NULL)
        -: 3141:			return 0;
        -: 3142:		}
        -: 3143:	else
    #####: 3144:		ctx->psk_identity_hint = NULL;
        -: 3145:	return 1;
        -: 3146:	}
        -: 3147:
    #####: 3148:int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint)
        -: 3149:	{
    #####: 3150:	if (s == NULL)
        -: 3151:		return 0;
        -: 3152:
    #####: 3153:	if (s->session == NULL)
        -: 3154:		return 1; /* session not created yet, ignored */
        -: 3155:
    #####: 3156:	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
        -: 3157:		{
    #####: 3158:		SSLerr(SSL_F_SSL_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
    #####: 3159:		return 0;
        -: 3160:		}
    #####: 3161:	if (s->session->psk_identity_hint != NULL)
    #####: 3162:		OPENSSL_free(s->session->psk_identity_hint);
    #####: 3163:	if (identity_hint != NULL)
        -: 3164:		{
    #####: 3165:		s->session->psk_identity_hint = BUF_strdup(identity_hint);
    #####: 3166:		if (s->session->psk_identity_hint == NULL)
        -: 3167:			return 0;
        -: 3168:		}
        -: 3169:	else
    #####: 3170:		s->session->psk_identity_hint = NULL;
        -: 3171:	return 1;
        -: 3172:	}
        -: 3173:
    #####: 3174:const char *SSL_get_psk_identity_hint(const SSL *s)
        -: 3175:	{
    #####: 3176:	if (s == NULL || s->session == NULL)
        -: 3177:		return NULL;
    #####: 3178:	return(s->session->psk_identity_hint);
        -: 3179:	}
        -: 3180:
    #####: 3181:const char *SSL_get_psk_identity(const SSL *s)
        -: 3182:	{
    #####: 3183:	if (s == NULL || s->session == NULL)
        -: 3184:		return NULL;
    #####: 3185:	return(s->session->psk_identity);
        -: 3186:	}
        -: 3187:
    #####: 3188:void SSL_set_psk_client_callback(SSL *s,
        -: 3189:    unsigned int (*cb)(SSL *ssl, const char *hint,
        -: 3190:                       char *identity, unsigned int max_identity_len, unsigned char *psk,
        -: 3191:                       unsigned int max_psk_len))
        -: 3192:	{
    #####: 3193:	s->psk_client_callback = cb;
    #####: 3194:	}
        -: 3195:
    #####: 3196:void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,
        -: 3197:    unsigned int (*cb)(SSL *ssl, const char *hint,
        -: 3198:                       char *identity, unsigned int max_identity_len, unsigned char *psk,
        -: 3199:                       unsigned int max_psk_len))
        -: 3200:	{
    #####: 3201:	ctx->psk_client_callback = cb;
    #####: 3202:	}
        -: 3203:
    #####: 3204:void SSL_set_psk_server_callback(SSL *s,
        -: 3205:    unsigned int (*cb)(SSL *ssl, const char *identity,
        -: 3206:                       unsigned char *psk, unsigned int max_psk_len))
        -: 3207:	{
    #####: 3208:	s->psk_server_callback = cb;
    #####: 3209:	}
        -: 3210:
    #####: 3211:void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
        -: 3212:    unsigned int (*cb)(SSL *ssl, const char *identity,
        -: 3213:                       unsigned char *psk, unsigned int max_psk_len))
        -: 3214:	{
    #####: 3215:	ctx->psk_server_callback = cb;
    #####: 3216:	}
        -: 3217:#endif
        -: 3218:
    #####: 3219:void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
        -: 3220:	{
        -: 3221:	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
    #####: 3222:	}
    #####: 3223:void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
        -: 3224:	{
        -: 3225:	SSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
    #####: 3226:	}
        -: 3227:
        -: 3228:/* Allocates new EVP_MD_CTX and sets pointer to it into given pointer
        -: 3229: * vairable, freeing  EVP_MD_CTX previously stored in that variable, if
        -: 3230: * any. If EVP_MD pointer is passed, initializes ctx with this md
        -: 3231: * Returns newly allocated ctx;
        -: 3232: */
        -: 3233:
    20000: 3234:EVP_MD_CTX *ssl_replace_hash(EVP_MD_CTX **hash,const EVP_MD *md) 
        -: 3235:{
        -: 3236:	ssl_clear_hash_ctx(hash);
    20000: 3237:	*hash = EVP_MD_CTX_create();
    20000: 3238:	if (md) EVP_DigestInit_ex(*hash,md,NULL);
    20000: 3239:	return *hash;
        -: 3240:}
    #####: 3241:void ssl_clear_hash_ctx(EVP_MD_CTX **hash) 
        -: 3242:{
        -: 3243:
   100000: 3244:	if (*hash) EVP_MD_CTX_destroy(*hash);
   100000: 3245:	*hash=NULL;
    #####: 3246:}
        -: 3247:
    #####: 3248:void SSL_set_debug(SSL *s, int debug)
        -: 3249:	{
    #####: 3250:	s->debug = debug;
    #####: 3251:	}
        -: 3252:
    10000: 3253:int SSL_cache_hit(SSL *s)
        -: 3254:	{
    10000: 3255:	return s->hit;
        -: 3256:	}
        -: 3257:
        -: 3258:#if defined(_WINDLL) && defined(OPENSSL_SYS_WIN16)
        -: 3259:#include "../crypto/bio/bss_file.c"
        -: 3260:#endif
        -: 3261:
        -: 3262:IMPLEMENT_STACK_OF(SSL_CIPHER)
        -: 3263:IMPLEMENT_STACK_OF(SSL_COMP)
    90000: 3264:IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER,
        -: 3265:				    ssl_cipher_id);
