        -:    0:Source:s_server.c
        -:    0:Graph:s_server.gcno
        -:    0:Data:s_server.gcda
        -:    0:Runs:10000
        -:    0:Programs:1
        -:    1:/* apps/s_server.c */
        -:    2:/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
        -:    3: * All rights reserved.
        -:    4: *
        -:    5: * This package is an SSL implementation written
        -:    6: * by Eric Young (eay@cryptsoft.com).
        -:    7: * The implementation was written so as to conform with Netscapes SSL.
        -:    8: * 
        -:    9: * This library is free for commercial and non-commercial use as long as
        -:   10: * the following conditions are aheared to.  The following conditions
        -:   11: * apply to all code found in this distribution, be it the RC4, RSA,
        -:   12: * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
        -:   13: * included with this distribution is covered by the same copyright terms
        -:   14: * except that the holder is Tim Hudson (tjh@cryptsoft.com).
        -:   15: * 
        -:   16: * Copyright remains Eric Young's, and as such any Copyright notices in
        -:   17: * the code are not to be removed.
        -:   18: * If this package is used in a product, Eric Young should be given attribution
        -:   19: * as the author of the parts of the library used.
        -:   20: * This can be in the form of a textual message at program startup or
        -:   21: * in documentation (online or textual) provided with the package.
        -:   22: * 
        -:   23: * Redistribution and use in source and binary forms, with or without
        -:   24: * modification, are permitted provided that the following conditions
        -:   25: * are met:
        -:   26: * 1. Redistributions of source code must retain the copyright
        -:   27: *    notice, this list of conditions and the following disclaimer.
        -:   28: * 2. Redistributions in binary form must reproduce the above copyright
        -:   29: *    notice, this list of conditions and the following disclaimer in the
        -:   30: *    documentation and/or other materials provided with the distribution.
        -:   31: * 3. All advertising materials mentioning features or use of this software
        -:   32: *    must display the following acknowledgement:
        -:   33: *    "This product includes cryptographic software written by
        -:   34: *     Eric Young (eay@cryptsoft.com)"
        -:   35: *    The word 'cryptographic' can be left out if the rouines from the library
        -:   36: *    being used are not cryptographic related :-).
        -:   37: * 4. If you include any Windows specific code (or a derivative thereof) from 
        -:   38: *    the apps directory (application code) you must include an acknowledgement:
        -:   39: *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
        -:   40: * 
        -:   41: * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
        -:   42: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   43: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   44: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        -:   45: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   46: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   47: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   48: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   49: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   50: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   51: * SUCH DAMAGE.
        -:   52: * 
        -:   53: * The licence and distribution terms for any publically available version or
        -:   54: * derivative of this code cannot be changed.  i.e. this code cannot simply be
        -:   55: * copied and put under another distribution licence
        -:   56: * [including the GNU Public Licence.]
        -:   57: */
        -:   58:/* ====================================================================
        -:   59: * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
        -:   60: *
        -:   61: * Redistribution and use in source and binary forms, with or without
        -:   62: * modification, are permitted provided that the following conditions
        -:   63: * are met:
        -:   64: *
        -:   65: * 1. Redistributions of source code must retain the above copyright
        -:   66: *    notice, this list of conditions and the following disclaimer. 
        -:   67: *
        -:   68: * 2. Redistributions in binary form must reproduce the above copyright
        -:   69: *    notice, this list of conditions and the following disclaimer in
        -:   70: *    the documentation and/or other materials provided with the
        -:   71: *    distribution.
        -:   72: *
        -:   73: * 3. All advertising materials mentioning features or use of this
        -:   74: *    software must display the following acknowledgment:
        -:   75: *    "This product includes software developed by the OpenSSL Project
        -:   76: *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
        -:   77: *
        -:   78: * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
        -:   79: *    endorse or promote products derived from this software without
        -:   80: *    prior written permission. For written permission, please contact
        -:   81: *    openssl-core@openssl.org.
        -:   82: *
        -:   83: * 5. Products derived from this software may not be called "OpenSSL"
        -:   84: *    nor may "OpenSSL" appear in their names without prior written
        -:   85: *    permission of the OpenSSL Project.
        -:   86: *
        -:   87: * 6. Redistributions of any form whatsoever must retain the following
        -:   88: *    acknowledgment:
        -:   89: *    "This product includes software developed by the OpenSSL Project
        -:   90: *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
        -:   91: *
        -:   92: * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
        -:   93: * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   94: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        -:   95: * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
        -:   96: * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   97: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   98: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   99: * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:  100: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:  101: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        -:  102: * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
        -:  103: * OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  104: * ====================================================================
        -:  105: *
        -:  106: * This product includes cryptographic software written by Eric Young
        -:  107: * (eay@cryptsoft.com).  This product includes software written by Tim
        -:  108: * Hudson (tjh@cryptsoft.com).
        -:  109: *
        -:  110: */
        -:  111:/* ====================================================================
        -:  112: * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
        -:  113: * ECC cipher suite support in OpenSSL originally developed by 
        -:  114: * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
        -:  115: */
        -:  116:/* ====================================================================
        -:  117: * Copyright 2005 Nokia. All rights reserved.
        -:  118: *
        -:  119: * The portions of the attached software ("Contribution") is developed by
        -:  120: * Nokia Corporation and is licensed pursuant to the OpenSSL open source
        -:  121: * license.
        -:  122: *
        -:  123: * The Contribution, originally written by Mika Kousa and Pasi Eronen of
        -:  124: * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
        -:  125: * support (see RFC 4279) to OpenSSL.
        -:  126: *
        -:  127: * No patent licenses or other rights except those expressly stated in
        -:  128: * the OpenSSL open source license shall be deemed granted or received
        -:  129: * expressly, by implication, estoppel, or otherwise.
        -:  130: *
        -:  131: * No assurances are provided by Nokia that the Contribution does not
        -:  132: * infringe the patent or other intellectual property rights of any third
        -:  133: * party or that the license provides you with all the necessary rights
        -:  134: * to make use of the Contribution.
        -:  135: *
        -:  136: * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
        -:  137: * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
        -:  138: * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
        -:  139: * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
        -:  140: * OTHERWISE.
        -:  141: */
        -:  142:
        -:  143:/* Until the key-gen callbacks are modified to use newer prototypes, we allow
        -:  144: * deprecated functions for openssl-internal code */
        -:  145:#ifdef OPENSSL_NO_DEPRECATED
        -:  146:#undef OPENSSL_NO_DEPRECATED
        -:  147:#endif
        -:  148:
        -:  149:#include <assert.h>
        -:  150:#include <ctype.h>
        -:  151:#include <stdio.h>
        -:  152:#include <stdlib.h>
        -:  153:#include <string.h>
        -:  154:
        -:  155:#include <openssl/e_os2.h>
        -:  156:#ifdef OPENSSL_NO_STDIO
        -:  157:#define APPS_WIN16
        -:  158:#endif
        -:  159:
        -:  160:#if !defined(OPENSSL_SYS_NETWARE)  /* conflicts with winsock2 stuff on netware */
        -:  161:#include <sys/types.h>
        -:  162:#endif
        -:  163:
        -:  164:/* With IPv6, it looks like Digital has mixed up the proper order of
        -:  165:   recursive header file inclusion, resulting in the compiler complaining
        -:  166:   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
        -:  167:   is needed to have fileno() declared correctly...  So let's define u_int */
        -:  168:#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
        -:  169:#define __U_INT
        -:  170:typedef unsigned int u_int;
        -:  171:#endif
        -:  172:
        -:  173:#include <openssl/lhash.h>
        -:  174:#include <openssl/bn.h>
        -:  175:#define USE_SOCKETS
        -:  176:#include "apps.h"
        -:  177:#include <openssl/err.h>
        -:  178:#include <openssl/pem.h>
        -:  179:#include <openssl/x509.h>
        -:  180:#include <openssl/ssl.h>
        -:  181:#include <openssl/rand.h>
        -:  182:#include <openssl/ocsp.h>
        -:  183:#ifndef OPENSSL_NO_DH
        -:  184:#include <openssl/dh.h>
        -:  185:#endif
        -:  186:#ifndef OPENSSL_NO_RSA
        -:  187:#include <openssl/rsa.h>
        -:  188:#endif
        -:  189:#ifndef OPENSSL_NO_SRP
        -:  190:#include <openssl/srp.h>
        -:  191:#endif
        -:  192:#include "s_apps.h"
        -:  193:#include "timeouts.h"
        -:  194:
        -:  195:#if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
        -:  196:/* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
        -:  197:#undef FIONBIO
        -:  198:#endif
        -:  199:
        -:  200:#if defined(OPENSSL_SYS_BEOS_R5)
        -:  201:#include <fcntl.h>
        -:  202:#endif
        -:  203:
        -:  204:#ifndef OPENSSL_NO_RSA
        -:  205:static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength);
        -:  206:#endif
        -:  207:static int sv_body(char *hostname, int s, unsigned char *context);
        -:  208:static int www_body(char *hostname, int s, unsigned char *context);
        -:  209:static void close_accept_socket(void );
        -:  210:static void sv_usage(void);
        -:  211:static int init_ssl_connection(SSL *s);
        -:  212:static void print_stats(BIO *bp,SSL_CTX *ctx);
        -:  213:static int generate_session_id(const SSL *ssl, unsigned char *id,
        -:  214:				unsigned int *id_len);
        -:  215:#ifndef OPENSSL_NO_DH
        -:  216:static DH *load_dh_param(const char *dhfile);
        -:  217:static DH *get_dh512(void);
        -:  218:#endif
        -:  219:
        -:  220:#ifdef MONOLITH
        -:  221:static void s_server_init(void);
        -:  222:#endif
        -:  223:
        -:  224:#ifndef OPENSSL_NO_DH
        -:  225:static unsigned char dh512_p[]={
        -:  226:	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
        -:  227:	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
        -:  228:	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
        -:  229:	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
        -:  230:	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
        -:  231:	0x47,0x74,0xE8,0x33,
        -:  232:	};
        -:  233:static unsigned char dh512_g[]={
        -:  234:	0x02,
        -:  235:	};
        -:  236:
    #####:  237:static DH *get_dh512(void)
        -:  238:	{
        -:  239:	DH *dh=NULL;
        -:  240:
    #####:  241:	if ((dh=DH_new()) == NULL) return(NULL);
    #####:  242:	dh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);
    #####:  243:	dh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);
    #####:  244:	if ((dh->p == NULL) || (dh->g == NULL))
        -:  245:		return(NULL);
    #####:  246:	return(dh);
        -:  247:	}
        -:  248:#endif
        -:  249:
        -:  250:
        -:  251:/* static int load_CA(SSL_CTX *ctx, char *file);*/
        -:  252:
        -:  253:#undef BUFSIZZ
        -:  254:#define BUFSIZZ	16*1024
        -:  255:static int bufsize=BUFSIZZ;
        -:  256:static int accept_socket= -1;
        -:  257:
        -:  258:#define TEST_CERT	"server.pem"
        -:  259:#ifndef OPENSSL_NO_TLSEXT
        -:  260:#define TEST_CERT2	"server2.pem"
        -:  261:#endif
        -:  262:#undef PROG
        -:  263:#define PROG		s_server_main
        -:  264:
        -:  265:extern int verify_depth, verify_return_error;
        -:  266:
        -:  267:static char *cipher=NULL;
        -:  268:static int s_server_verify=SSL_VERIFY_NONE;
        -:  269:static int s_server_session_id_context = 1; /* anything will do */
        -:  270:static const char *s_cert_file=TEST_CERT,*s_key_file=NULL;
        -:  271:#ifndef OPENSSL_NO_TLSEXT
        -:  272:static const char *s_cert_file2=TEST_CERT2,*s_key_file2=NULL;
        -:  273:#endif
        -:  274:static char *s_dcert_file=NULL,*s_dkey_file=NULL;
        -:  275:#ifdef FIONBIO
        -:  276:static int s_nbio=0;
        -:  277:#endif
        -:  278:static int s_nbio_test=0;
        -:  279:int s_crlf=0;
        -:  280:static SSL_CTX *ctx=NULL;
        -:  281:#ifndef OPENSSL_NO_TLSEXT
        -:  282:static SSL_CTX *ctx2=NULL;
        -:  283:#endif
        -:  284:static int www=0;
        -:  285:
        -:  286:static BIO *bio_s_out=NULL;
        -:  287:static int s_debug=0;
        -:  288:#ifndef OPENSSL_NO_TLSEXT
        -:  289:static int s_tlsextdebug=0;
        -:  290:static int s_tlsextstatus=0;
        -:  291:static int cert_status_cb(SSL *s, void *arg);
        -:  292:#endif
        -:  293:static int s_msg=0;
        -:  294:static int s_quiet=0;
        -:  295:
        -:  296:static char *keymatexportlabel=NULL;
        -:  297:static int keymatexportlen=20;
        -:  298:
        -:  299:static int hack=0;
        -:  300:#ifndef OPENSSL_NO_ENGINE
        -:  301:static char *engine_id=NULL;
        -:  302:#endif
        -:  303:static const char *session_id_prefix=NULL;
        -:  304:
        -:  305:static int enable_timeouts = 0;
        -:  306:static long socket_mtu;
        -:  307:#ifndef OPENSSL_NO_DTLS1
        -:  308:static int cert_chain = 0;
        -:  309:#endif
        -:  310:
        -:  311:
        -:  312:#ifndef OPENSSL_NO_PSK
        -:  313:static char *psk_identity="Client_identity";
        -:  314:char *psk_key=NULL; /* by default PSK is not used */
        -:  315:
    #####:  316:static unsigned int psk_server_cb(SSL *ssl, const char *identity,
        -:  317:	unsigned char *psk, unsigned int max_psk_len)
        -:  318:	{
        -:  319:	unsigned int psk_len = 0;
        -:  320:	int ret;
    #####:  321:	BIGNUM *bn = NULL;
        -:  322:
    #####:  323:	if (s_debug)
    #####:  324:		BIO_printf(bio_s_out,"psk_server_cb\n");
    #####:  325:	if (!identity)
        -:  326:		{
    #####:  327:		BIO_printf(bio_err,"Error: client did not send PSK identity\n");
    #####:  328:		goto out_err;
        -:  329:		}
    #####:  330:	if (s_debug)
    #####:  331:		BIO_printf(bio_s_out,"identity_len=%d identity=%s\n",
    #####:  332:			identity ? (int)strlen(identity) : 0, identity);
        -:  333:
        -:  334:	/* here we could lookup the given identity e.g. from a database */
    #####:  335:  	if (strcmp(identity, psk_identity) != 0)
        -:  336:		{
    #####:  337:                BIO_printf(bio_s_out, "PSK error: client identity not found"
        -:  338:			   " (got '%s' expected '%s')\n", identity,
        -:  339:			   psk_identity);
    #####:  340:		goto out_err;
        -:  341:                }
    #####:  342:	if (s_debug)
    #####:  343:		BIO_printf(bio_s_out, "PSK client identity found\n");
        -:  344:
        -:  345:	/* convert the PSK key to binary */
    #####:  346:	ret = BN_hex2bn(&bn, psk_key);
    #####:  347:	if (!ret)
        -:  348:		{
    #####:  349:		BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", psk_key);
    #####:  350:		if (bn)
    #####:  351:			BN_free(bn);
        -:  352:		return 0;
        -:  353:		}
    #####:  354:	if (BN_num_bytes(bn) > (int)max_psk_len)
        -:  355:		{
    #####:  356:		BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
    #####:  357:			max_psk_len, BN_num_bytes(bn));
    #####:  358:		BN_free(bn);
    #####:  359:		return 0;
        -:  360:		}
        -:  361:
    #####:  362:	ret = BN_bn2bin(bn, psk);
    #####:  363:	BN_free(bn);
        -:  364:
    #####:  365:	if (ret < 0)
        -:  366:		goto out_err;
    #####:  367:	psk_len = (unsigned int)ret;
        -:  368:
    #####:  369:	if (s_debug)
    #####:  370:		BIO_printf(bio_s_out, "fetched PSK len=%d\n", psk_len);
    #####:  371:        return psk_len;
        -:  372: out_err:
    #####:  373:	if (s_debug)
    #####:  374:		BIO_printf(bio_err, "Error in PSK server callback\n");
        -:  375:	return 0;
        -:  376:        }
        -:  377:#endif
        -:  378:
        -:  379:#ifndef OPENSSL_NO_SRP
        -:  380:/* This is a context that we pass to callbacks */
        -:  381:typedef struct srpsrvparm_st
        -:  382:	{
        -:  383:	char *login;
        -:  384:	SRP_VBASE *vb;
        -:  385:	SRP_user_pwd *user;
        -:  386:	} srpsrvparm;
        -:  387:
        -:  388:/* This callback pretends to require some asynchronous logic in order to obtain
        -:  389:   a verifier. When the callback is called for a new connection we return
        -:  390:   with a negative value. This will provoke the accept etc to return with
        -:  391:   an LOOKUP_X509. The main logic of the reinvokes the suspended call 
        -:  392:   (which would normally occur after a worker has finished) and we
        -:  393:   set the user parameters. 
        -:  394:*/
    #####:  395:static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
        -:  396:	{
        -:  397:	srpsrvparm *p = (srpsrvparm *)arg;
    #####:  398:	if (p->login == NULL && p->user == NULL )
        -:  399:		{
    #####:  400:		p->login = SSL_get_srp_username(s);
    #####:  401:		BIO_printf(bio_err, "SRP username = \"%s\"\n", p->login);
    #####:  402:		return (-1) ;
        -:  403:		}
        -:  404:
    #####:  405:	if (p->user == NULL)
        -:  406:		{
    #####:  407:		BIO_printf(bio_err, "User %s doesn't exist\n", p->login);
    #####:  408:		return SSL3_AL_FATAL;
        -:  409:		}
    #####:  410:	if (SSL_set_srp_server_param(s, p->user->N, p->user->g, p->user->s, p->user->v,
        -:  411:				     p->user->info) < 0)
        -:  412:		{
    #####:  413:		*ad = SSL_AD_INTERNAL_ERROR;
    #####:  414:		return SSL3_AL_FATAL;
        -:  415:		}
    #####:  416:	BIO_printf(bio_err, "SRP parameters set: username = \"%s\" info=\"%s\" \n", p->login,p->user->info);
        -:  417:	/* need to check whether there are memory leaks */
    #####:  418:	p->user = NULL;
    #####:  419:	p->login = NULL;
    #####:  420:	return SSL_ERROR_NONE;
        -:  421:	}
        -:  422:
        -:  423:#endif
        -:  424:
        -:  425:#ifdef MONOLITH
    #####:  426:static void s_server_init(void)
        -:  427:	{
    #####:  428:	accept_socket=-1;
    #####:  429:	cipher=NULL;
    #####:  430:	s_server_verify=SSL_VERIFY_NONE;
    #####:  431:	s_dcert_file=NULL;
    #####:  432:	s_dkey_file=NULL;
    #####:  433:	s_cert_file=TEST_CERT;
    #####:  434:	s_key_file=NULL;
        -:  435:#ifndef OPENSSL_NO_TLSEXT
    #####:  436:	s_cert_file2=TEST_CERT2;
    #####:  437:	s_key_file2=NULL;
    #####:  438:	ctx2=NULL;
        -:  439:#endif
        -:  440:#ifdef FIONBIO
    #####:  441:	s_nbio=0;
        -:  442:#endif
    #####:  443:	s_nbio_test=0;
    #####:  444:	ctx=NULL;
    #####:  445:	www=0;
        -:  446:
    #####:  447:	bio_s_out=NULL;
    #####:  448:	s_debug=0;
    #####:  449:	s_msg=0;
    #####:  450:	s_quiet=0;
    #####:  451:	hack=0;
        -:  452:#ifndef OPENSSL_NO_ENGINE
    #####:  453:	engine_id=NULL;
        -:  454:#endif
    #####:  455:	}
        -:  456:#endif
        -:  457:
    #####:  458:static void sv_usage(void)
        -:  459:	{
    #####:  460:	BIO_printf(bio_err,"usage: s_server [args ...]\n");
    #####:  461:	BIO_printf(bio_err,"\n");
    #####:  462:	BIO_printf(bio_err," -accept arg   - port to accept on (default is %d)\n",PORT);
    #####:  463:	BIO_printf(bio_err," -context arg  - set session ID context\n");
    #####:  464:	BIO_printf(bio_err," -verify arg   - turn on peer certificate verification\n");
    #####:  465:	BIO_printf(bio_err," -Verify arg   - turn on peer certificate verification, must have a cert.\n");
    #####:  466:	BIO_printf(bio_err," -cert arg     - certificate file to use\n");
    #####:  467:	BIO_printf(bio_err,"                 (default is %s)\n",TEST_CERT);
    #####:  468:	BIO_printf(bio_err," -crl_check    - check the peer certificate has not been revoked by its CA.\n" \
        -:  469:	                   "                 The CRL(s) are appended to the certificate file\n");
    #####:  470:	BIO_printf(bio_err," -crl_check_all - check the peer certificate has not been revoked by its CA\n" \
        -:  471:	                   "                 or any other CRL in the CA chain. CRL(s) are appened to the\n" \
        -:  472:	                   "                 the certificate file.\n");
    #####:  473:	BIO_printf(bio_err," -certform arg - certificate format (PEM or DER) PEM default\n");
    #####:  474:	BIO_printf(bio_err," -key arg      - Private Key file to use, in cert file if\n");
    #####:  475:	BIO_printf(bio_err,"                 not specified (default is %s)\n",TEST_CERT);
    #####:  476:	BIO_printf(bio_err," -keyform arg  - key format (PEM, DER or ENGINE) PEM default\n");
    #####:  477:	BIO_printf(bio_err," -pass arg     - private key file pass phrase source\n");
    #####:  478:	BIO_printf(bio_err," -dcert arg    - second certificate file to use (usually for DSA)\n");
    #####:  479:	BIO_printf(bio_err," -dcertform x  - second certificate format (PEM or DER) PEM default\n");
    #####:  480:	BIO_printf(bio_err," -dkey arg     - second private key file to use (usually for DSA)\n");
    #####:  481:	BIO_printf(bio_err," -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\n");
    #####:  482:	BIO_printf(bio_err," -dpass arg    - second private key file pass phrase source\n");
    #####:  483:	BIO_printf(bio_err," -dhparam arg  - DH parameter file to use, in cert file if not specified\n");
    #####:  484:	BIO_printf(bio_err,"                 or a default set of parameters is used\n");
        -:  485:#ifndef OPENSSL_NO_ECDH
    #####:  486:	BIO_printf(bio_err," -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
        -:  487:	                   "                 Use \"openssl ecparam -list_curves\" for all names\n" \
        -:  488:	                   "                 (default is nistp256).\n");
        -:  489:#endif
        -:  490:#ifdef FIONBIO
    #####:  491:	BIO_printf(bio_err," -nbio         - Run with non-blocking IO\n");
        -:  492:#endif
    #####:  493:	BIO_printf(bio_err," -nbio_test    - test with the non-blocking test bio\n");
    #####:  494:	BIO_printf(bio_err," -crlf         - convert LF from terminal into CRLF\n");
    #####:  495:	BIO_printf(bio_err," -debug        - Print more output\n");
    #####:  496:	BIO_printf(bio_err," -msg          - Show protocol messages\n");
    #####:  497:	BIO_printf(bio_err," -state        - Print the SSL states\n");
    #####:  498:	BIO_printf(bio_err," -CApath arg   - PEM format directory of CA's\n");
    #####:  499:	BIO_printf(bio_err," -CAfile arg   - PEM format file of CA's\n");
    #####:  500:	BIO_printf(bio_err," -nocert       - Don't use any certificates (Anon-DH)\n");
    #####:  501:	BIO_printf(bio_err," -cipher arg   - play with 'openssl ciphers' to see what goes here\n");
    #####:  502:	BIO_printf(bio_err," -serverpref   - Use server's cipher preferences\n");
    #####:  503:	BIO_printf(bio_err," -quiet        - No server output\n");
    #####:  504:	BIO_printf(bio_err," -no_tmp_rsa   - Do not generate a tmp RSA key\n");
        -:  505:#ifndef OPENSSL_NO_PSK
    #####:  506:	BIO_printf(bio_err," -psk_hint arg - PSK identity hint to use\n");
    #####:  507:	BIO_printf(bio_err," -psk arg      - PSK in hex (without 0x)\n");
        -:  508:# ifndef OPENSSL_NO_JPAKE
        -:  509:	BIO_printf(bio_err," -jpake arg    - JPAKE secret to use\n");
        -:  510:# endif
        -:  511:#endif
        -:  512:#ifndef OPENSSL_NO_SRP
    #####:  513:	BIO_printf(bio_err," -srpvfile file      - The verifier file for SRP\n");
    #####:  514:	BIO_printf(bio_err," -srpuserseed string - A seed string for a default user salt.\n");
        -:  515:#endif
    #####:  516:	BIO_printf(bio_err," -ssl2         - Just talk SSLv2\n");
    #####:  517:	BIO_printf(bio_err," -ssl3         - Just talk SSLv3\n");
    #####:  518:	BIO_printf(bio_err," -tls1_2       - Just talk TLSv1.2\n");
    #####:  519:	BIO_printf(bio_err," -tls1_1       - Just talk TLSv1.1\n");
    #####:  520:	BIO_printf(bio_err," -tls1         - Just talk TLSv1\n");
    #####:  521:	BIO_printf(bio_err," -dtls1        - Just talk DTLSv1\n");
    #####:  522:	BIO_printf(bio_err," -timeout      - Enable timeouts\n");
    #####:  523:	BIO_printf(bio_err," -mtu          - Set link layer MTU\n");
    #####:  524:	BIO_printf(bio_err," -chain        - Read a certificate chain\n");
    #####:  525:	BIO_printf(bio_err," -no_ssl2      - Just disable SSLv2\n");
    #####:  526:	BIO_printf(bio_err," -no_ssl3      - Just disable SSLv3\n");
    #####:  527:	BIO_printf(bio_err," -no_tls1      - Just disable TLSv1\n");
    #####:  528:	BIO_printf(bio_err," -no_tls1_1    - Just disable TLSv1.1\n");
    #####:  529:	BIO_printf(bio_err," -no_tls1_2    - Just disable TLSv1.2\n");
        -:  530:#ifndef OPENSSL_NO_DH
    #####:  531:	BIO_printf(bio_err," -no_dhe       - Disable ephemeral DH\n");
        -:  532:#endif
        -:  533:#ifndef OPENSSL_NO_ECDH
    #####:  534:	BIO_printf(bio_err," -no_ecdhe     - Disable ephemeral ECDH\n");
        -:  535:#endif
    #####:  536:	BIO_printf(bio_err," -bugs         - Turn on SSL bug compatibility\n");
    #####:  537:	BIO_printf(bio_err," -www          - Respond to a 'GET /' with a status page\n");
    #####:  538:	BIO_printf(bio_err," -WWW          - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
    #####:  539:	BIO_printf(bio_err," -HTTP         - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
    #####:  540:        BIO_printf(bio_err,"                 with the assumption it contains a complete HTTP response.\n");
        -:  541:#ifndef OPENSSL_NO_ENGINE
    #####:  542:	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
        -:  543:#endif
    #####:  544:	BIO_printf(bio_err," -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\n");
    #####:  545:	BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
        -:  546:#ifndef OPENSSL_NO_TLSEXT
    #####:  547:	BIO_printf(bio_err," -servername host - servername for HostName TLS extension\n");
    #####:  548:	BIO_printf(bio_err," -servername_fatal - on mismatch send fatal alert (default warning alert)\n");
    #####:  549:	BIO_printf(bio_err," -cert2 arg    - certificate file to use for servername\n");
    #####:  550:	BIO_printf(bio_err,"                 (default is %s)\n",TEST_CERT2);
    #####:  551:	BIO_printf(bio_err," -key2 arg     - Private Key file to use for servername, in cert file if\n");
    #####:  552:	BIO_printf(bio_err,"                 not specified (default is %s)\n",TEST_CERT2);
    #####:  553:	BIO_printf(bio_err," -tlsextdebug  - hex dump of all TLS extensions received\n");
    #####:  554:	BIO_printf(bio_err," -no_ticket    - disable use of RFC4507bis session tickets\n");
    #####:  555:	BIO_printf(bio_err," -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
        -:  556:# ifndef OPENSSL_NO_NEXTPROTONEG
    #####:  557:	BIO_printf(bio_err," -nextprotoneg arg - set the advertised protocols for the NPN extension (comma-separated list)\n");
        -:  558:# endif
        -:  559:# ifndef OPENSSL_NO_SRTP
    #####:  560:        BIO_printf(bio_err," -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
        -:  561:# endif
        -:  562:#endif
    #####:  563:	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
    #####:  564:	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
    #####:  565:	}
        -:  566:
        -:  567:static int local_argc=0;
        -:  568:static char **local_argv;
        -:  569:
        -:  570:#ifdef CHARSET_EBCDIC
        -:  571:static int ebcdic_new(BIO *bi);
        -:  572:static int ebcdic_free(BIO *a);
        -:  573:static int ebcdic_read(BIO *b, char *out, int outl);
        -:  574:static int ebcdic_write(BIO *b, const char *in, int inl);
        -:  575:static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr);
        -:  576:static int ebcdic_gets(BIO *bp, char *buf, int size);
        -:  577:static int ebcdic_puts(BIO *bp, const char *str);
        -:  578:
        -:  579:#define BIO_TYPE_EBCDIC_FILTER	(18|0x0200)
        -:  580:static BIO_METHOD methods_ebcdic=
        -:  581:	{
        -:  582:	BIO_TYPE_EBCDIC_FILTER,
        -:  583:	"EBCDIC/ASCII filter",
        -:  584:	ebcdic_write,
        -:  585:	ebcdic_read,
        -:  586:	ebcdic_puts,
        -:  587:	ebcdic_gets,
        -:  588:	ebcdic_ctrl,
        -:  589:	ebcdic_new,
        -:  590:	ebcdic_free,
        -:  591:	};
        -:  592:
        -:  593:typedef struct
        -:  594:{
        -:  595:	size_t	alloced;
        -:  596:	char	buff[1];
        -:  597:} EBCDIC_OUTBUFF;
        -:  598:
        -:  599:BIO_METHOD *BIO_f_ebcdic_filter()
        -:  600:{
        -:  601:	return(&methods_ebcdic);
        -:  602:}
        -:  603:
        -:  604:static int ebcdic_new(BIO *bi)
        -:  605:{
        -:  606:	EBCDIC_OUTBUFF *wbuf;
        -:  607:
        -:  608:	wbuf = (EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);
        -:  609:	wbuf->alloced = 1024;
        -:  610:	wbuf->buff[0] = '\0';
        -:  611:
        -:  612:	bi->ptr=(char *)wbuf;
        -:  613:	bi->init=1;
        -:  614:	bi->flags=0;
        -:  615:	return(1);
        -:  616:}
        -:  617:
        -:  618:static int ebcdic_free(BIO *a)
        -:  619:{
        -:  620:	if (a == NULL) return(0);
        -:  621:	if (a->ptr != NULL)
        -:  622:		OPENSSL_free(a->ptr);
        -:  623:	a->ptr=NULL;
        -:  624:	a->init=0;
        -:  625:	a->flags=0;
        -:  626:	return(1);
        -:  627:}
        -:  628:	
        -:  629:static int ebcdic_read(BIO *b, char *out, int outl)
        -:  630:{
        -:  631:	int ret=0;
        -:  632:
        -:  633:	if (out == NULL || outl == 0) return(0);
        -:  634:	if (b->next_bio == NULL) return(0);
        -:  635:
        -:  636:	ret=BIO_read(b->next_bio,out,outl);
        -:  637:	if (ret > 0)
        -:  638:		ascii2ebcdic(out,out,ret);
        -:  639:	return(ret);
        -:  640:}
        -:  641:
        -:  642:static int ebcdic_write(BIO *b, const char *in, int inl)
        -:  643:{
        -:  644:	EBCDIC_OUTBUFF *wbuf;
        -:  645:	int ret=0;
        -:  646:	int num;
        -:  647:	unsigned char n;
        -:  648:
        -:  649:	if ((in == NULL) || (inl <= 0)) return(0);
        -:  650:	if (b->next_bio == NULL) return(0);
        -:  651:
        -:  652:	wbuf=(EBCDIC_OUTBUFF *)b->ptr;
        -:  653:
        -:  654:	if (inl > (num = wbuf->alloced))
        -:  655:	{
        -:  656:		num = num + num;  /* double the size */
        -:  657:		if (num < inl)
        -:  658:			num = inl;
        -:  659:		OPENSSL_free(wbuf);
        -:  660:		wbuf=(EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + num);
        -:  661:
        -:  662:		wbuf->alloced = num;
        -:  663:		wbuf->buff[0] = '\0';
        -:  664:
        -:  665:		b->ptr=(char *)wbuf;
        -:  666:	}
        -:  667:
        -:  668:	ebcdic2ascii(wbuf->buff, in, inl);
        -:  669:
        -:  670:	ret=BIO_write(b->next_bio, wbuf->buff, inl);
        -:  671:
        -:  672:	return(ret);
        -:  673:}
        -:  674:
        -:  675:static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr)
        -:  676:{
        -:  677:	long ret;
        -:  678:
        -:  679:	if (b->next_bio == NULL) return(0);
        -:  680:	switch (cmd)
        -:  681:	{
        -:  682:	case BIO_CTRL_DUP:
        -:  683:		ret=0L;
        -:  684:		break;
        -:  685:	default:
        -:  686:		ret=BIO_ctrl(b->next_bio,cmd,num,ptr);
        -:  687:		break;
        -:  688:	}
        -:  689:	return(ret);
        -:  690:}
        -:  691:
        -:  692:static int ebcdic_gets(BIO *bp, char *buf, int size)
        -:  693:{
        -:  694:	int i, ret=0;
        -:  695:	if (bp->next_bio == NULL) return(0);
        -:  696:/*	return(BIO_gets(bp->next_bio,buf,size));*/
        -:  697:	for (i=0; i<size-1; ++i)
        -:  698:	{
        -:  699:		ret = ebcdic_read(bp,&buf[i],1);
        -:  700:		if (ret <= 0)
        -:  701:			break;
        -:  702:		else if (buf[i] == '\n')
        -:  703:		{
        -:  704:			++i;
        -:  705:			break;
        -:  706:		}
        -:  707:	}
        -:  708:	if (i < size)
        -:  709:		buf[i] = '\0';
        -:  710:	return (ret < 0 && i == 0) ? ret : i;
        -:  711:}
        -:  712:
        -:  713:static int ebcdic_puts(BIO *bp, const char *str)
        -:  714:{
        -:  715:	if (bp->next_bio == NULL) return(0);
        -:  716:	return ebcdic_write(bp, str, strlen(str));
        -:  717:}
        -:  718:#endif
        -:  719:
        -:  720:#ifndef OPENSSL_NO_TLSEXT
        -:  721:
        -:  722:/* This is a context that we pass to callbacks */
        -:  723:typedef struct tlsextctx_st {
        -:  724:   char * servername;
        -:  725:   BIO * biodebug;
        -:  726:   int extension_error;
        -:  727:} tlsextctx;
        -:  728:
        -:  729:
    #####:  730:static int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)
        -:  731:	{
        -:  732:	tlsextctx * p = (tlsextctx *) arg;
    #####:  733:	const char * servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
    #####:  734:        if (servername && p->biodebug) 
    #####:  735:		BIO_printf(p->biodebug,"Hostname in TLS extension: \"%s\"\n",servername);
        -:  736:        
    #####:  737:	if (!p->servername)
        -:  738:		return SSL_TLSEXT_ERR_NOACK;
        -:  739:	
    #####:  740:	if (servername)
        -:  741:		{
    #####:  742:    		if (strcmp(servername,p->servername)) 
    #####:  743:			return p->extension_error;
    #####:  744:		if (ctx2)
        -:  745:			{
    #####:  746:			BIO_printf(p->biodebug,"Switching server context.\n");
    #####:  747:			SSL_set_SSL_CTX(s,ctx2);
        -:  748:			}     
        -:  749:		}
        -:  750:	return SSL_TLSEXT_ERR_OK;
        -:  751:}
        -:  752:
        -:  753:/* Structure passed to cert status callback */
        -:  754:
        -:  755:typedef struct tlsextstatusctx_st {
        -:  756:   /* Default responder to use */
        -:  757:   char *host, *path, *port;
        -:  758:   int use_ssl;
        -:  759:   int timeout;
        -:  760:   BIO *err;
        -:  761:   int verbose;
        -:  762:} tlsextstatusctx;
        -:  763:
        -:  764:static tlsextstatusctx tlscstatp = {NULL, NULL, NULL, 0, -1, NULL, 0};
        -:  765:
        -:  766:/* Certificate Status callback. This is called when a client includes a
        -:  767: * certificate status request extension.
        -:  768: *
        -:  769: * This is a simplified version. It examines certificates each time and
        -:  770: * makes one OCSP responder query for each request.
        -:  771: *
        -:  772: * A full version would store details such as the OCSP certificate IDs and
        -:  773: * minimise the number of OCSP responses by caching them until they were
        -:  774: * considered "expired".
        -:  775: */
        -:  776:
    #####:  777:static int cert_status_cb(SSL *s, void *arg)
        -:  778:	{
        -:  779:	tlsextstatusctx *srctx = arg;
    #####:  780:	BIO *err = srctx->err;
        -:  781:	char *host, *port, *path;
        -:  782:	int use_ssl;
    #####:  783:	unsigned char *rspder = NULL;
        -:  784:	int rspderlen;
        -:  785:	STACK_OF(OPENSSL_STRING) *aia = NULL;
        -:  786:	X509 *x = NULL;
        -:  787:	X509_STORE_CTX inctx;
        -:  788:	X509_OBJECT obj;
        -:  789:	OCSP_REQUEST *req = NULL;
        -:  790:	OCSP_RESPONSE *resp = NULL;
        -:  791:	OCSP_CERTID *id = NULL;
        -:  792:	STACK_OF(X509_EXTENSION) *exts;
        -:  793:	int ret = SSL_TLSEXT_ERR_NOACK;
        -:  794:	int i;
        -:  795:#if 0
        -:  796:STACK_OF(OCSP_RESPID) *ids;
        -:  797:SSL_get_tlsext_status_ids(s, &ids);
        -:  798:BIO_printf(err, "cert_status: received %d ids\n", sk_OCSP_RESPID_num(ids));
        -:  799:#endif
    #####:  800:	if (srctx->verbose)
    #####:  801:		BIO_puts(err, "cert_status: callback called\n");
        -:  802:	/* Build up OCSP query from server certificate */
    #####:  803:	x = SSL_get_certificate(s);
    #####:  804:	aia = X509_get1_ocsp(x);
    #####:  805:	if (aia)
        -:  806:		{
    #####:  807:		if (!OCSP_parse_url(sk_OPENSSL_STRING_value(aia, 0),
        -:  808:			&host, &port, &path, &use_ssl))
        -:  809:			{
    #####:  810:			BIO_puts(err, "cert_status: can't parse AIA URL\n");
    #####:  811:			goto err;
        -:  812:			}
    #####:  813:		if (srctx->verbose)
    #####:  814:			BIO_printf(err, "cert_status: AIA URL: %s\n",
    #####:  815:					sk_OPENSSL_STRING_value(aia, 0));
        -:  816:		}
        -:  817:	else
        -:  818:		{
    #####:  819:		if (!srctx->host)
        -:  820:			{
    #####:  821:			BIO_puts(srctx->err, "cert_status: no AIA and no default responder URL\n");
    #####:  822:			goto done;
        -:  823:			}
    #####:  824:		host = srctx->host;
    #####:  825:		path = srctx->path;
    #####:  826:		port = srctx->port;
    #####:  827:		use_ssl = srctx->use_ssl;
        -:  828:		}
        -:  829:		
    #####:  830:	if (!X509_STORE_CTX_init(&inctx,
    #####:  831:				SSL_CTX_get_cert_store(SSL_get_SSL_CTX(s)),
        -:  832:				NULL, NULL))
        -:  833:		goto err;
    #####:  834:	if (X509_STORE_get_by_subject(&inctx,X509_LU_X509,
        -:  835:				X509_get_issuer_name(x),&obj) <= 0)
        -:  836:		{
    #####:  837:		BIO_puts(err, "cert_status: Can't retrieve issuer certificate.\n");
    #####:  838:		X509_STORE_CTX_cleanup(&inctx);
    #####:  839:		goto done;
        -:  840:		}
    #####:  841:	req = OCSP_REQUEST_new();
    #####:  842:	if (!req)
        -:  843:		goto err;
    #####:  844:	id = OCSP_cert_to_id(NULL, x, obj.data.x509);
    #####:  845:	X509_free(obj.data.x509);
    #####:  846:	X509_STORE_CTX_cleanup(&inctx);
    #####:  847:	if (!id)
        -:  848:		goto err;
    #####:  849:	if (!OCSP_request_add0_id(req, id))
        -:  850:		goto err;
        -:  851:	id = NULL;
        -:  852:	/* Add any extensions to the request */
    #####:  853:	SSL_get_tlsext_status_exts(s, &exts);
    #####:  854:	for (i = 0; i < sk_X509_EXTENSION_num(exts); i++)
        -:  855:		{
    #####:  856:		X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
    #####:  857:		if (!OCSP_REQUEST_add_ext(req, ext, -1))
        -:  858:			goto err;
        -:  859:		}
    #####:  860:	resp = process_responder(err, req, host, path, port, use_ssl, NULL,
        -:  861:					srctx->timeout);
    #####:  862:	if (!resp)
        -:  863:		{
    #####:  864:		BIO_puts(err, "cert_status: error querying responder\n");
    #####:  865:		goto done;
        -:  866:		}
    #####:  867:	rspderlen = i2d_OCSP_RESPONSE(resp, &rspder);
    #####:  868:	if (rspderlen <= 0)
        -:  869:		goto err;
    #####:  870:	SSL_set_tlsext_status_ocsp_resp(s, rspder, rspderlen);
    #####:  871:	if (srctx->verbose)
        -:  872:		{
    #####:  873:		BIO_puts(err, "cert_status: ocsp response sent:\n");
    #####:  874:		OCSP_RESPONSE_print(err, resp, 2);
        -:  875:		}
        -:  876:	ret = SSL_TLSEXT_ERR_OK;
        -:  877:	done:
    #####:  878:	if (ret != SSL_TLSEXT_ERR_OK)
    #####:  879:		ERR_print_errors(err);
    #####:  880:	if (aia)
        -:  881:		{
    #####:  882:		OPENSSL_free(host);
    #####:  883:		OPENSSL_free(path);
    #####:  884:		OPENSSL_free(port);
    #####:  885:		X509_email_free(aia);
        -:  886:		}
    #####:  887:	if (id)
    #####:  888:		OCSP_CERTID_free(id);
    #####:  889:	if (req)
    #####:  890:		OCSP_REQUEST_free(req);
    #####:  891:	if (resp)
    #####:  892:		OCSP_RESPONSE_free(resp);
    #####:  893:	return ret;
        -:  894:	err:
        -:  895:	ret = SSL_TLSEXT_ERR_ALERT_FATAL;
        -:  896:	goto done;
        -:  897:	}
        -:  898:
        -:  899:# ifndef OPENSSL_NO_NEXTPROTONEG
        -:  900:/* This is the context that we pass to next_proto_cb */
        -:  901:typedef struct tlsextnextprotoctx_st {
        -:  902:	unsigned char *data;
        -:  903:	unsigned int len;
        -:  904:} tlsextnextprotoctx;
        -:  905:
    #####:  906:static int next_proto_cb(SSL *s, const unsigned char **data, unsigned int *len, void *arg)
        -:  907:	{
        -:  908:	tlsextnextprotoctx *next_proto = arg;
        -:  909:
    #####:  910:	*data = next_proto->data;
    #####:  911:	*len = next_proto->len;
        -:  912:
    #####:  913:	return SSL_TLSEXT_ERR_OK;
        -:  914:	}
        -:  915:# endif  /* ndef OPENSSL_NO_NEXTPROTONEG */
        -:  916:
        -:  917:
        -:  918:#endif
        -:  919:
        -:  920:int MAIN(int, char **);
        -:  921:
        -:  922:#ifndef OPENSSL_NO_JPAKE
        -:  923:static char *jpake_secret = NULL;
        -:  924:#endif
        -:  925:#ifndef OPENSSL_NO_SRP
        -:  926:	static srpsrvparm srp_callback_parm;
        -:  927:#endif
        -:  928:#ifndef OPENSSL_NO_SRTP
        -:  929:static char *srtp_profiles = NULL;
        -:  930:#endif
        -:  931:
    #####:  932:int MAIN(int argc, char *argv[])
        -:  933:	{
    #####:  934:	X509_VERIFY_PARAM *vpm = NULL;
    #####:  935:	int badarg = 0;
    #####:  936:	short port=PORT;
        -:  937:	char *CApath=NULL,*CAfile=NULL;
        -:  938:	unsigned char *context = NULL;
        -:  939:	char *dhfile = NULL;
        -:  940:#ifndef OPENSSL_NO_ECDH
        -:  941:	char *named_curve = NULL;
        -:  942:#endif
        -:  943:	int badop=0,bugs=0;
        -:  944:	int ret=1;
        -:  945:	int off=0;
        -:  946:	int no_tmp_rsa=0,no_dhe=0,no_ecdhe=0,nocert=0;
        -:  947:	int state=0;
        -:  948:	const SSL_METHOD *meth=NULL;
        -:  949:	int socket_type=SOCK_STREAM;
        -:  950:	ENGINE *e=NULL;
        -:  951:	char *inrand=NULL;
        -:  952:	int s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM;
    #####:  953:	char *passarg = NULL, *pass = NULL;
    #####:  954:	char *dpassarg = NULL, *dpass = NULL;
        -:  955:	int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;
        -:  956:	X509 *s_cert = NULL, *s_dcert = NULL;
        -:  957:	EVP_PKEY *s_key = NULL, *s_dkey = NULL;
        -:  958:	int no_cache = 0;
        -:  959:#ifndef OPENSSL_NO_TLSEXT
        -:  960:	EVP_PKEY *s_key2 = NULL;
        -:  961:	X509 *s_cert2 = NULL;
    #####:  962:        tlsextctx tlsextcbp = {NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING};
        -:  963:# ifndef OPENSSL_NO_NEXTPROTONEG
        -:  964:	const char *next_proto_neg_in = NULL;
        -:  965:	tlsextnextprotoctx next_proto;
        -:  966:# endif
        -:  967:#endif
        -:  968:#ifndef OPENSSL_NO_PSK
        -:  969:	/* by default do not send a PSK identity hint */
        -:  970:	static char *psk_identity_hint=NULL;
        -:  971:#endif
        -:  972:#ifndef OPENSSL_NO_SRP
        -:  973:	char *srpuserseed = NULL;
        -:  974:	char *srp_verifier_file = NULL;
        -:  975:#endif
    #####:  976:	meth=SSLv23_server_method();
        -:  977:
    #####:  978:	local_argc=argc;
    #####:  979:	local_argv=argv;
        -:  980:
    #####:  981:	apps_startup();
        -:  982:#ifdef MONOLITH
    #####:  983:	s_server_init();
        -:  984:#endif
        -:  985:
    #####:  986:	if (bio_err == NULL)
    #####:  987:		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
        -:  988:
    #####:  989:	if (!load_config(bio_err, NULL))
        -:  990:		goto end;
        -:  991:
    #####:  992:	verify_depth=0;
        -:  993:#ifdef FIONBIO
    #####:  994:	s_nbio=0;
        -:  995:#endif
    #####:  996:	s_nbio_test=0;
        -:  997:
    #####:  998:	argc--;
    #####:  999:	argv++;
        -: 1000:
    #####: 1001:	while (argc >= 1)
        -: 1002:		{
    #####: 1003:		if	((strcmp(*argv,"-port") == 0) ||
    #####: 1004:			 (strcmp(*argv,"-accept") == 0))
        -: 1005:			{
    #####: 1006:			if (--argc < 1) goto bad;
    #####: 1007:			if (!extract_port(*(++argv),&port))
        -: 1008:				goto bad;
        -: 1009:			}
    #####: 1010:		else if	(strcmp(*argv,"-verify") == 0)
        -: 1011:			{
    #####: 1012:			s_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;
    #####: 1013:			if (--argc < 1) goto bad;
    #####: 1014:			verify_depth=atoi(*(++argv));
    #####: 1015:			BIO_printf(bio_err,"verify depth is %d\n",verify_depth);
        -: 1016:			}
    #####: 1017:		else if	(strcmp(*argv,"-Verify") == 0)
        -: 1018:			{
    #####: 1019:			s_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
        -: 1020:				SSL_VERIFY_CLIENT_ONCE;
    #####: 1021:			if (--argc < 1) goto bad;
    #####: 1022:			verify_depth=atoi(*(++argv));
    #####: 1023:			BIO_printf(bio_err,"verify depth is %d, must return a certificate\n",verify_depth);
        -: 1024:			}
    #####: 1025:		else if	(strcmp(*argv,"-context") == 0)
        -: 1026:			{
    #####: 1027:			if (--argc < 1) goto bad;
    #####: 1028:			context= (unsigned char *)*(++argv);
        -: 1029:			}
    #####: 1030:		else if	(strcmp(*argv,"-cert") == 0)
        -: 1031:			{
    #####: 1032:			if (--argc < 1) goto bad;
    #####: 1033:			s_cert_file= *(++argv);
        -: 1034:			}
    #####: 1035:		else if	(strcmp(*argv,"-certform") == 0)
        -: 1036:			{
    #####: 1037:			if (--argc < 1) goto bad;
    #####: 1038:			s_cert_format = str2fmt(*(++argv));
        -: 1039:			}
    #####: 1040:		else if	(strcmp(*argv,"-key") == 0)
        -: 1041:			{
    #####: 1042:			if (--argc < 1) goto bad;
    #####: 1043:			s_key_file= *(++argv);
        -: 1044:			}
    #####: 1045:		else if	(strcmp(*argv,"-keyform") == 0)
        -: 1046:			{
    #####: 1047:			if (--argc < 1) goto bad;
    #####: 1048:			s_key_format = str2fmt(*(++argv));
        -: 1049:			}
    #####: 1050:		else if	(strcmp(*argv,"-pass") == 0)
        -: 1051:			{
    #####: 1052:			if (--argc < 1) goto bad;
    #####: 1053:			passarg = *(++argv);
        -: 1054:			}
    #####: 1055:		else if	(strcmp(*argv,"-dhparam") == 0)
        -: 1056:			{
    #####: 1057:			if (--argc < 1) goto bad;
    #####: 1058:			dhfile = *(++argv);
        -: 1059:			}
        -: 1060:#ifndef OPENSSL_NO_ECDH		
    #####: 1061:		else if	(strcmp(*argv,"-named_curve") == 0)
        -: 1062:			{
    #####: 1063:			if (--argc < 1) goto bad;
    #####: 1064:			named_curve = *(++argv);
        -: 1065:			}
        -: 1066:#endif
    #####: 1067:		else if	(strcmp(*argv,"-dcertform") == 0)
        -: 1068:			{
    #####: 1069:			if (--argc < 1) goto bad;
    #####: 1070:			s_dcert_format = str2fmt(*(++argv));
        -: 1071:			}
    #####: 1072:		else if	(strcmp(*argv,"-dcert") == 0)
        -: 1073:			{
    #####: 1074:			if (--argc < 1) goto bad;
    #####: 1075:			s_dcert_file= *(++argv);
        -: 1076:			}
    #####: 1077:		else if	(strcmp(*argv,"-dkeyform") == 0)
        -: 1078:			{
    #####: 1079:			if (--argc < 1) goto bad;
    #####: 1080:			s_dkey_format = str2fmt(*(++argv));
        -: 1081:			}
    #####: 1082:		else if	(strcmp(*argv,"-dpass") == 0)
        -: 1083:			{
    #####: 1084:			if (--argc < 1) goto bad;
    #####: 1085:			dpassarg = *(++argv);
        -: 1086:			}
    #####: 1087:		else if	(strcmp(*argv,"-dkey") == 0)
        -: 1088:			{
    #####: 1089:			if (--argc < 1) goto bad;
    #####: 1090:			s_dkey_file= *(++argv);
        -: 1091:			}
    #####: 1092:		else if (strcmp(*argv,"-nocert") == 0)
        -: 1093:			{
        -: 1094:			nocert=1;
        -: 1095:			}
    #####: 1096:		else if	(strcmp(*argv,"-CApath") == 0)
        -: 1097:			{
    #####: 1098:			if (--argc < 1) goto bad;
    #####: 1099:			CApath= *(++argv);
        -: 1100:			}
    #####: 1101:		else if (strcmp(*argv,"-no_cache") == 0)
        -: 1102:			no_cache = 1;
    #####: 1103:		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm))
        -: 1104:			{
    #####: 1105:			if (badarg)
        -: 1106:				goto bad;
    #####: 1107:			continue;
        -: 1108:			}
    #####: 1109:		else if (strcmp(*argv,"-verify_return_error") == 0)
    #####: 1110:			verify_return_error = 1;
    #####: 1111:		else if	(strcmp(*argv,"-serverpref") == 0)
    #####: 1112:			{ off|=SSL_OP_CIPHER_SERVER_PREFERENCE; }
    #####: 1113:		else if (strcmp(*argv,"-legacy_renegotiation") == 0)
    #####: 1114:			off|=SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
    #####: 1115:		else if	(strcmp(*argv,"-cipher") == 0)
        -: 1116:			{
    #####: 1117:			if (--argc < 1) goto bad;
    #####: 1118:			cipher= *(++argv);
        -: 1119:			}
    #####: 1120:		else if	(strcmp(*argv,"-CAfile") == 0)
        -: 1121:			{
    #####: 1122:			if (--argc < 1) goto bad;
    #####: 1123:			CAfile= *(++argv);
        -: 1124:			}
        -: 1125:#ifdef FIONBIO	
    #####: 1126:		else if	(strcmp(*argv,"-nbio") == 0)
    #####: 1127:			{ s_nbio=1; }
        -: 1128:#endif
    #####: 1129:		else if	(strcmp(*argv,"-nbio_test") == 0)
        -: 1130:			{
        -: 1131:#ifdef FIONBIO	
    #####: 1132:			s_nbio=1;
        -: 1133:#endif
    #####: 1134:			s_nbio_test=1;
        -: 1135:			}
    #####: 1136:		else if	(strcmp(*argv,"-debug") == 0)
    #####: 1137:			{ s_debug=1; }
        -: 1138:#ifndef OPENSSL_NO_TLSEXT
    #####: 1139:		else if	(strcmp(*argv,"-tlsextdebug") == 0)
    #####: 1140:			s_tlsextdebug=1;
    #####: 1141:		else if	(strcmp(*argv,"-status") == 0)
    #####: 1142:			s_tlsextstatus=1;
    #####: 1143:		else if	(strcmp(*argv,"-status_verbose") == 0)
        -: 1144:			{
    #####: 1145:			s_tlsextstatus=1;
    #####: 1146:			tlscstatp.verbose = 1;
        -: 1147:			}
    #####: 1148:		else if (!strcmp(*argv, "-status_timeout"))
        -: 1149:			{
    #####: 1150:			s_tlsextstatus=1;
    #####: 1151:                        if (--argc < 1) goto bad;
    #####: 1152:			tlscstatp.timeout = atoi(*(++argv));
        -: 1153:			}
    #####: 1154:		else if (!strcmp(*argv, "-status_url"))
        -: 1155:			{
    #####: 1156:			s_tlsextstatus=1;
    #####: 1157:                        if (--argc < 1) goto bad;
    #####: 1158:			if (!OCSP_parse_url(*(++argv),
        -: 1159:					&tlscstatp.host,
        -: 1160:					&tlscstatp.port,
        -: 1161:					&tlscstatp.path,
        -: 1162:					&tlscstatp.use_ssl))
        -: 1163:				{
    #####: 1164:				BIO_printf(bio_err, "Error parsing URL\n");
    #####: 1165:				goto bad;
        -: 1166:				}
        -: 1167:			}
        -: 1168:#endif
    #####: 1169:		else if	(strcmp(*argv,"-msg") == 0)
    #####: 1170:			{ s_msg=1; }
    #####: 1171:		else if	(strcmp(*argv,"-hack") == 0)
    #####: 1172:			{ hack=1; }
    #####: 1173:		else if	(strcmp(*argv,"-state") == 0)
        -: 1174:			{ state=1; }
    #####: 1175:		else if	(strcmp(*argv,"-crlf") == 0)
    #####: 1176:			{ s_crlf=1; }
    #####: 1177:		else if	(strcmp(*argv,"-quiet") == 0)
    #####: 1178:			{ s_quiet=1; }
    #####: 1179:		else if	(strcmp(*argv,"-bugs") == 0)
        -: 1180:			{ bugs=1; }
    #####: 1181:		else if	(strcmp(*argv,"-no_tmp_rsa") == 0)
        -: 1182:			{ no_tmp_rsa=1; }
    #####: 1183:		else if	(strcmp(*argv,"-no_dhe") == 0)
        -: 1184:			{ no_dhe=1; }
    #####: 1185:		else if	(strcmp(*argv,"-no_ecdhe") == 0)
        -: 1186:			{ no_ecdhe=1; }
        -: 1187:#ifndef OPENSSL_NO_PSK
    #####: 1188:                else if (strcmp(*argv,"-psk_hint") == 0)
        -: 1189:			{
    #####: 1190:                        if (--argc < 1) goto bad;
    #####: 1191:                        psk_identity_hint= *(++argv);
        -: 1192:                        }
    #####: 1193:                else if (strcmp(*argv,"-psk") == 0)
        -: 1194:			{
        -: 1195:			size_t i;
        -: 1196:
    #####: 1197:			if (--argc < 1) goto bad;
    #####: 1198:			psk_key=*(++argv);
    #####: 1199:			for (i=0; i<strlen(psk_key); i++)
        -: 1200:				{
    #####: 1201:				if (isxdigit((unsigned char)psk_key[i]))
    #####: 1202:					continue;
    #####: 1203:				BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
    #####: 1204:				goto bad;
        -: 1205:				}
        -: 1206:			}
        -: 1207:#endif
        -: 1208:#ifndef OPENSSL_NO_SRP
    #####: 1209:		else if (strcmp(*argv, "-srpvfile") == 0)
        -: 1210:			{
    #####: 1211:			if (--argc < 1) goto bad;
    #####: 1212:			srp_verifier_file = *(++argv);
    #####: 1213:			meth = TLSv1_server_method();
        -: 1214:			}
    #####: 1215:		else if (strcmp(*argv, "-srpuserseed") == 0)
        -: 1216:			{
    #####: 1217:			if (--argc < 1) goto bad;
    #####: 1218:			srpuserseed = *(++argv);
    #####: 1219:			meth = TLSv1_server_method();
        -: 1220:			}
        -: 1221:#endif
    #####: 1222:		else if	(strcmp(*argv,"-www") == 0)
    #####: 1223:			{ www=1; }
    #####: 1224:		else if	(strcmp(*argv,"-WWW") == 0)
    #####: 1225:			{ www=2; }
    #####: 1226:		else if	(strcmp(*argv,"-HTTP") == 0)
    #####: 1227:			{ www=3; }
    #####: 1228:		else if	(strcmp(*argv,"-no_ssl2") == 0)
    #####: 1229:			{ off|=SSL_OP_NO_SSLv2; }
    #####: 1230:		else if	(strcmp(*argv,"-no_ssl3") == 0)
    #####: 1231:			{ off|=SSL_OP_NO_SSLv3; }
    #####: 1232:		else if	(strcmp(*argv,"-no_tls1") == 0)
    #####: 1233:			{ off|=SSL_OP_NO_TLSv1; }
    #####: 1234:		else if	(strcmp(*argv,"-no_tls1_1") == 0)
    #####: 1235:			{ off|=SSL_OP_NO_TLSv1_1; }
    #####: 1236:		else if	(strcmp(*argv,"-no_tls1_2") == 0)
    #####: 1237:			{ off|=SSL_OP_NO_TLSv1_2; }
    #####: 1238:		else if	(strcmp(*argv,"-no_comp") == 0)
    #####: 1239:			{ off|=SSL_OP_NO_COMPRESSION; }
        -: 1240:#ifndef OPENSSL_NO_TLSEXT
    #####: 1241:		else if	(strcmp(*argv,"-no_ticket") == 0)
    #####: 1242:			{ off|=SSL_OP_NO_TICKET; }
        -: 1243:#endif
        -: 1244:#ifndef OPENSSL_NO_SSL2
    #####: 1245:		else if	(strcmp(*argv,"-ssl2") == 0)
    #####: 1246:			{ meth=SSLv2_server_method(); }
        -: 1247:#endif
        -: 1248:#ifndef OPENSSL_NO_SSL3
    #####: 1249:		else if	(strcmp(*argv,"-ssl3") == 0)
    #####: 1250:			{ meth=SSLv3_server_method(); }
        -: 1251:#endif
        -: 1252:#ifndef OPENSSL_NO_TLS1
    #####: 1253:		else if	(strcmp(*argv,"-tls1") == 0)
    #####: 1254:			{ meth=TLSv1_server_method(); }
    #####: 1255:		else if	(strcmp(*argv,"-tls1_1") == 0)
    #####: 1256:			{ meth=TLSv1_1_server_method(); }
    #####: 1257:		else if	(strcmp(*argv,"-tls1_2") == 0)
    #####: 1258:			{ meth=TLSv1_2_server_method(); }
        -: 1259:#endif
        -: 1260:#ifndef OPENSSL_NO_DTLS1
    #####: 1261:		else if	(strcmp(*argv,"-dtls1") == 0)
        -: 1262:			{ 
    #####: 1263:			meth=DTLSv1_server_method();
        -: 1264:			socket_type = SOCK_DGRAM;
        -: 1265:			}
    #####: 1266:		else if (strcmp(*argv,"-timeout") == 0)
    #####: 1267:			enable_timeouts = 1;
    #####: 1268:		else if (strcmp(*argv,"-mtu") == 0)
        -: 1269:			{
    #####: 1270:			if (--argc < 1) goto bad;
    #####: 1271:			socket_mtu = atol(*(++argv));
        -: 1272:			}
    #####: 1273:		else if (strcmp(*argv, "-chain") == 0)
    #####: 1274:			cert_chain = 1;
        -: 1275:#endif
    #####: 1276:		else if (strcmp(*argv, "-id_prefix") == 0)
        -: 1277:			{
    #####: 1278:			if (--argc < 1) goto bad;
    #####: 1279:			session_id_prefix = *(++argv);
        -: 1280:			}
        -: 1281:#ifndef OPENSSL_NO_ENGINE
    #####: 1282:		else if (strcmp(*argv,"-engine") == 0)
        -: 1283:			{
    #####: 1284:			if (--argc < 1) goto bad;
    #####: 1285:			engine_id= *(++argv);
        -: 1286:			}
        -: 1287:#endif
    #####: 1288:		else if (strcmp(*argv,"-rand") == 0)
        -: 1289:			{
    #####: 1290:			if (--argc < 1) goto bad;
    #####: 1291:			inrand= *(++argv);
        -: 1292:			}
        -: 1293:#ifndef OPENSSL_NO_TLSEXT
    #####: 1294:		else if (strcmp(*argv,"-servername") == 0)
        -: 1295:			{
    #####: 1296:			if (--argc < 1) goto bad;
    #####: 1297:			tlsextcbp.servername= *(++argv);
        -: 1298:			}
    #####: 1299:		else if (strcmp(*argv,"-servername_fatal") == 0)
    #####: 1300:			{ tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL; }
    #####: 1301:		else if	(strcmp(*argv,"-cert2") == 0)
        -: 1302:			{
    #####: 1303:			if (--argc < 1) goto bad;
    #####: 1304:			s_cert_file2= *(++argv);
        -: 1305:			}
    #####: 1306:		else if	(strcmp(*argv,"-key2") == 0)
        -: 1307:			{
    #####: 1308:			if (--argc < 1) goto bad;
    #####: 1309:			s_key_file2= *(++argv);
        -: 1310:			}
        -: 1311:# ifndef OPENSSL_NO_NEXTPROTONEG
    #####: 1312:		else if	(strcmp(*argv,"-nextprotoneg") == 0)
        -: 1313:			{
    #####: 1314:			if (--argc < 1) goto bad;
    #####: 1315:			next_proto_neg_in = *(++argv);
        -: 1316:			}
        -: 1317:# endif
        -: 1318:#endif
        -: 1319:#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
        -: 1320:		else if (strcmp(*argv,"-jpake") == 0)
        -: 1321:			{
        -: 1322:			if (--argc < 1) goto bad;
        -: 1323:			jpake_secret = *(++argv);
        -: 1324:			}
        -: 1325:#endif
        -: 1326:#ifndef OPENSSL_NO_SRTP
    #####: 1327:		else if (strcmp(*argv,"-use_srtp") == 0)
        -: 1328:			{
    #####: 1329:			if (--argc < 1) goto bad;
    #####: 1330:			srtp_profiles = *(++argv);
        -: 1331:			}
        -: 1332:#endif
    #####: 1333:		else if (strcmp(*argv,"-keymatexport") == 0)
        -: 1334:			{
    #####: 1335:			if (--argc < 1) goto bad;
    #####: 1336:			keymatexportlabel= *(++argv);
        -: 1337:			}
    #####: 1338:		else if (strcmp(*argv,"-keymatexportlen") == 0)
        -: 1339:			{
    #####: 1340:			if (--argc < 1) goto bad;
    #####: 1341:			keymatexportlen=atoi(*(++argv));
    #####: 1342:			if (keymatexportlen == 0) goto bad;
        -: 1343:			}
        -: 1344:		else
        -: 1345:			{
    #####: 1346:			BIO_printf(bio_err,"unknown option %s\n",*argv);
        -: 1347:			badop=1;
    #####: 1348:			break;
        -: 1349:			}
    #####: 1350:		argc--;
    #####: 1351:		argv++;
        -: 1352:		}
    #####: 1353:	if (badop)
        -: 1354:		{
        -: 1355:bad:
    #####: 1356:		sv_usage();
    #####: 1357:		goto end;
        -: 1358:		}
        -: 1359:
        -: 1360:#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
        -: 1361:	if (jpake_secret)
        -: 1362:		{
        -: 1363:		if (psk_key)
        -: 1364:			{
        -: 1365:			BIO_printf(bio_err,
        -: 1366:				   "Can't use JPAKE and PSK together\n");
        -: 1367:			goto end;
        -: 1368:			}
        -: 1369:		psk_identity = "JPAKE";
        -: 1370:		if (cipher)
        -: 1371:			{
        -: 1372:			BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
        -: 1373:			goto end;
        -: 1374:			}
        -: 1375:		cipher = "PSK";
        -: 1376:		}
        -: 1377:
        -: 1378:#endif
        -: 1379:
    #####: 1380:	SSL_load_error_strings();
    #####: 1381:	OpenSSL_add_ssl_algorithms();
        -: 1382:
        -: 1383:#ifndef OPENSSL_NO_ENGINE
    #####: 1384:        e = setup_engine(bio_err, engine_id, 1);
        -: 1385:#endif
        -: 1386:
    #####: 1387:	if (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass))
        -: 1388:		{
    #####: 1389:		BIO_printf(bio_err, "Error getting password\n");
    #####: 1390:		goto end;
        -: 1391:		}
        -: 1392:
        -: 1393:
    #####: 1394:	if (s_key_file == NULL)
    #####: 1395:		s_key_file = s_cert_file;
        -: 1396:#ifndef OPENSSL_NO_TLSEXT
    #####: 1397:	if (s_key_file2 == NULL)
    #####: 1398:		s_key_file2 = s_cert_file2;
        -: 1399:#endif
        -: 1400:
    #####: 1401:	if (nocert == 0)
        -: 1402:		{
    #####: 1403:		s_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,
        -: 1404:		       "server certificate private key file");
    #####: 1405:		if (!s_key)
        -: 1406:			{
    #####: 1407:			ERR_print_errors(bio_err);
    #####: 1408:			goto end;
        -: 1409:			}
        -: 1410:
    #####: 1411:		s_cert = load_cert(bio_err,s_cert_file,s_cert_format,
        -: 1412:			NULL, e, "server certificate file");
        -: 1413:
    #####: 1414:		if (!s_cert)
        -: 1415:			{
    #####: 1416:			ERR_print_errors(bio_err);
    #####: 1417:			goto end;
        -: 1418:			}
        -: 1419:
        -: 1420:#ifndef OPENSSL_NO_TLSEXT
    #####: 1421:		if (tlsextcbp.servername) 
        -: 1422:			{
    #####: 1423:			s_key2 = load_key(bio_err, s_key_file2, s_key_format, 0, pass, e,
        -: 1424:				"second server certificate private key file");
    #####: 1425:			if (!s_key2)
        -: 1426:				{
    #####: 1427:				ERR_print_errors(bio_err);
    #####: 1428:				goto end;
        -: 1429:				}
        -: 1430:			
    #####: 1431:			s_cert2 = load_cert(bio_err,s_cert_file2,s_cert_format,
        -: 1432:				NULL, e, "second server certificate file");
        -: 1433:			
    #####: 1434:			if (!s_cert2)
        -: 1435:				{
    #####: 1436:				ERR_print_errors(bio_err);
    #####: 1437:				goto end;
        -: 1438:				}
        -: 1439:			}
        -: 1440:#endif
        -: 1441:		}
        -: 1442:
        -: 1443:#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG) 
    #####: 1444:	if (next_proto_neg_in)
        -: 1445:		{
        -: 1446:		unsigned short len;
    #####: 1447:		next_proto.data = next_protos_parse(&len, next_proto_neg_in);
    #####: 1448:		if (next_proto.data == NULL)
        -: 1449:			goto end;
    #####: 1450:		next_proto.len = len;
        -: 1451:		}
        -: 1452:	else
        -: 1453:		{
    #####: 1454:		next_proto.data = NULL;
        -: 1455:		}
        -: 1456:#endif
        -: 1457:
        -: 1458:
    #####: 1459:	if (s_dcert_file)
        -: 1460:		{
        -: 1461:
    #####: 1462:		if (s_dkey_file == NULL)
    #####: 1463:			s_dkey_file = s_dcert_file;
        -: 1464:
    #####: 1465:		s_dkey = load_key(bio_err, s_dkey_file, s_dkey_format,
        -: 1466:				0, dpass, e,
        -: 1467:			       "second certificate private key file");
    #####: 1468:		if (!s_dkey)
        -: 1469:			{
    #####: 1470:			ERR_print_errors(bio_err);
    #####: 1471:			goto end;
        -: 1472:			}
        -: 1473:
    #####: 1474:		s_dcert = load_cert(bio_err,s_dcert_file,s_dcert_format,
        -: 1475:				NULL, e, "second server certificate file");
        -: 1476:
    #####: 1477:		if (!s_dcert)
        -: 1478:			{
    #####: 1479:			ERR_print_errors(bio_err);
    #####: 1480:			goto end;
        -: 1481:			}
        -: 1482:
        -: 1483:		}
        -: 1484:
    #####: 1485:	if (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL
    #####: 1486:		&& !RAND_status())
        -: 1487:		{
    #####: 1488:		BIO_printf(bio_err,"warning, not much extra random data, consider using the -rand option\n");
        -: 1489:		}
    #####: 1490:	if (inrand != NULL)
    #####: 1491:		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
        -: 1492:			app_RAND_load_files(inrand));
        -: 1493:
    #####: 1494:	if (bio_s_out == NULL)
        -: 1495:		{
    #####: 1496:		if (s_quiet && !s_debug && !s_msg)
        -: 1497:			{
    #####: 1498:			bio_s_out=BIO_new(BIO_s_null());
        -: 1499:			}
        -: 1500:		else
        -: 1501:			{
    #####: 1502:			if (bio_s_out == NULL)
    #####: 1503:				bio_s_out=BIO_new_fp(stdout,BIO_NOCLOSE);
        -: 1504:			}
        -: 1505:		}
        -: 1506:
        -: 1507:#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
    #####: 1508:	if (nocert)
        -: 1509:#endif
        -: 1510:		{
    #####: 1511:		s_cert_file=NULL;
    #####: 1512:		s_key_file=NULL;
    #####: 1513:		s_dcert_file=NULL;
    #####: 1514:		s_dkey_file=NULL;
        -: 1515:#ifndef OPENSSL_NO_TLSEXT
    #####: 1516:		s_cert_file2=NULL;
    #####: 1517:		s_key_file2=NULL;
        -: 1518:#endif
        -: 1519:		}
        -: 1520:
    #####: 1521:	ctx=SSL_CTX_new(meth);
    #####: 1522:	if (ctx == NULL)
        -: 1523:		{
    #####: 1524:		ERR_print_errors(bio_err);
    #####: 1525:		goto end;
        -: 1526:		}
    #####: 1527:	if (session_id_prefix)
        -: 1528:		{
    #####: 1529:		if(strlen(session_id_prefix) >= 32)
    #####: 1530:			BIO_printf(bio_err,
        -: 1531:"warning: id_prefix is too long, only one new session will be possible\n");
    #####: 1532:		else if(strlen(session_id_prefix) >= 16)
    #####: 1533:			BIO_printf(bio_err,
        -: 1534:"warning: id_prefix is too long if you use SSLv2\n");
    #####: 1535:		if(!SSL_CTX_set_generate_session_id(ctx, generate_session_id))
        -: 1536:			{
    #####: 1537:			BIO_printf(bio_err,"error setting 'id_prefix'\n");
    #####: 1538:			ERR_print_errors(bio_err);
    #####: 1539:			goto end;
        -: 1540:			}
    #####: 1541:		BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
        -: 1542:		}
    #####: 1543:	SSL_CTX_set_quiet_shutdown(ctx,1);
    #####: 1544:	if (bugs) SSL_CTX_set_options(ctx,SSL_OP_ALL);
    #####: 1545:	if (hack) SSL_CTX_set_options(ctx,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
    #####: 1546:	SSL_CTX_set_options(ctx,off);
        -: 1547:	/* DTLS: partial reads end up discarding unread UDP bytes :-( 
        -: 1548:	 * Setting read ahead solves this problem.
        -: 1549:	 */
    #####: 1550:	if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
        -: 1551:
    #####: 1552:	if (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);
    #####: 1553:	if (no_cache)
    #####: 1554:		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
        -: 1555:	else
    #####: 1556:		SSL_CTX_sess_set_cache_size(ctx,128);
        -: 1557:
        -: 1558:#ifndef OPENSSL_NO_SRTP
    #####: 1559:	if (srtp_profiles != NULL)
    #####: 1560:		SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);
        -: 1561:#endif
        -: 1562:
        -: 1563:#if 0
        -: 1564:	if (cipher == NULL) cipher=getenv("SSL_CIPHER");
        -: 1565:#endif
        -: 1566:
        -: 1567:#if 0
        -: 1568:	if (s_cert_file == NULL)
        -: 1569:		{
        -: 1570:		BIO_printf(bio_err,"You must specify a certificate file for the server to use\n");
        -: 1571:		goto end;
        -: 1572:		}
        -: 1573:#endif
        -: 1574:
    #####: 1575:	if ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||
    #####: 1576:		(!SSL_CTX_set_default_verify_paths(ctx)))
        -: 1577:		{
        -: 1578:		/* BIO_printf(bio_err,"X509_load_verify_locations\n"); */
    #####: 1579:		ERR_print_errors(bio_err);
        -: 1580:		/* goto end; */
        -: 1581:		}
    #####: 1582:	if (vpm)
    #####: 1583:		SSL_CTX_set1_param(ctx, vpm);
        -: 1584:
        -: 1585:#ifndef OPENSSL_NO_TLSEXT
    #####: 1586:	if (s_cert2)
        -: 1587:		{
    #####: 1588:		ctx2=SSL_CTX_new(meth);
    #####: 1589:		if (ctx2 == NULL)
        -: 1590:			{
    #####: 1591:			ERR_print_errors(bio_err);
    #####: 1592:			goto end;
        -: 1593:			}
        -: 1594:		}
        -: 1595:	
    #####: 1596:	if (ctx2)
        -: 1597:		{
    #####: 1598:		BIO_printf(bio_s_out,"Setting secondary ctx parameters\n");
        -: 1599:
    #####: 1600:		if (session_id_prefix)
        -: 1601:			{
    #####: 1602:			if(strlen(session_id_prefix) >= 32)
    #####: 1603:				BIO_printf(bio_err,
        -: 1604:					"warning: id_prefix is too long, only one new session will be possible\n");
    #####: 1605:			else if(strlen(session_id_prefix) >= 16)
    #####: 1606:				BIO_printf(bio_err,
        -: 1607:					"warning: id_prefix is too long if you use SSLv2\n");
    #####: 1608:			if(!SSL_CTX_set_generate_session_id(ctx2, generate_session_id))
        -: 1609:				{
    #####: 1610:				BIO_printf(bio_err,"error setting 'id_prefix'\n");
    #####: 1611:				ERR_print_errors(bio_err);
    #####: 1612:				goto end;
        -: 1613:				}
    #####: 1614:			BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
        -: 1615:			}
    #####: 1616:		SSL_CTX_set_quiet_shutdown(ctx2,1);
    #####: 1617:		if (bugs) SSL_CTX_set_options(ctx2,SSL_OP_ALL);
    #####: 1618:		if (hack) SSL_CTX_set_options(ctx2,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
    #####: 1619:		SSL_CTX_set_options(ctx2,off);
        -: 1620:		/* DTLS: partial reads end up discarding unread UDP bytes :-( 
        -: 1621:		 * Setting read ahead solves this problem.
        -: 1622:		 */
    #####: 1623:		if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx2, 1);
        -: 1624:
    #####: 1625:		if (state) SSL_CTX_set_info_callback(ctx2,apps_ssl_info_callback);
        -: 1626:
    #####: 1627:		if (no_cache)
    #####: 1628:			SSL_CTX_set_session_cache_mode(ctx2,SSL_SESS_CACHE_OFF);
        -: 1629:		else
    #####: 1630:			SSL_CTX_sess_set_cache_size(ctx2,128);
        -: 1631:
    #####: 1632:		if ((!SSL_CTX_load_verify_locations(ctx2,CAfile,CApath)) ||
    #####: 1633:			(!SSL_CTX_set_default_verify_paths(ctx2)))
        -: 1634:			{
    #####: 1635:			ERR_print_errors(bio_err);
        -: 1636:			}
    #####: 1637:		if (vpm)
    #####: 1638:			SSL_CTX_set1_param(ctx2, vpm);
        -: 1639:		}
        -: 1640:
        -: 1641:# ifndef OPENSSL_NO_NEXTPROTONEG
    #####: 1642:	if (next_proto.data)
    #####: 1643:		SSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb, &next_proto);
        -: 1644:# endif
        -: 1645:#endif 
        -: 1646:
        -: 1647:#ifndef OPENSSL_NO_DH
    #####: 1648:	if (!no_dhe)
        -: 1649:		{
        -: 1650:		DH *dh=NULL;
        -: 1651:
    #####: 1652:		if (dhfile)
    #####: 1653:			dh = load_dh_param(dhfile);
    #####: 1654:		else if (s_cert_file)
    #####: 1655:			dh = load_dh_param(s_cert_file);
        -: 1656:
    #####: 1657:		if (dh != NULL)
        -: 1658:			{
    #####: 1659:			BIO_printf(bio_s_out,"Setting temp DH parameters\n");
        -: 1660:			}
        -: 1661:		else
        -: 1662:			{
    #####: 1663:			BIO_printf(bio_s_out,"Using default temp DH parameters\n");
    #####: 1664:			dh=get_dh512();
        -: 1665:			}
    #####: 1666:		(void)BIO_flush(bio_s_out);
        -: 1667:
    #####: 1668:		SSL_CTX_set_tmp_dh(ctx,dh);
        -: 1669:#ifndef OPENSSL_NO_TLSEXT
    #####: 1670:		if (ctx2)
        -: 1671:			{
    #####: 1672:			if (!dhfile)
        -: 1673:				{ 
    #####: 1674:				DH *dh2=load_dh_param(s_cert_file2);
    #####: 1675:				if (dh2 != NULL)
        -: 1676:					{
    #####: 1677:					BIO_printf(bio_s_out,"Setting temp DH parameters\n");
    #####: 1678:					(void)BIO_flush(bio_s_out);
        -: 1679:
    #####: 1680:					DH_free(dh);
        -: 1681:					dh = dh2;
        -: 1682:					}
        -: 1683:				}
    #####: 1684:			SSL_CTX_set_tmp_dh(ctx2,dh);
        -: 1685:			}
        -: 1686:#endif
    #####: 1687:		DH_free(dh);
        -: 1688:		}
        -: 1689:#endif
        -: 1690:
        -: 1691:#ifndef OPENSSL_NO_ECDH
    #####: 1692:	if (!no_ecdhe)
        -: 1693:		{
        -: 1694:		EC_KEY *ecdh=NULL;
        -: 1695:
    #####: 1696:		if (named_curve)
        -: 1697:			{
    #####: 1698:			int nid = OBJ_sn2nid(named_curve);
        -: 1699:
    #####: 1700:			if (nid == 0)
        -: 1701:				{
    #####: 1702:				BIO_printf(bio_err, "unknown curve name (%s)\n", 
        -: 1703:					named_curve);
    #####: 1704:				goto end;
        -: 1705:				}
    #####: 1706:			ecdh = EC_KEY_new_by_curve_name(nid);
    #####: 1707:			if (ecdh == NULL)
        -: 1708:				{
    #####: 1709:				BIO_printf(bio_err, "unable to create curve (%s)\n", 
        -: 1710:					named_curve);
    #####: 1711:				goto end;
        -: 1712:				}
        -: 1713:			}
        -: 1714:
    #####: 1715:		if (ecdh != NULL)
        -: 1716:			{
    #####: 1717:			BIO_printf(bio_s_out,"Setting temp ECDH parameters\n");
        -: 1718:			}
        -: 1719:		else
        -: 1720:			{
    #####: 1721:			BIO_printf(bio_s_out,"Using default temp ECDH parameters\n");
    #####: 1722:			ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
    #####: 1723:			if (ecdh == NULL) 
        -: 1724:				{
    #####: 1725:				BIO_printf(bio_err, "unable to create curve (nistp256)\n");
    #####: 1726:				goto end;
        -: 1727:				}
        -: 1728:			}
    #####: 1729:		(void)BIO_flush(bio_s_out);
        -: 1730:
    #####: 1731:		SSL_CTX_set_tmp_ecdh(ctx,ecdh);
        -: 1732:#ifndef OPENSSL_NO_TLSEXT
    #####: 1733:		if (ctx2) 
    #####: 1734:			SSL_CTX_set_tmp_ecdh(ctx2,ecdh);
        -: 1735:#endif
    #####: 1736:		EC_KEY_free(ecdh);
        -: 1737:		}
        -: 1738:#endif
        -: 1739:	
    #####: 1740:	if (!set_cert_key_stuff(ctx, s_cert, s_key))
        -: 1741:		goto end;
        -: 1742:#ifndef OPENSSL_NO_TLSEXT
    #####: 1743:	if (ctx2 && !set_cert_key_stuff(ctx2,s_cert2,s_key2))
        -: 1744:		goto end; 
        -: 1745:#endif
    #####: 1746:	if (s_dcert != NULL)
        -: 1747:		{
    #####: 1748:		if (!set_cert_key_stuff(ctx, s_dcert, s_dkey))
        -: 1749:			goto end;
        -: 1750:		}
        -: 1751:
        -: 1752:#ifndef OPENSSL_NO_RSA
        -: 1753:#if 1
    #####: 1754:	if (!no_tmp_rsa)
        -: 1755:		{
    #####: 1756:		SSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);
        -: 1757:#ifndef OPENSSL_NO_TLSEXT
    #####: 1758:		if (ctx2) 
    #####: 1759:			SSL_CTX_set_tmp_rsa_callback(ctx2,tmp_rsa_cb);
        -: 1760:#endif		
        -: 1761:		}
        -: 1762:#else
        -: 1763:	if (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx))
        -: 1764:		{
        -: 1765:		RSA *rsa;
        -: 1766:
        -: 1767:		BIO_printf(bio_s_out,"Generating temp (512 bit) RSA key...");
        -: 1768:		BIO_flush(bio_s_out);
        -: 1769:
        -: 1770:		rsa=RSA_generate_key(512,RSA_F4,NULL);
        -: 1771:
        -: 1772:		if (!SSL_CTX_set_tmp_rsa(ctx,rsa))
        -: 1773:			{
        -: 1774:			ERR_print_errors(bio_err);
        -: 1775:			goto end;
        -: 1776:			}
        -: 1777:#ifndef OPENSSL_NO_TLSEXT
        -: 1778:			if (ctx2)
        -: 1779:				{
        -: 1780:				if (!SSL_CTX_set_tmp_rsa(ctx2,rsa))
        -: 1781:					{
        -: 1782:					ERR_print_errors(bio_err);
        -: 1783:					goto end;
        -: 1784:					}
        -: 1785:				}
        -: 1786:#endif
        -: 1787:		RSA_free(rsa);
        -: 1788:		BIO_printf(bio_s_out,"\n");
        -: 1789:		}
        -: 1790:#endif
        -: 1791:#endif
        -: 1792:
        -: 1793:#ifndef OPENSSL_NO_PSK
        -: 1794:#ifdef OPENSSL_NO_JPAKE
    #####: 1795:	if (psk_key != NULL)
        -: 1796:#else
        -: 1797:	if (psk_key != NULL || jpake_secret)
        -: 1798:#endif
        -: 1799:		{
    #####: 1800:		if (s_debug)
    #####: 1801:			BIO_printf(bio_s_out, "PSK key given or JPAKE in use, setting server callback\n");
    #####: 1802:		SSL_CTX_set_psk_server_callback(ctx, psk_server_cb);
        -: 1803:		}
        -: 1804:
    #####: 1805:	if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint))
        -: 1806:		{
    #####: 1807:		BIO_printf(bio_err,"error setting PSK identity hint to context\n");
    #####: 1808:		ERR_print_errors(bio_err);
    #####: 1809:		goto end;
        -: 1810:		}
        -: 1811:#endif
        -: 1812:
    #####: 1813:	if (cipher != NULL)
        -: 1814:		{
    #####: 1815:		if(!SSL_CTX_set_cipher_list(ctx,cipher))
        -: 1816:			{
    #####: 1817:			BIO_printf(bio_err,"error setting cipher list\n");
    #####: 1818:			ERR_print_errors(bio_err);
    #####: 1819:			goto end;
        -: 1820:			}
        -: 1821:#ifndef OPENSSL_NO_TLSEXT
    #####: 1822:		if (ctx2 && !SSL_CTX_set_cipher_list(ctx2,cipher))
        -: 1823:			{
    #####: 1824:			BIO_printf(bio_err,"error setting cipher list\n");
    #####: 1825:			ERR_print_errors(bio_err);
    #####: 1826:			goto end;
        -: 1827:			}
        -: 1828:#endif
        -: 1829:		}
    #####: 1830:	SSL_CTX_set_verify(ctx,s_server_verify,verify_callback);
    #####: 1831:	SSL_CTX_set_session_id_context(ctx,(void*)&s_server_session_id_context,
        -: 1832:		sizeof s_server_session_id_context);
        -: 1833:
        -: 1834:	/* Set DTLS cookie generation and verification callbacks */
    #####: 1835:	SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);
    #####: 1836:	SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);
        -: 1837:
        -: 1838:#ifndef OPENSSL_NO_TLSEXT
    #####: 1839:	if (ctx2)
        -: 1840:		{
    #####: 1841:		SSL_CTX_set_verify(ctx2,s_server_verify,verify_callback);
    #####: 1842:		SSL_CTX_set_session_id_context(ctx2,(void*)&s_server_session_id_context,
        -: 1843:			sizeof s_server_session_id_context);
        -: 1844:
    #####: 1845:		tlsextcbp.biodebug = bio_s_out;
    #####: 1846:		SSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);
    #####: 1847:		SSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);
    #####: 1848:		SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
    #####: 1849:		SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);
        -: 1850:		}
        -: 1851:#endif
        -: 1852:
        -: 1853:#ifndef OPENSSL_NO_SRP
    #####: 1854:	if (srp_verifier_file != NULL)
        -: 1855:		{
    #####: 1856:		srp_callback_parm.vb = SRP_VBASE_new(srpuserseed);
    #####: 1857:		srp_callback_parm.user = NULL;
    #####: 1858:		srp_callback_parm.login = NULL;
    #####: 1859:		if ((ret = SRP_VBASE_init(srp_callback_parm.vb, srp_verifier_file)) != SRP_NO_ERROR)
        -: 1860:			{
    #####: 1861:			BIO_printf(bio_err,
        -: 1862:				   "Cannot initialize SRP verifier file \"%s\":ret=%d\n",
        -: 1863:				   srp_verifier_file, ret);
    #####: 1864:				goto end;
        -: 1865:			}
    #####: 1866:		SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE,verify_callback);
    #####: 1867:		SSL_CTX_set_srp_cb_arg(ctx, &srp_callback_parm);  			
    #####: 1868:		SSL_CTX_set_srp_username_callback(ctx, ssl_srp_server_param_cb);
        -: 1869:		}
        -: 1870:	else
        -: 1871:#endif
    #####: 1872:	if (CAfile != NULL)
        -: 1873:		{
    #####: 1874:		SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));
        -: 1875:#ifndef OPENSSL_NO_TLSEXT
    #####: 1876:		if (ctx2) 
    #####: 1877:			SSL_CTX_set_client_CA_list(ctx2,SSL_load_client_CA_file(CAfile));
        -: 1878:#endif
        -: 1879:		}
        -: 1880:
    #####: 1881:	BIO_printf(bio_s_out,"ACCEPT\n");
    #####: 1882:	(void)BIO_flush(bio_s_out);
    #####: 1883:	if (www)
    #####: 1884:		do_server(port,socket_type,&accept_socket,www_body, context);
        -: 1885:	else
    #####: 1886:		do_server(port,socket_type,&accept_socket,sv_body, context);
    #####: 1887:	print_stats(bio_s_out,ctx);
        -: 1888:	ret=0;
        -: 1889:end:
    #####: 1890:	if (ctx != NULL) SSL_CTX_free(ctx);
    #####: 1891:	if (s_cert)
    #####: 1892:		X509_free(s_cert);
    #####: 1893:	if (s_dcert)
    #####: 1894:		X509_free(s_dcert);
    #####: 1895:	if (s_key)
    #####: 1896:		EVP_PKEY_free(s_key);
    #####: 1897:	if (s_dkey)
    #####: 1898:		EVP_PKEY_free(s_dkey);
    #####: 1899:	if (pass)
    #####: 1900:		OPENSSL_free(pass);
    #####: 1901:	if (dpass)
    #####: 1902:		OPENSSL_free(dpass);
    #####: 1903:	if (vpm)
    #####: 1904:		X509_VERIFY_PARAM_free(vpm);
        -: 1905:#ifndef OPENSSL_NO_TLSEXT
    #####: 1906:	if (tlscstatp.host)
    #####: 1907:		OPENSSL_free(tlscstatp.host);
    #####: 1908:	if (tlscstatp.port)
    #####: 1909:		OPENSSL_free(tlscstatp.port);
    #####: 1910:	if (tlscstatp.path)
    #####: 1911:		OPENSSL_free(tlscstatp.path);
    #####: 1912:	if (ctx2 != NULL) SSL_CTX_free(ctx2);
    #####: 1913:	if (s_cert2)
    #####: 1914:		X509_free(s_cert2);
    #####: 1915:	if (s_key2)
    #####: 1916:		EVP_PKEY_free(s_key2);
        -: 1917:#endif
    #####: 1918:	if (bio_s_out != NULL)
        -: 1919:		{
    #####: 1920:        BIO_free(bio_s_out);
    #####: 1921:		bio_s_out=NULL;
        -: 1922:		}
        -: 1923:	apps_shutdown();
    #####: 1924:	OPENSSL_EXIT(ret);
        -: 1925:	}
        -: 1926:
    #####: 1927:static void print_stats(BIO *bio, SSL_CTX *ssl_ctx)
        -: 1928:	{
    #####: 1929:	BIO_printf(bio,"%4ld items in the session cache\n",
        -: 1930:		SSL_CTX_sess_number(ssl_ctx));
    #####: 1931:	BIO_printf(bio,"%4ld client connects (SSL_connect())\n",
        -: 1932:		SSL_CTX_sess_connect(ssl_ctx));
    #####: 1933:	BIO_printf(bio,"%4ld client renegotiates (SSL_connect())\n",
        -: 1934:		SSL_CTX_sess_connect_renegotiate(ssl_ctx));
    #####: 1935:	BIO_printf(bio,"%4ld client connects that finished\n",
        -: 1936:		SSL_CTX_sess_connect_good(ssl_ctx));
    #####: 1937:	BIO_printf(bio,"%4ld server accepts (SSL_accept())\n",
        -: 1938:		SSL_CTX_sess_accept(ssl_ctx));
    #####: 1939:	BIO_printf(bio,"%4ld server renegotiates (SSL_accept())\n",
        -: 1940:		SSL_CTX_sess_accept_renegotiate(ssl_ctx));
    #####: 1941:	BIO_printf(bio,"%4ld server accepts that finished\n",
        -: 1942:		SSL_CTX_sess_accept_good(ssl_ctx));
    #####: 1943:	BIO_printf(bio,"%4ld session cache hits\n",SSL_CTX_sess_hits(ssl_ctx));
    #####: 1944:	BIO_printf(bio,"%4ld session cache misses\n",SSL_CTX_sess_misses(ssl_ctx));
    #####: 1945:	BIO_printf(bio,"%4ld session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx));
    #####: 1946:	BIO_printf(bio,"%4ld callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx));
    #####: 1947:	BIO_printf(bio,"%4ld cache full overflows (%ld allowed)\n",
        -: 1948:		SSL_CTX_sess_cache_full(ssl_ctx),
        -: 1949:		SSL_CTX_sess_get_cache_size(ssl_ctx));
    #####: 1950:	}
        -: 1951:
    #####: 1952:static int sv_body(char *hostname, int s, unsigned char *context)
        -: 1953:	{
        -: 1954:	char *buf=NULL;
        -: 1955:	fd_set readfds;
        -: 1956:	int ret=1,width;
        -: 1957:	int k,i;
        -: 1958:	unsigned long l;
        -: 1959:	SSL *con=NULL;
        -: 1960:	BIO *sbio;
        -: 1961:#ifndef OPENSSL_NO_KRB5
        -: 1962:	KSSL_CTX *kctx;
        -: 1963:#endif
        -: 1964:	struct timeval timeout;
        -: 1965:#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
        -: 1966:	struct timeval tv;
        -: 1967:#else
        -: 1968:	struct timeval *timeoutp;
        -: 1969:#endif
        -: 1970:
    #####: 1971:	if ((buf=OPENSSL_malloc(bufsize)) == NULL)
        -: 1972:		{
    #####: 1973:		BIO_printf(bio_err,"out of memory\n");
    #####: 1974:		goto err;
        -: 1975:		}
        -: 1976:#ifdef FIONBIO	
    #####: 1977:	if (s_nbio)
        -: 1978:		{
    #####: 1979:		unsigned long sl=1;
        -: 1980:
    #####: 1981:		if (!s_quiet)
    #####: 1982:			BIO_printf(bio_err,"turning on non blocking io\n");
    #####: 1983:		if (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)
    #####: 1984:			ERR_print_errors(bio_err);
        -: 1985:		}
        -: 1986:#endif
        -: 1987:
        -: 1988:	if (con == NULL) {
    #####: 1989:		con=SSL_new(ctx);
        -: 1990:#ifndef OPENSSL_NO_TLSEXT
    #####: 1991:	if (s_tlsextdebug)
        -: 1992:		{
    #####: 1993:		SSL_set_tlsext_debug_callback(con, tlsext_cb);
    #####: 1994:		SSL_set_tlsext_debug_arg(con, bio_s_out);
        -: 1995:		}
    #####: 1996:	if (s_tlsextstatus)
        -: 1997:		{
    #####: 1998:		SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);
    #####: 1999:		tlscstatp.err = bio_err;
    #####: 2000:		SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);
        -: 2001:		}
        -: 2002:#endif
        -: 2003:#ifndef OPENSSL_NO_KRB5
        -: 2004:		if ((kctx = kssl_ctx_new()) != NULL)
        -: 2005:                        {
        -: 2006:			SSL_set0_kssl_ctx(con, kctx);
        -: 2007:                        kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
        -: 2008:                        kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
        -: 2009:                        }
        -: 2010:#endif	/* OPENSSL_NO_KRB5 */
    #####: 2011:		if(context)
    #####: 2012:		      SSL_set_session_id_context(con, context,
    #####: 2013:						 strlen((char *)context));
        -: 2014:	}
    #####: 2015:	SSL_clear(con);
        -: 2016:#if 0
        -: 2017:#ifdef TLSEXT_TYPE_opaque_prf_input
        -: 2018:	SSL_set_tlsext_opaque_prf_input(con, "Test server", 11);
        -: 2019:#endif
        -: 2020:#endif
        -: 2021:
    #####: 2022:	if (SSL_version(con) == DTLS1_VERSION)
        -: 2023:		{
        -: 2024:
    #####: 2025:		sbio=BIO_new_dgram(s,BIO_NOCLOSE);
        -: 2026:
    #####: 2027:		if (enable_timeouts)
        -: 2028:			{
    #####: 2029:			timeout.tv_sec = 0;
    #####: 2030:			timeout.tv_usec = DGRAM_RCV_TIMEOUT;
    #####: 2031:			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);
        -: 2032:			
    #####: 2033:			timeout.tv_sec = 0;
    #####: 2034:			timeout.tv_usec = DGRAM_SND_TIMEOUT;
    #####: 2035:			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);
        -: 2036:			}
        -: 2037:
    #####: 2038:		if (socket_mtu > 28)
        -: 2039:			{
    #####: 2040:			SSL_set_options(con, SSL_OP_NO_QUERY_MTU);
    #####: 2041:			SSL_set_mtu(con, socket_mtu - 28);
        -: 2042:			}
        -: 2043:		else
        -: 2044:			/* want to do MTU discovery */
    #####: 2045:			BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);
        -: 2046:
        -: 2047:        /* turn on cookie exchange */
    #####: 2048:        SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);
        -: 2049:		}
        -: 2050:	else
    #####: 2051:		sbio=BIO_new_socket(s,BIO_NOCLOSE);
        -: 2052:
    #####: 2053:	if (s_nbio_test)
        -: 2054:		{
        -: 2055:		BIO *test;
        -: 2056:
    #####: 2057:		test=BIO_new(BIO_f_nbio_test());
    #####: 2058:		sbio=BIO_push(test,sbio);
        -: 2059:		}
        -: 2060:#ifndef OPENSSL_NO_JPAKE
        -: 2061:	if(jpake_secret)
        -: 2062:		jpake_server_auth(bio_s_out, sbio, jpake_secret);
        -: 2063:#endif
        -: 2064:
    #####: 2065:	SSL_set_bio(con,sbio,sbio);
    #####: 2066:	SSL_set_accept_state(con);
        -: 2067:	/* SSL_set_fd(con,s); */
        -: 2068:
    #####: 2069:	if (s_debug)
        -: 2070:		{
    #####: 2071:		SSL_set_debug(con, 1);
    #####: 2072:		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
    #####: 2073:		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
        -: 2074:		}
    #####: 2075:	if (s_msg)
        -: 2076:		{
    #####: 2077:		SSL_set_msg_callback(con, msg_cb);
    #####: 2078:		SSL_set_msg_callback_arg(con, bio_s_out);
        -: 2079:		}
        -: 2080:#ifndef OPENSSL_NO_TLSEXT
    #####: 2081:	if (s_tlsextdebug)
        -: 2082:		{
    #####: 2083:		SSL_set_tlsext_debug_callback(con, tlsext_cb);
    #####: 2084:		SSL_set_tlsext_debug_arg(con, bio_s_out);
        -: 2085:		}
        -: 2086:#endif
        -: 2087:
    #####: 2088:	width=s+1;
        -: 2089:	for (;;)
        -: 2090:		{
        -: 2091:		int read_from_terminal;
        -: 2092:		int read_from_sslcon;
        -: 2093:
        -: 2094:		read_from_terminal = 0;
    #####: 2095:		read_from_sslcon = SSL_pending(con);
        -: 2096:
    #####: 2097:		if (!read_from_sslcon)
        -: 2098:			{
    #####: 2099:			FD_ZERO(&readfds);
        -: 2100:#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)
    #####: 2101:			openssl_fdset(fileno(stdin),&readfds);
        -: 2102:#endif
    #####: 2103:			openssl_fdset(s,&readfds);
        -: 2104:			/* Note: under VMS with SOCKETSHR the second parameter is
        -: 2105:			 * currently of type (int *) whereas under other systems
        -: 2106:			 * it is (void *) if you don't have a cast it will choke
        -: 2107:			 * the compiler: if you do have a cast then you can either
        -: 2108:			 * go for (int *) or (void *).
        -: 2109:			 */
        -: 2110:#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
        -: 2111:                        /* Under DOS (non-djgpp) and Windows we can't select on stdin: only
        -: 2112:			 * on sockets. As a workaround we timeout the select every
        -: 2113:			 * second and check for any keypress. In a proper Windows
        -: 2114:			 * application we wouldn't do this because it is inefficient.
        -: 2115:			 */
        -: 2116:			tv.tv_sec = 1;
        -: 2117:			tv.tv_usec = 0;
        -: 2118:			i=select(width,(void *)&readfds,NULL,NULL,&tv);
        -: 2119:			if((i < 0) || (!i && !_kbhit() ) )continue;
        -: 2120:			if(_kbhit())
        -: 2121:				read_from_terminal = 1;
        -: 2122:#elif defined(OPENSSL_SYS_BEOS_R5)
        -: 2123:			/* Under BeOS-R5 the situation is similar to DOS */
        -: 2124:			tv.tv_sec = 1;
        -: 2125:			tv.tv_usec = 0;
        -: 2126:			(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
        -: 2127:			i=select(width,(void *)&readfds,NULL,NULL,&tv);
        -: 2128:			if ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))
        -: 2129:				continue;
        -: 2130:			if (read(fileno(stdin), buf, 0) >= 0)
        -: 2131:				read_from_terminal = 1;
        -: 2132:			(void)fcntl(fileno(stdin), F_SETFL, 0);
        -: 2133:#else
    #####: 2134:			if ((SSL_version(con) == DTLS1_VERSION) &&
    #####: 2135:				DTLSv1_get_timeout(con, &timeout))
        -: 2136:				timeoutp = &timeout;
        -: 2137:			else
        -: 2138:				timeoutp = NULL;
        -: 2139:
    #####: 2140:			i=select(width,(void *)&readfds,NULL,NULL,timeoutp);
        -: 2141:
    #####: 2142:			if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0)
        -: 2143:				{
    #####: 2144:				BIO_printf(bio_err,"TIMEOUT occured\n");
        -: 2145:				}
        -: 2146:
    #####: 2147:			if (i <= 0) continue;
    #####: 2148:			if (FD_ISSET(fileno(stdin),&readfds))
        -: 2149:				read_from_terminal = 1;
        -: 2150:#endif
    #####: 2151:			if (FD_ISSET(s,&readfds))
        -: 2152:				read_from_sslcon = 1;
        -: 2153:			}
    #####: 2154:		if (read_from_terminal)
        -: 2155:			{
    #####: 2156:			if (s_crlf)
        -: 2157:				{
        -: 2158:				int j, lf_num;
        -: 2159:
    #####: 2160:				i=raw_read_stdin(buf, bufsize/2);
        -: 2161:				lf_num = 0;
        -: 2162:				/* both loops are skipped when i <= 0 */
    #####: 2163:				for (j = 0; j < i; j++)
    #####: 2164:					if (buf[j] == '\n')
    #####: 2165:						lf_num++;
    #####: 2166:				for (j = i-1; j >= 0; j--)
        -: 2167:					{
    #####: 2168:					buf[j+lf_num] = buf[j];
    #####: 2169:					if (buf[j] == '\n')
        -: 2170:						{
    #####: 2171:						lf_num--;
    #####: 2172:						i++;
    #####: 2173:						buf[j+lf_num] = '\r';
        -: 2174:						}
        -: 2175:					}
    #####: 2176:				assert(lf_num == 0);
        -: 2177:				}
        -: 2178:			else
    #####: 2179:				i=raw_read_stdin(buf,bufsize);
    #####: 2180:			if (!s_quiet)
        -: 2181:				{
    #####: 2182:				if ((i <= 0) || (buf[0] == 'Q'))
        -: 2183:					{
    #####: 2184:					BIO_printf(bio_s_out,"DONE\n");
    #####: 2185:					SHUTDOWN(s);
    #####: 2186:					close_accept_socket();
        -: 2187:					ret= -11;
    #####: 2188:					goto err;
        -: 2189:					}
    #####: 2190:				if ((i <= 0) || (buf[0] == 'q'))
        -: 2191:					{
    #####: 2192:					BIO_printf(bio_s_out,"DONE\n");
    #####: 2193:					if (SSL_version(con) != DTLS1_VERSION)
    #####: 2194:                        SHUTDOWN(s);
        -: 2195:	/*				close_accept_socket();
        -: 2196:					ret= -11;*/
        -: 2197:					goto err;
        -: 2198:					}
        -: 2199:
        -: 2200:#ifndef OPENSSL_NO_HEARTBEATS
    #####: 2201:				if ((buf[0] == 'B') &&
    #####: 2202:					((buf[1] == '\n') || (buf[1] == '\r')))
        -: 2203:					{
    #####: 2204:					BIO_printf(bio_err,"HEARTBEATING\n");
    #####: 2205:					SSL_heartbeat(con);
        -: 2206:					i=0;
    #####: 2207:					continue;
        -: 2208:					}
        -: 2209:#endif
    #####: 2210:				if ((buf[0] == 'r') && 
    #####: 2211:					((buf[1] == '\n') || (buf[1] == '\r')))
        -: 2212:					{
    #####: 2213:					SSL_renegotiate(con);
    #####: 2214:					i=SSL_do_handshake(con);
        -: 2215:					printf("SSL_do_handshake -> %d\n",i);
        -: 2216:					i=0; /*13; */
    #####: 2217:					continue;
        -: 2218:					/* strcpy(buf,"server side RE-NEGOTIATE\n"); */
        -: 2219:					}
    #####: 2220:				if ((buf[0] == 'R') &&
    #####: 2221:					((buf[1] == '\n') || (buf[1] == '\r')))
        -: 2222:					{
    #####: 2223:					SSL_set_verify(con,
        -: 2224:						SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,NULL);
    #####: 2225:					SSL_renegotiate(con);
    #####: 2226:					i=SSL_do_handshake(con);
        -: 2227:					printf("SSL_do_handshake -> %d\n",i);
        -: 2228:					i=0; /* 13; */
    #####: 2229:					continue;
        -: 2230:					/* strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n"); */
        -: 2231:					}
    #####: 2232:				if (buf[0] == 'P')
        -: 2233:					{
        -: 2234:					static const char *str="Lets print some clear text\n";
    #####: 2235:					BIO_write(SSL_get_wbio(con),str,strlen(str));
        -: 2236:					}
    #####: 2237:				if (buf[0] == 'S')
        -: 2238:					{
    #####: 2239:					print_stats(bio_s_out,SSL_get_SSL_CTX(con));
        -: 2240:					}
        -: 2241:				}
        -: 2242:#ifdef CHARSET_EBCDIC
        -: 2243:			ebcdic2ascii(buf,buf,i);
        -: 2244:#endif
        -: 2245:			l=k=0;
        -: 2246:			for (;;)
        -: 2247:				{
        -: 2248:				/* should do a select for the write */
        -: 2249:#ifdef RENEG
        -: 2250:{ static count=0; if (++count == 100) { count=0; SSL_renegotiate(con); } }
        -: 2251:#endif
    #####: 2252:				k=SSL_write(con,&(buf[l]),(unsigned int)i);
        -: 2253:#ifndef OPENSSL_NO_SRP
    #####: 2254:				while (SSL_get_error(con,k) == SSL_ERROR_WANT_X509_LOOKUP)
        -: 2255:					{
    #####: 2256:					BIO_printf(bio_s_out,"LOOKUP renego during write\n");
    #####: 2257:					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
    #####: 2258:					if (srp_callback_parm.user) 
    #####: 2259:						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
        -: 2260:					else 
    #####: 2261:						BIO_printf(bio_s_out,"LOOKUP not successful\n");
    #####: 2262:						k=SSL_write(con,&(buf[l]),(unsigned int)i);
        -: 2263:					}
        -: 2264:#endif
    #####: 2265:				switch (SSL_get_error(con,k))
        -: 2266:					{
        -: 2267:				case SSL_ERROR_NONE:
        -: 2268:					break;
        -: 2269:				case SSL_ERROR_WANT_WRITE:
        -: 2270:				case SSL_ERROR_WANT_READ:
        -: 2271:				case SSL_ERROR_WANT_X509_LOOKUP:
    #####: 2272:					BIO_printf(bio_s_out,"Write BLOCK\n");
    #####: 2273:					break;
        -: 2274:				case SSL_ERROR_SYSCALL:
        -: 2275:				case SSL_ERROR_SSL:
    #####: 2276:					BIO_printf(bio_s_out,"ERROR\n");
    #####: 2277:					ERR_print_errors(bio_err);
        -: 2278:					ret=1;
    #####: 2279:					goto err;
        -: 2280:					/* break; */
        -: 2281:				case SSL_ERROR_ZERO_RETURN:
    #####: 2282:					BIO_printf(bio_s_out,"DONE\n");
        -: 2283:					ret=1;
    #####: 2284:					goto err;
        -: 2285:					}
    #####: 2286:				l+=k;
    #####: 2287:				i-=k;
    #####: 2288:				if (i <= 0) break;
        -: 2289:				}
        -: 2290:			}
    #####: 2291:		if (read_from_sslcon)
        -: 2292:			{
    #####: 2293:			if (!SSL_is_init_finished(con))
        -: 2294:				{
    #####: 2295:				i=init_ssl_connection(con);
        -: 2296:				
    #####: 2297:				if (i < 0)
        -: 2298:					{
        -: 2299:					ret=0;
        -: 2300:					goto err;
        -: 2301:					}
    #####: 2302:				else if (i == 0)
        -: 2303:					{
        -: 2304:					ret=1;
        -: 2305:					goto err;
        -: 2306:					}
        -: 2307:				}
        -: 2308:			else
        -: 2309:				{
        -: 2310:again:	
    #####: 2311:				i=SSL_read(con,(char *)buf,bufsize);
        -: 2312:#ifndef OPENSSL_NO_SRP
    #####: 2313:				while (SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP)
        -: 2314:					{
    #####: 2315:					BIO_printf(bio_s_out,"LOOKUP renego during read\n");
    #####: 2316:					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
    #####: 2317:					if (srp_callback_parm.user) 
    #####: 2318:						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
        -: 2319:					else 
    #####: 2320:						BIO_printf(bio_s_out,"LOOKUP not successful\n");
    #####: 2321:					i=SSL_read(con,(char *)buf,bufsize);
        -: 2322:					}
        -: 2323:#endif
    #####: 2324:				switch (SSL_get_error(con,i))
        -: 2325:					{
        -: 2326:				case SSL_ERROR_NONE:
        -: 2327:#ifdef CHARSET_EBCDIC
        -: 2328:					ascii2ebcdic(buf,buf,i);
        -: 2329:#endif
    #####: 2330:					raw_write_stdout(buf,
        -: 2331:						(unsigned int)i);
    #####: 2332:					if (SSL_pending(con)) goto again;
        -: 2333:					break;
        -: 2334:				case SSL_ERROR_WANT_WRITE:
        -: 2335:				case SSL_ERROR_WANT_READ:
    #####: 2336:					BIO_printf(bio_s_out,"Read BLOCK\n");
    #####: 2337:					break;
        -: 2338:				case SSL_ERROR_SYSCALL:
        -: 2339:				case SSL_ERROR_SSL:
    #####: 2340:					BIO_printf(bio_s_out,"ERROR\n");
    #####: 2341:					ERR_print_errors(bio_err);
        -: 2342:					ret=1;
    #####: 2343:					goto err;
        -: 2344:				case SSL_ERROR_ZERO_RETURN:
    #####: 2345:					BIO_printf(bio_s_out,"DONE\n");
        -: 2346:					ret=1;
    #####: 2347:					goto err;
        -: 2348:					}
        -: 2349:				}
        -: 2350:			}
        -: 2351:		}
        -: 2352:err:
    #####: 2353:	if (con != NULL)
        -: 2354:		{
    #####: 2355:		BIO_printf(bio_s_out,"shutting down SSL\n");
        -: 2356:#if 1
    #####: 2357:		SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
        -: 2358:#else
        -: 2359:		SSL_shutdown(con);
        -: 2360:#endif
    #####: 2361:		SSL_free(con);
        -: 2362:		}
    #####: 2363:	BIO_printf(bio_s_out,"CONNECTION CLOSED\n");
    #####: 2364:	if (buf != NULL)
        -: 2365:		{
    #####: 2366:		OPENSSL_cleanse(buf,bufsize);
    #####: 2367:		OPENSSL_free(buf);
        -: 2368:		}
    #####: 2369:	if (ret >= 0)
    #####: 2370:		BIO_printf(bio_s_out,"ACCEPT\n");
    #####: 2371:	return(ret);
        -: 2372:	}
        -: 2373:
    #####: 2374:static void close_accept_socket(void)
        -: 2375:	{
    #####: 2376:	BIO_printf(bio_err,"shutdown accept socket\n");
    #####: 2377:	if (accept_socket >= 0)
        -: 2378:		{
    #####: 2379:		SHUTDOWN2(accept_socket);
        -: 2380:		}
    #####: 2381:	}
        -: 2382:
    #####: 2383:static int init_ssl_connection(SSL *con)
        -: 2384:	{
        -: 2385:	int i;
        -: 2386:	const char *str;
        -: 2387:	X509 *peer;
        -: 2388:	long verify_error;
        -: 2389:	MS_STATIC char buf[BUFSIZ];
        -: 2390:#ifndef OPENSSL_NO_KRB5
        -: 2391:	char *client_princ;
        -: 2392:#endif
        -: 2393:#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
        -: 2394:	const unsigned char *next_proto_neg;
        -: 2395:	unsigned next_proto_neg_len;
        -: 2396:#endif
        -: 2397:	unsigned char *exportedkeymat;
        -: 2398:
        -: 2399:
    #####: 2400:	i=SSL_accept(con);
        -: 2401:#ifndef OPENSSL_NO_SRP
    #####: 2402:	while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
        -: 2403:		{
    #####: 2404:			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
    #####: 2405:			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
    #####: 2406:			if (srp_callback_parm.user) 
    #####: 2407:				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
        -: 2408:			else 
    #####: 2409:				BIO_printf(bio_s_out,"LOOKUP not successful\n");
    #####: 2410:			i=SSL_accept(con);
        -: 2411:		}
        -: 2412:#endif
    #####: 2413:	if (i <= 0)
        -: 2414:		{
    #####: 2415:		if (BIO_sock_should_retry(i))
        -: 2416:			{
    #####: 2417:			BIO_printf(bio_s_out,"DELAY\n");
    #####: 2418:			return(1);
        -: 2419:			}
        -: 2420:
    #####: 2421:		BIO_printf(bio_err,"ERROR\n");
    #####: 2422:		verify_error=SSL_get_verify_result(con);
    #####: 2423:		if (verify_error != X509_V_OK)
        -: 2424:			{
    #####: 2425:			BIO_printf(bio_err,"verify error:%s\n",
        -: 2426:				X509_verify_cert_error_string(verify_error));
        -: 2427:			}
        -: 2428:		else
    #####: 2429:			ERR_print_errors(bio_err);
        -: 2430:		return(0);
        -: 2431:		}
        -: 2432:
    #####: 2433:	PEM_write_bio_SSL_SESSION(bio_s_out,SSL_get_session(con));
        -: 2434:
    #####: 2435:	peer=SSL_get_peer_certificate(con);
    #####: 2436:	if (peer != NULL)
        -: 2437:		{
    #####: 2438:		BIO_printf(bio_s_out,"Client certificate\n");
    #####: 2439:		PEM_write_bio_X509(bio_s_out,peer);
    #####: 2440:		X509_NAME_oneline(X509_get_subject_name(peer),buf,sizeof buf);
    #####: 2441:		BIO_printf(bio_s_out,"subject=%s\n",buf);
    #####: 2442:		X509_NAME_oneline(X509_get_issuer_name(peer),buf,sizeof buf);
    #####: 2443:		BIO_printf(bio_s_out,"issuer=%s\n",buf);
    #####: 2444:		X509_free(peer);
        -: 2445:		}
        -: 2446:
    #####: 2447:	if (SSL_get_shared_ciphers(con,buf,sizeof buf) != NULL)
    #####: 2448:		BIO_printf(bio_s_out,"Shared ciphers:%s\n",buf);
    #####: 2449:	str=SSL_CIPHER_get_name(SSL_get_current_cipher(con));
    #####: 2450:	BIO_printf(bio_s_out,"CIPHER is %s\n",(str != NULL)?str:"(NONE)");
        -: 2451:
        -: 2452:#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
    #####: 2453:	SSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);
    #####: 2454:	if (next_proto_neg)
        -: 2455:		{
    #####: 2456:		BIO_printf(bio_s_out,"NEXTPROTO is ");
    #####: 2457:		BIO_write(bio_s_out, next_proto_neg, next_proto_neg_len);
    #####: 2458:		BIO_printf(bio_s_out, "\n");
        -: 2459:		}
        -: 2460:#endif
        -: 2461:#ifndef OPENSSL_NO_SRTP
        -: 2462:	{
    #####: 2463:	SRTP_PROTECTION_PROFILE *srtp_profile
        -: 2464:	  = SSL_get_selected_srtp_profile(con);
        -: 2465:
    #####: 2466:	if(srtp_profile)
    #####: 2467:		BIO_printf(bio_s_out,"SRTP Extension negotiated, profile=%s\n",
        -: 2468:			   srtp_profile->name);
        -: 2469:	}
        -: 2470:#endif
    #####: 2471:	if (SSL_cache_hit(con)) BIO_printf(bio_s_out,"Reused session-id\n");
    #####: 2472:	if (SSL_ctrl(con,SSL_CTRL_GET_FLAGS,0,NULL) &
        -: 2473:		TLS1_FLAGS_TLS_PADDING_BUG)
    #####: 2474:		BIO_printf(bio_s_out,
        -: 2475:			   "Peer has incorrect TLSv1 block padding\n");
        -: 2476:#ifndef OPENSSL_NO_KRB5
        -: 2477:	client_princ = kssl_ctx_get0_client_princ(SSL_get0_kssl_ctx(con));
        -: 2478:	if (client_princ != NULL)
        -: 2479:		{
        -: 2480:		BIO_printf(bio_s_out,"Kerberos peer principal is %s\n",
        -: 2481:								client_princ);
        -: 2482:		}
        -: 2483:#endif /* OPENSSL_NO_KRB5 */
    #####: 2484:	BIO_printf(bio_s_out, "Secure Renegotiation IS%s supported\n",
    #####: 2485:		      SSL_get_secure_renegotiation_support(con) ? "" : " NOT");
    #####: 2486:	if (keymatexportlabel != NULL)
        -: 2487:		{
    #####: 2488:		BIO_printf(bio_s_out, "Keying material exporter:\n");
    #####: 2489:		BIO_printf(bio_s_out, "    Label: '%s'\n", keymatexportlabel);
    #####: 2490:		BIO_printf(bio_s_out, "    Length: %i bytes\n",
        -: 2491:			   keymatexportlen);
    #####: 2492:		exportedkeymat = OPENSSL_malloc(keymatexportlen);
    #####: 2493:		if (exportedkeymat != NULL)
        -: 2494:			{
    #####: 2495:			if (!SSL_export_keying_material(con, exportedkeymat,
        -: 2496:						        keymatexportlen,
        -: 2497:						        keymatexportlabel,
        -: 2498:						        strlen(keymatexportlabel),
        -: 2499:						        NULL, 0, 0))
        -: 2500:				{
    #####: 2501:				BIO_printf(bio_s_out, "    Error\n");
        -: 2502:				}
        -: 2503:			else
        -: 2504:				{
    #####: 2505:				BIO_printf(bio_s_out, "    Keying material: ");
    #####: 2506:				for (i=0; i<keymatexportlen; i++)
    #####: 2507:					BIO_printf(bio_s_out, "%02X",
    #####: 2508:						   exportedkeymat[i]);
    #####: 2509:				BIO_printf(bio_s_out, "\n");
        -: 2510:				}
    #####: 2511:			OPENSSL_free(exportedkeymat);
        -: 2512:			}
        -: 2513:		}
        -: 2514:
        -: 2515:	return(1);
        -: 2516:	}
        -: 2517:
        -: 2518:#ifndef OPENSSL_NO_DH
    #####: 2519:static DH *load_dh_param(const char *dhfile)
        -: 2520:	{
        -: 2521:	DH *ret=NULL;
        -: 2522:	BIO *bio;
        -: 2523:
    #####: 2524:	if ((bio=BIO_new_file(dhfile,"r")) == NULL)
        -: 2525:		goto err;
    #####: 2526:	ret=PEM_read_bio_DHparams(bio,NULL,NULL,NULL);
        -: 2527:err:
    #####: 2528:	if (bio != NULL) BIO_free(bio);
    #####: 2529:	return(ret);
        -: 2530:	}
        -: 2531:#endif
        -: 2532:#ifndef OPENSSL_NO_KRB5
        -: 2533:	char *client_princ;
        -: 2534:#endif
        -: 2535:
        -: 2536:#if 0
        -: 2537:static int load_CA(SSL_CTX *ctx, char *file)
        -: 2538:	{
        -: 2539:	FILE *in;
        -: 2540:	X509 *x=NULL;
        -: 2541:
        -: 2542:	if ((in=fopen(file,"r")) == NULL)
        -: 2543:		return(0);
        -: 2544:
        -: 2545:	for (;;)
        -: 2546:		{
        -: 2547:		if (PEM_read_X509(in,&x,NULL) == NULL)
        -: 2548:			break;
        -: 2549:		SSL_CTX_add_client_CA(ctx,x);
        -: 2550:		}
        -: 2551:	if (x != NULL) X509_free(x);
        -: 2552:	fclose(in);
        -: 2553:	return(1);
        -: 2554:	}
        -: 2555:#endif
        -: 2556:
    #####: 2557:static int www_body(char *hostname, int s, unsigned char *context)
        -: 2558:	{
        -: 2559:	char *buf=NULL;
        -: 2560:	int ret=1;
        -: 2561:	int i,j,k,dot;
        -: 2562:	SSL *con;
        -: 2563:	const SSL_CIPHER *c;
        -: 2564:	BIO *io,*ssl_bio,*sbio;
        -: 2565:#ifndef OPENSSL_NO_KRB5
        -: 2566:	KSSL_CTX *kctx;
        -: 2567:#endif
        -: 2568:
    #####: 2569:	buf=OPENSSL_malloc(bufsize);
    #####: 2570:	if (buf == NULL) return(0);
    #####: 2571:	io=BIO_new(BIO_f_buffer());
    #####: 2572:	ssl_bio=BIO_new(BIO_f_ssl());
    #####: 2573:	if ((io == NULL) || (ssl_bio == NULL)) goto err;
        -: 2574:
        -: 2575:#ifdef FIONBIO	
    #####: 2576:	if (s_nbio)
        -: 2577:		{
    #####: 2578:		unsigned long sl=1;
        -: 2579:
    #####: 2580:		if (!s_quiet)
    #####: 2581:			BIO_printf(bio_err,"turning on non blocking io\n");
    #####: 2582:		if (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)
    #####: 2583:			ERR_print_errors(bio_err);
        -: 2584:		}
        -: 2585:#endif
        -: 2586:
        -: 2587:	/* lets make the output buffer a reasonable size */
    #####: 2588:	if (!BIO_set_write_buffer_size(io,bufsize)) goto err;
        -: 2589:
    #####: 2590:	if ((con=SSL_new(ctx)) == NULL) goto err;
        -: 2591:#ifndef OPENSSL_NO_TLSEXT
    #####: 2592:		if (s_tlsextdebug)
        -: 2593:			{
    #####: 2594:			SSL_set_tlsext_debug_callback(con, tlsext_cb);
    #####: 2595:			SSL_set_tlsext_debug_arg(con, bio_s_out);
        -: 2596:			}
        -: 2597:#endif
        -: 2598:#ifndef OPENSSL_NO_KRB5
        -: 2599:	if ((kctx = kssl_ctx_new()) != NULL)
        -: 2600:		{
        -: 2601:		kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
        -: 2602:		kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
        -: 2603:		}
        -: 2604:#endif	/* OPENSSL_NO_KRB5 */
    #####: 2605:	if(context) SSL_set_session_id_context(con, context,
    #####: 2606:					       strlen((char *)context));
        -: 2607:
    #####: 2608:	sbio=BIO_new_socket(s,BIO_NOCLOSE);
    #####: 2609:	if (s_nbio_test)
        -: 2610:		{
        -: 2611:		BIO *test;
        -: 2612:
    #####: 2613:		test=BIO_new(BIO_f_nbio_test());
    #####: 2614:		sbio=BIO_push(test,sbio);
        -: 2615:		}
    #####: 2616:	SSL_set_bio(con,sbio,sbio);
    #####: 2617:	SSL_set_accept_state(con);
        -: 2618:
        -: 2619:	/* SSL_set_fd(con,s); */
    #####: 2620:	BIO_set_ssl(ssl_bio,con,BIO_CLOSE);
    #####: 2621:	BIO_push(io,ssl_bio);
        -: 2622:#ifdef CHARSET_EBCDIC
        -: 2623:	io = BIO_push(BIO_new(BIO_f_ebcdic_filter()),io);
        -: 2624:#endif
        -: 2625:
    #####: 2626:	if (s_debug)
        -: 2627:		{
    #####: 2628:		SSL_set_debug(con, 1);
    #####: 2629:		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
    #####: 2630:		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
        -: 2631:		}
    #####: 2632:	if (s_msg)
        -: 2633:		{
    #####: 2634:		SSL_set_msg_callback(con, msg_cb);
    #####: 2635:		SSL_set_msg_callback_arg(con, bio_s_out);
        -: 2636:		}
        -: 2637:
        -: 2638:	for (;;)
        -: 2639:		{
    #####: 2640:		if (hack)
        -: 2641:			{
    #####: 2642:			i=SSL_accept(con);
        -: 2643:#ifndef OPENSSL_NO_SRP
    #####: 2644:			while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
        -: 2645:		{
    #####: 2646:			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
    #####: 2647:			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
    #####: 2648:			if (srp_callback_parm.user) 
    #####: 2649:				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
        -: 2650:			else 
    #####: 2651:				BIO_printf(bio_s_out,"LOOKUP not successful\n");
    #####: 2652:			i=SSL_accept(con);
        -: 2653:		}
        -: 2654:#endif
    #####: 2655:			switch (SSL_get_error(con,i))
        -: 2656:				{
        -: 2657:			case SSL_ERROR_NONE:
        -: 2658:				break;
        -: 2659:			case SSL_ERROR_WANT_WRITE:
        -: 2660:			case SSL_ERROR_WANT_READ:
        -: 2661:			case SSL_ERROR_WANT_X509_LOOKUP:
    #####: 2662:				continue;
        -: 2663:			case SSL_ERROR_SYSCALL:
        -: 2664:			case SSL_ERROR_SSL:
        -: 2665:			case SSL_ERROR_ZERO_RETURN:
        -: 2666:				ret=1;
        -: 2667:				goto err;
        -: 2668:				/* break; */
        -: 2669:				}
        -: 2670:
    #####: 2671:			SSL_renegotiate(con);
    #####: 2672:			SSL_write(con,NULL,0);
        -: 2673:			}
        -: 2674:
    #####: 2675:		i=BIO_gets(io,buf,bufsize-1);
    #####: 2676:		if (i < 0) /* error */
        -: 2677:			{
    #####: 2678:			if (!BIO_should_retry(io))
        -: 2679:				{
    #####: 2680:				if (!s_quiet)
    #####: 2681:					ERR_print_errors(bio_err);
        -: 2682:				goto err;
        -: 2683:				}
        -: 2684:			else
        -: 2685:				{
    #####: 2686:				BIO_printf(bio_s_out,"read R BLOCK\n");
        -: 2687:#if defined(OPENSSL_SYS_NETWARE)
        -: 2688:            delay(1000);
        -: 2689:#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
    #####: 2690:				sleep(1);
        -: 2691:#endif
    #####: 2692:				continue;
        -: 2693:				}
        -: 2694:			}
    #####: 2695:		else if (i == 0) /* end of input */
        -: 2696:			{
        -: 2697:			ret=1;
        -: 2698:			goto end;
        -: 2699:			}
        -: 2700:
        -: 2701:		/* else we have data */
    #####: 2702:		if (	((www == 1) && (strncmp("GET ",buf,4) == 0)) ||
    #####: 2703:			((www == 2) && (strncmp("GET /stats ",buf,10) == 0)))
        -: 2704:			{
        -: 2705:			char *p;
        -: 2706:			X509 *peer;
        -: 2707:			STACK_OF(SSL_CIPHER) *sk;
        -: 2708:			static const char *space="                          ";
        -: 2709:
    #####: 2710:			BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
    #####: 2711:			BIO_puts(io,"<HTML><BODY BGCOLOR=\"#ffffff\">\n");
    #####: 2712:			BIO_puts(io,"<pre>\n");
        -: 2713:/*			BIO_puts(io,SSLeay_version(SSLEAY_VERSION));*/
    #####: 2714:			BIO_puts(io,"\n");
    #####: 2715:			for (i=0; i<local_argc; i++)
        -: 2716:				{
    #####: 2717:				BIO_puts(io,local_argv[i]);
    #####: 2718:				BIO_write(io," ",1);
        -: 2719:				}
    #####: 2720:			BIO_puts(io,"\n");
        -: 2721:
    #####: 2722:			BIO_printf(io,
        -: 2723:				"Secure Renegotiation IS%s supported\n",
    #####: 2724:		      		SSL_get_secure_renegotiation_support(con) ?
        -: 2725:							"" : " NOT");
        -: 2726:
        -: 2727:			/* The following is evil and should not really
        -: 2728:			 * be done */
    #####: 2729:			BIO_printf(io,"Ciphers supported in s_server binary\n");
    #####: 2730:			sk=SSL_get_ciphers(con);
    #####: 2731:			j=sk_SSL_CIPHER_num(sk);
    #####: 2732:			for (i=0; i<j; i++)
        -: 2733:				{
    #####: 2734:				c=sk_SSL_CIPHER_value(sk,i);
    #####: 2735:				BIO_printf(io,"%-11s:%-25s",
        -: 2736:					SSL_CIPHER_get_version(c),
        -: 2737:					SSL_CIPHER_get_name(c));
    #####: 2738:				if ((((i+1)%2) == 0) && (i+1 != j))
    #####: 2739:					BIO_puts(io,"\n");
        -: 2740:				}
    #####: 2741:			BIO_puts(io,"\n");
    #####: 2742:			p=SSL_get_shared_ciphers(con,buf,bufsize);
    #####: 2743:			if (p != NULL)
        -: 2744:				{
    #####: 2745:				BIO_printf(io,"---\nCiphers common between both SSL end points:\n");
        -: 2746:				j=i=0;
    #####: 2747:				while (*p)
        -: 2748:					{
    #####: 2749:					if (*p == ':')
        -: 2750:						{
    #####: 2751:						BIO_write(io,space,26-j);
    #####: 2752:						i++;
        -: 2753:						j=0;
    #####: 2754:						BIO_write(io,((i%3)?" ":"\n"),1);
        -: 2755:						}
        -: 2756:					else
        -: 2757:						{
    #####: 2758:						BIO_write(io,p,1);
    #####: 2759:						j++;
        -: 2760:						}
    #####: 2761:					p++;
        -: 2762:					}
    #####: 2763:				BIO_puts(io,"\n");
        -: 2764:				}
    #####: 2765:			BIO_printf(io,(SSL_cache_hit(con)
        -: 2766:				?"---\nReused, "
        -: 2767:				:"---\nNew, "));
    #####: 2768:			c=SSL_get_current_cipher(con);
    #####: 2769:			BIO_printf(io,"%s, Cipher is %s\n",
        -: 2770:				SSL_CIPHER_get_version(c),
        -: 2771:				SSL_CIPHER_get_name(c));
    #####: 2772:			SSL_SESSION_print(io,SSL_get_session(con));
    #####: 2773:			BIO_printf(io,"---\n");
    #####: 2774:			print_stats(io,SSL_get_SSL_CTX(con));
    #####: 2775:			BIO_printf(io,"---\n");
    #####: 2776:			peer=SSL_get_peer_certificate(con);
    #####: 2777:			if (peer != NULL)
        -: 2778:				{
    #####: 2779:				BIO_printf(io,"Client certificate\n");
    #####: 2780:				X509_print(io,peer);
    #####: 2781:				PEM_write_bio_X509(io,peer);
        -: 2782:				}
        -: 2783:			else
    #####: 2784:				BIO_puts(io,"no client certificate available\n");
    #####: 2785:			BIO_puts(io,"</BODY></HTML>\r\n\r\n");
    #####: 2786:			break;
        -: 2787:			}
    #####: 2788:		else if ((www == 2 || www == 3)
    #####: 2789:                         && (strncmp("GET /",buf,5) == 0))
        -: 2790:			{
        -: 2791:			BIO *file;
        -: 2792:			char *p,*e;
        -: 2793:			static const char *text="HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n";
        -: 2794:
        -: 2795:			/* skip the '/' */
    #####: 2796:			p= &(buf[5]);
        -: 2797:
        -: 2798:			dot = 1;
    #####: 2799:			for (e=p; *e != '\0'; e++)
        -: 2800:				{
    #####: 2801:				if (e[0] == ' ')
        -: 2802:					break;
        -: 2803:
    #####: 2804:				switch (dot)
        -: 2805:					{
        -: 2806:				case 1:
    #####: 2807:					dot = (e[0] == '.') ? 2 : 0;
    #####: 2808:					break;
        -: 2809:				case 2:
    #####: 2810:					dot = (e[0] == '.') ? 3 : 0;
    #####: 2811:					break;
        -: 2812:				case 3:
    #####: 2813:					dot = (e[0] == '/') ? -1 : 0;
    #####: 2814:					break;
        -: 2815:					}
    #####: 2816:				if (dot == 0)
    #####: 2817:					dot = (e[0] == '/') ? 1 : 0;
        -: 2818:				}
    #####: 2819:			dot = (dot == 3) || (dot == -1); /* filename contains ".." component */
        -: 2820:
    #####: 2821:			if (*e == '\0')
        -: 2822:				{
    #####: 2823:				BIO_puts(io,text);
    #####: 2824:				BIO_printf(io,"'%s' is an invalid file name\r\n",p);
    #####: 2825:				break;
        -: 2826:				}
    #####: 2827:			*e='\0';
        -: 2828:
    #####: 2829:			if (dot)
        -: 2830:				{
    #####: 2831:				BIO_puts(io,text);
    #####: 2832:				BIO_printf(io,"'%s' contains '..' reference\r\n",p);
    #####: 2833:				break;
        -: 2834:				}
        -: 2835:
    #####: 2836:			if (*p == '/')
        -: 2837:				{
    #####: 2838:				BIO_puts(io,text);
    #####: 2839:				BIO_printf(io,"'%s' is an invalid path\r\n",p);
    #####: 2840:				break;
        -: 2841:				}
        -: 2842:
        -: 2843:#if 0
        -: 2844:			/* append if a directory lookup */
        -: 2845:			if (e[-1] == '/')
        -: 2846:				strcat(p,"index.html");
        -: 2847:#endif
        -: 2848:
        -: 2849:			/* if a directory, do the index thang */
    #####: 2850:			if (app_isdir(p)>0)
        -: 2851:				{
        -: 2852:#if 0 /* must check buffer size */
        -: 2853:				strcat(p,"/index.html");
        -: 2854:#else
    #####: 2855:				BIO_puts(io,text);
    #####: 2856:				BIO_printf(io,"'%s' is a directory\r\n",p);
    #####: 2857:				break;
        -: 2858:#endif
        -: 2859:				}
        -: 2860:
    #####: 2861:			if ((file=BIO_new_file(p,"r")) == NULL)
        -: 2862:				{
    #####: 2863:				BIO_puts(io,text);
    #####: 2864:				BIO_printf(io,"Error opening '%s'\r\n",p);
    #####: 2865:				ERR_print_errors(io);
    #####: 2866:				break;
        -: 2867:				}
        -: 2868:
    #####: 2869:			if (!s_quiet)
    #####: 2870:				BIO_printf(bio_err,"FILE:%s\n",p);
        -: 2871:
    #####: 2872:                        if (www == 2)
        -: 2873:                                {
    #####: 2874:                                i=strlen(p);
    #####: 2875:                                if (	((i > 5) && (strcmp(&(p[i-5]),".html") == 0)) ||
    #####: 2876:                                        ((i > 4) && (strcmp(&(p[i-4]),".php") == 0)) ||
    #####: 2877:                                        ((i > 4) && (strcmp(&(p[i-4]),".htm") == 0)))
    #####: 2878:                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
        -: 2879:                                else
    #####: 2880:                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n");
        -: 2881:                                }
        -: 2882:			/* send the file */
        -: 2883:			for (;;)
        -: 2884:				{
    #####: 2885:				i=BIO_read(file,buf,bufsize);
    #####: 2886:				if (i <= 0) break;
        -: 2887:
        -: 2888:#ifdef RENEG
        -: 2889:				total_bytes+=i;
        -: 2890:				fprintf(stderr,"%d\n",i);
        -: 2891:				if (total_bytes > 3*1024)
        -: 2892:					{
        -: 2893:					total_bytes=0;
        -: 2894:					fprintf(stderr,"RENEGOTIATE\n");
        -: 2895:					SSL_renegotiate(con);
        -: 2896:					}
        -: 2897:#endif
        -: 2898:
    #####: 2899:				for (j=0; j<i; )
        -: 2900:					{
        -: 2901:#ifdef RENEG
        -: 2902:{ static count=0; if (++count == 13) { SSL_renegotiate(con); } }
        -: 2903:#endif
    #####: 2904:					k=BIO_write(io,&(buf[j]),i-j);
    #####: 2905:					if (k <= 0)
        -: 2906:						{
    #####: 2907:						if (!BIO_should_retry(io))
        -: 2908:							goto write_error;
        -: 2909:						else
        -: 2910:							{
    #####: 2911:							BIO_printf(bio_s_out,"rwrite W BLOCK\n");
        -: 2912:							}
        -: 2913:						}
        -: 2914:					else
        -: 2915:						{
    #####: 2916:						j+=k;
        -: 2917:						}
        -: 2918:					}
        -: 2919:				}
        -: 2920:write_error:
    #####: 2921:			BIO_free(file);
    #####: 2922:			break;
        -: 2923:			}
        -: 2924:		}
        -: 2925:
        -: 2926:	for (;;)
        -: 2927:		{
    #####: 2928:		i=(int)BIO_flush(io);
    #####: 2929:		if (i <= 0)
        -: 2930:			{
    #####: 2931:			if (!BIO_should_retry(io))
        -: 2932:				break;
        -: 2933:			}
        -: 2934:		else
        -: 2935:			break;
        -: 2936:		}
        -: 2937:end:
        -: 2938:#if 1
        -: 2939:	/* make sure we re-use sessions */
    #####: 2940:	SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
        -: 2941:#else
        -: 2942:	/* This kills performance */
        -: 2943:/*	SSL_shutdown(con); A shutdown gets sent in the
        -: 2944: *	BIO_free_all(io) procession */
        -: 2945:#endif
        -: 2946:
        -: 2947:err:
        -: 2948:
        -: 2949:	if (ret >= 0)
    #####: 2950:		BIO_printf(bio_s_out,"ACCEPT\n");
        -: 2951:
    #####: 2952:	if (buf != NULL) OPENSSL_free(buf);
    #####: 2953:	if (io != NULL) BIO_free_all(io);
        -: 2954:/*	if (ssl_bio != NULL) BIO_free(ssl_bio);*/
        -: 2955:	return(ret);
        -: 2956:	}
        -: 2957:
        -: 2958:#ifndef OPENSSL_NO_RSA
    #####: 2959:static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
        -: 2960:	{
        -: 2961:	BIGNUM *bn = NULL;
        -: 2962:	static RSA *rsa_tmp=NULL;
        -: 2963:
    #####: 2964:	if (!rsa_tmp && ((bn = BN_new()) == NULL))
    #####: 2965:		BIO_printf(bio_err,"Allocation error in generating RSA key\n");
    #####: 2966:	if (!rsa_tmp && bn)
        -: 2967:		{
    #####: 2968:		if (!s_quiet)
        -: 2969:			{
    #####: 2970:			BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
    #####: 2971:			(void)BIO_flush(bio_err);
        -: 2972:			}
    #####: 2973:		if(!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||
    #####: 2974:				!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
        -: 2975:			{
    #####: 2976:			if(rsa_tmp) RSA_free(rsa_tmp);
    #####: 2977:			rsa_tmp = NULL;
        -: 2978:			}
    #####: 2979:		if (!s_quiet)
        -: 2980:			{
    #####: 2981:			BIO_printf(bio_err,"\n");
    #####: 2982:			(void)BIO_flush(bio_err);
        -: 2983:			}
    #####: 2984:		BN_free(bn);
        -: 2985:		}
    #####: 2986:	return(rsa_tmp);
        -: 2987:	}
        -: 2988:#endif
        -: 2989:
        -: 2990:#define MAX_SESSION_ID_ATTEMPTS 10
    #####: 2991:static int generate_session_id(const SSL *ssl, unsigned char *id,
        -: 2992:				unsigned int *id_len)
        -: 2993:	{
        -: 2994:	unsigned int count = 0;
        -: 2995:	do	{
    #####: 2996:		RAND_pseudo_bytes(id, *id_len);
        -: 2997:		/* Prefix the session_id with the required prefix. NB: If our
        -: 2998:		 * prefix is too long, clip it - but there will be worse effects
        -: 2999:		 * anyway, eg. the server could only possibly create 1 session
        -: 3000:		 * ID (ie. the prefix!) so all future session negotiations will
        -: 3001:		 * fail due to conflicts. */
    #####: 3002:		memcpy(id, session_id_prefix,
    #####: 3003:			(strlen(session_id_prefix) < *id_len) ?
        -: 3004:			strlen(session_id_prefix) : *id_len);
        -: 3005:		}
    #####: 3006:	while(SSL_has_matching_session_id(ssl, id, *id_len) &&
    #####: 3007:		(++count < MAX_SESSION_ID_ATTEMPTS));
    #####: 3008:	if(count >= MAX_SESSION_ID_ATTEMPTS)
        -: 3009:		return 0;
    #####: 3010:	return 1;
        -: 3011:	}
